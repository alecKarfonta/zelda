{"instruction": "I want to create an enemy that can block Link's sword attacks with a shield and deflect projectiles back at him, similar to a Darknut but simpler. It should have 3 states: guarding, attacking, and a brief stun when its shield is hit. Could you help me implement this with proper collision and state management in OoT style?", "output": "```c\n// Forward declarations\ntypedef enum {\n    /* 0x00 */ SHIELD_GUARD,\n    /* 0x01 */ SHIELD_ATTACK,\n    /* 0x02 */ SHIELD_STUN\n} ShieldKnightState;\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ Vec3s jointTable[20];\n    /* 0x0208 */ Vec3s morphTable[20];\n    /* 0x0280 */ ShieldKnightState actionState;\n    /* 0x0284 */ s16 timer;\n    /* 0x0286 */ s16 stunTimer;\n    /* 0x0288 */ f32 blockAngle;\n    /* 0x028C */ ColliderCylinder bodyCollider;\n    /* 0x02D8 */ ColliderQuad shieldCollider;\n    /* 0x0358 */ Vec3f shieldPos;\n} EnShieldKnight; // size = 0x0364\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_HIT0,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 70, 0, { 0, 0, 0 } },\n};\n\nvoid EnShieldKnight_Init(Actor* thisx, PlayState* play) {\n    EnShieldKnight* this = (EnShieldKnight*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.015f);\n    this->actor.colChkInfo.mass = MASS_HEAVY;\n    this->actor.colChkInfo.health = 8;\n    \n    Collider_InitCylinder(play, &this->bodyCollider);\n    Collider_SetCylinder(play, &this->bodyCollider, &this->actor, &sCylinderInit);\n    \n    Collider_InitQuad(play, &this->shieldCollider);\n    \n    this->actionState = SHIELD_GUARD;\n    this->timer = 0;\n    this->stunTimer = 0;\n    \n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 30.0f);\n    this->actor.flags |= ACTOR_FLAG_0;\n}\n\nvoid EnShieldKnight_Destroy(Actor* thisx, PlayState* play) {\n    EnShieldKnight* this = (EnShieldKnight*)thisx;\n    \n    Collider_DestroyCylinder(play, &this->bodyCollider);\n    Collider_DestroyQuad(play, &this->shieldCollider);\n}\n\nvoid EnShieldKnight_Guard(EnShieldKnight* this, PlayState* play) {\n    // Face player\n    Math_SmoothStepToS(&this->actor.shape.rot.y, \n        Math_Vec3f_Yaw(&this->actor.world.pos, &GET_PLAYER(play)->actor.world.pos), 5, 0x300, 0);\n    \n    if (this->shieldCollider.base.acFlags & AC_HIT) {\n        this->actionState = SHIELD_STUN;\n        this->stunTimer = 20;\n        Audio_PlayActorSound2(&this->actor, NA_SE_EN_GOMA_JR_FREEZE);\n    }\n}\n\nvoid EnShieldKnight_Update(Actor* thisx, PlayState* play) {\n    EnShieldKnight* this = (EnShieldKnight*)thisx;\n    \n    if (this->stunTimer > 0) {\n        this->stunTimer--;\n        if (this->stunTimer == 0) {\n            this->actionState = SHIELD_GUARD;\n        }\n    }\n    \n    switch (this->actionState) {\n        case SHIELD_GUARD:\n            EnShieldKnight_Guard(this, play);\n            break;\n        case SHIELD_STUN:\n            // Handle stun animation/effects\n            break;\n    }\n    \n    // Update colliders\n    Collider_UpdateCylinder(&this->actor, &this->bodyCollider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->bodyCollider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->bodyCollider.base);\n}\n\nvoid EnShieldKnight_Draw(Actor* thisx, PlayState* play) {\n    EnShieldKnight* this = (EnShieldKnight*)thisx;\n    \n    func_8002EBCC(&this->actor, play, 0);\n    // Draw model and shield here\n}\n```"}
{"instruction": "I need help creating a system for remembering object collisions in OoT - like when Link hits switches or interacts with mechanisms. It should track the state across room transitions but not be too performance heavy. Can you show me how to implement this with proper collision detection and state management like the original game uses?", "output": "/* Object collision memory system using DynaPolyActor pattern */\n\ntypedef enum {\n    /* 0x00 */ COLMEM_STATE_IDLE,\n    /* 0x01 */ COLMEM_STATE_ACTIVE,\n    /* 0x02 */ COLMEM_STATE_DISABLED\n} ColMemState;\n\ntypedef struct {\n    /* 0x0000 */ DynaPolyActor dyna;\n    /* 0x014C */ ColMemState state;\n    /* 0x0150 */ s16 switchFlag; // Switch flag to persist state\n    /* 0x0152 */ s16 timer;\n    /* 0x0154 */ ColliderCylinder collider;\n    /* 0x01A0 */ Vec3f initPos;\n} ColMemObject; // size = 0x01AC\n\nvoid ColMemObject_Init(Actor* thisx, PlayState* play) {\n    ColMemObject* this = (ColMemObject*)thisx;\n    \n    Actor_ProcessInitChain(&this->dyna.actor, sInitChain);\n    Actor_SetScale(&this->dyna.actor, 0.1f);\n    \n    this->switchFlag = (this->dyna.actor.params >> 8) & 0xFF;\n    this->state = COLMEM_STATE_IDLE;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->dyna.actor, &sCylinderInit);\n    \n    this->initPos = this->dyna.actor.world.pos;\n    \n    if (Flags_GetSwitch(play, this->switchFlag)) {\n        this->state = COLMEM_STATE_ACTIVE;\n    }\n}\n\nvoid ColMemObject_Destroy(Actor* thisx, PlayState* play) {\n    ColMemObject* this = (ColMemObject*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid ColMemObject_Update(Actor* thisx, PlayState* play) {\n    ColMemObject* this = (ColMemObject*)thisx;\n    \n    if (this->timer > 0) {\n        this->timer--;\n    }\n    \n    switch(this->state) {\n        case COLMEM_STATE_IDLE:\n            if (this->collider.base.acFlags & AC_HIT) {\n                this->state = COLMEM_STATE_ACTIVE;\n                this->timer = 30;\n                Flags_SetSwitch(play, this->switchFlag);\n                Audio_PlayActorSound2(&this->dyna.actor, NA_SE_EV_SWITCH_ON);\n            }\n            break;\n            \n        case COLMEM_STATE_ACTIVE:\n            if (this->timer == 0) {\n                Math_ApproachF(&this->dyna.actor.world.pos.y,\n                              this->initPos.y - 40.0f, 0.5f, 2.0f);\n            }\n            break;\n    }\n    \n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid ColMemObject_Draw(Actor* thisx, PlayState* play) {\n    ColMemObject* this = (ColMemObject*)thisx;\n    Gfx_DrawDListOpa(play, gColMemDL);\n}\n\nconst ActorProfile Col_Mem_InitVars = {\n    ACTOR_COL_MEM,\n    ACTORCAT_PROP,\n    FLAGS_NONE,\n    OBJECT_GAMEPLAY_KEEP,\n    sizeof(ColMemObject),\n    (ActorFunc)ColMemObject_Init,\n    (ActorFunc)ColMemObject_Destroy,\n    (ActorFunc)ColMemObject_Update,\n    (ActorFunc)ColMemObject_Draw,\n};\n"}
{"instruction": "I'm trying to implement a sword-wielding enemy in OoT that has 3 attack patterns - a basic slash, a spin attack, and a jumping slash. It should track the player's position and switch between patterns based on distance. Can you help me implement this with proper collision detection and damage handling like other OoT enemies?", "output": "```c\n// Forward declarations\ntypedef enum {\n    /* 0x00 */ ENSWORD_IDLE,\n    /* 0x01 */ ENSWORD_WALK,\n    /* 0x02 */ ENSWORD_SLASH,\n    /* 0x03 */ ENSWORD_SPIN,\n    /* 0x04 */ ENSWORD_JUMP_SLASH,\n    /* 0x05 */ ENSWORD_DAMAGED,\n    /* 0x06 */ ENSWORD_DEATH\n} EnSwordState;\n\ntypedef struct EnSword {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ Vec3s jointTable[20];\n    /* 0x0208 */ Vec3s morphTable[20];\n    /* 0x0280 */ EnSwordState actionState;\n    /* 0x0284 */ s16 timer;\n    /* 0x0286 */ s16 attackCooldown;\n    /* 0x0288 */ f32 attackRange;\n    /* 0x028C */ Vec3f swordTip;\n    /* 0x0298 */ ColliderCylinder bodyCollider;\n    /* 0x02E4 */ ColliderQuad swordCollider;\n} EnSword; // size = 0x0364\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_HIT0,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 70, 0, { 0, 0, 0 } },\n};\n\nvoid EnSword_Init(Actor* thisx, PlayState* play) {\n    EnSword* this = (EnSword*)thisx;\n\n    Actor_SetScale(&this->actor, 0.01f);\n    SkelAnime_Init(play, &this->skelAnime, &gSwordSkel, &gSwordIdleAnim, this->jointTable, this->morphTable, 20);\n    \n    this->actor.colChkInfo.mass = MASS_HEAVY;\n    this->actor.colChkInfo.health = 8;\n    this->actor.gravity = -2.0f;\n    this->actionState = ENSWORD_IDLE;\n    this->attackRange = 150.0f;\n    \n    Collider_InitCylinder(play, &this->bodyCollider);\n    Collider_SetCylinderType1(play, &this->bodyCollider, &this->actor, &sCylinderInit);\n    \n    Collider_InitQuad(play, &this->swordCollider);\n    this->actor.colChkInfo.damageTable = &sDamageTable;\n    \n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 30.0f);\n    this->actor.targetMode = 3;\n}\n\nvoid EnSword_Destroy(Actor* thisx, PlayState* play) {\n    EnSword* this = (EnSword*)thisx;\n    Collider_DestroyCylinder(play, &this->bodyCollider);\n    Collider_DestroyQuad(play, &this->swordCollider);\n}\n\nvoid EnSword_SetupIdle(EnSword* this) {\n    Animation_Change(&this->skelAnime, &gSwordIdleAnim, 1.0f, 0.0f, \n                    Animation_GetLastFrame(&gSwordIdleAnim), ANIMMODE_LOOP, -8.0f);\n    this->actionState = ENSWORD_IDLE;\n    this->timer = 30;\n}\n\nvoid EnSword_Idle(EnSword* this, PlayState* play) {\n    Player* player = GET_PLAYER(play);\n    f32 dist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    SkelAnime_Update(&this->skelAnime);\n    \n    if (this->timer <= 0) {\n        if (dist < 100.0f) {\n            this->actionState = ENSWORD_SPIN;\n            this->timer = 40;\n        } else if (dist < 200.0f) {\n            this->actionState = ENSWORD_SLASH;\n            this->timer = 20;\n        } else if (dist < 300.0f) {\n            this->actionState = ENSWORD_WALK;\n        }\n    } else {\n        this->timer--;\n    }\n}\n\nvoid EnSword_Update(Actor* thisx, PlayState* play) {\n    EnSword* this = (EnSword*)thisx;\n    \n    if (this->actor.colChkInfo.health <= 0) {\n        Actor_Kill(&this->actor);\n        return;\n    }\n\n    switch (this->actionState) {\n        case ENSWORD_IDLE:\n            EnSword_Idle(this, play);\n            break;\n        case ENSWORD_SLASH:\n            // Attack logic here\n            break;\n        // Additional states...\n    }\n    \n    Collider_UpdateCylinder(&this->actor, &this->bodyCollider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->bodyCollider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->bodyCollider.base);\n}\n\nvoid EnSword_Draw(Actor* thisx, PlayState* play) {\n    EnSword* this = (EnSword*)thisx;\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    SkelAnime_DrawOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable, NULL, NULL, this);\n}\n```"}
{"instruction": "I need help creating a sand flow object for Spirit Temple that activates when hitting a switch. It should have a timer mechanic where the sand flows for 10 seconds, allowing Link to climb up. The sand should smoothly transition between flowing/stopped states and use proper Spirit Temple collision. Can you provide the full actor code with proper initialization and state management?", "output": "```c\n/**\n * Spirit Temple Sand Flow\n * Handles timed sand flow mechanics with collision and state management\n */\n\n#include \"z_obj_sand_flow.h\"\n#include \"assets/objects/object_sand_flow/object_sand_flow.h\"\n\ntypedef enum {\n    /* 0 */ SAND_STATE_OFF,\n    /* 1 */ SAND_STATE_ACTIVATING,\n    /* 2 */ SAND_STATE_ACTIVE,\n    /* 3 */ SAND_STATE_DEACTIVATING\n} SandFlowState;\n\ntypedef struct {\n    /* 0x0000 */ DynaPolyActor dyna;\n    /* 0x014C */ SandFlowState state;\n    /* 0x0150 */ s16 timer;\n    /* 0x0152 */ f32 flowSpeed;\n    /* 0x0156 */ f32 flowAlpha;\n    /* 0x015A */ ColliderJntSph collider;\n    /* 0x015E */ ColliderJntSphElement sphereElements[1];\n} ObjSandFlow; // size = 0x019C\n\n#define SAND_FLOW_DURATION 600 // 10 seconds at 60fps\n#define SAND_FLOW_SWITCH_FLAG 0x1C\n\nvoid ObjSandFlow_Init(Actor* thisx, PlayState* play) {\n    ObjSandFlow* this = (ObjSandFlow*)thisx;\n    CollisionHeader* colHeader = NULL;\n\n    Actor_ProcessInitChain(&this->dyna.actor, sInitChain);\n    DynaPolyActor_Init(&this->dyna, DPM_UNK);\n    CollisionHeader_GetVirtual(&gSandFlowCol, &colHeader);\n    this->dyna.bgId = DynaPoly_SetBgActor(play, &play->colCtx.dyna, &this->dyna.actor, colHeader);\n    \n    this->state = SAND_STATE_OFF;\n    this->flowSpeed = 0.0f;\n    this->flowAlpha = 0.0f;\n    Actor_SetScale(&this->dyna.actor, 0.1f);\n\n    // Initialize collision for climbing\n    Collider_InitJntSph(play, &this->collider);\n    Collider_SetJntSph(play, &this->collider, &this->dyna.actor, &sSphereInit, this->sphereElements);\n}\n\nvoid ObjSandFlow_Destroy(Actor* thisx, PlayState* play) {\n    ObjSandFlow* this = (ObjSandFlow*)thisx;\n    DynaPoly_DeleteBgActor(play, &play->colCtx.dyna, this->dyna.bgId);\n    Collider_DestroyJntSph(play, &this->collider);\n}\n\nvoid ObjSandFlow_UpdateFlow(ObjSandFlow* this) {\n    switch (this->state) {\n        case SAND_STATE_OFF:\n            if (Flags_GetSwitch(play, SAND_FLOW_SWITCH_FLAG)) {\n                this->state = SAND_STATE_ACTIVATING;\n                this->timer = SAND_FLOW_DURATION;\n                Audio_PlayActorSound2(&this->dyna.actor, NA_SE_EV_SAND_STORM - SFX_FLAG);\n            }\n            break;\n\n        case SAND_STATE_ACTIVATING:\n            Math_ApproachF(&this->flowSpeed, 1.0f, 0.1f, 0.02f);\n            Math_ApproachF(&this->flowAlpha, 255.0f, 0.1f, 5.0f);\n            if (this->flowSpeed >= 0.99f) {\n                this->state = SAND_STATE_ACTIVE;\n            }\n            break;\n\n        case SAND_STATE_ACTIVE:\n            if (--this->timer <= 0) {\n                this->state = SAND_STATE_DEACTIVATING;\n                Flags_UnsetSwitch(play, SAND_FLOW_SWITCH_FLAG);\n            }\n            break;\n\n        case SAND_STATE_DEACTIVATING:\n            Math_ApproachF(&this->flowSpeed, 0.0f, 0.1f, 0.02f);\n            Math_ApproachF(&this->flowAlpha, 0.0f, 0.1f, 5.0f);\n            if (this->flowSpeed <= 0.01f) {\n                this->state = SAND_STATE_OFF;\n            }\n            break;\n    }\n}\n\nvoid ObjSandFlow_Update(Actor* thisx, PlayState* play) {\n    ObjSandFlow* this = (ObjSandFlow*)thisx;\n    \n    ObjSandFlow_UpdateFlow(this);\n    \n    // Update collision for climbing\n    if (this->state == SAND_STATE_ACTIVE || this->state == SAND_STATE_ACTIVATING) {\n        Collider_UpdateCylinder(&this->dyna.actor, &this->collider);\n        CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    }\n}\n\nvoid ObjSandFlow_Draw(Actor* thisx, PlayState* play) {\n    ObjSandFlow* this = (ObjSandFlow*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Xlu(play->state.gfxCtx);\n    gDPSetPrimColor(POLY_XLU_DISP++, 0, 0, 255, 255, 200, (u8)this->flowAlpha);\n    \n    Matrix_Translate(this->dyna.actor.world.pos.x, this->dyna.actor.world.pos.y,\n                    this->dyna.actor.world.pos.z, MTXMODE_NEW);\n    Matrix_Scale(this->dyna.actor.scale.x, this->dyna.actor.scale.y, \n                this->dyna.actor.scale.z, MTXMODE_APPLY);\n    \n    gSPMatrix(POLY_XLU_DISP++, MATRIX_NEWMTX(play->state.gfxCtx),\n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n    gSPDisplayList(POLY_XLU_DISP++, gSandFlowDL);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile Obj_SandFlow_InitVars = {\n    ACTOR_OBJ_SAND_FLOW,\n    ACTORCAT_BG,\n    FLAGS,\n    OBJECT_SAND_FLOW,\n    sizeof(ObjSandFlow),\n    (ActorFunc)ObjSandFlow_Init,\n    (ActorFunc)ObjSandFlow_Destroy,\n    (ActorFunc)ObjSandFlow_Update,\n    (ActorFunc)ObjSandFlow_Draw,\n};\n```"}
{"instruction": "I want to create a moving platform that smoothly oscillates up and down with basic debug visualization. It should use proper actor initialization, collision, and state management like other OoT objects. Can you show me the complete implementation including the structure layout and all required functions?", "output": "```c\n/**\n * Oscillating Platform\n * Dynamic actor that moves up and down with smooth animation\n */\n\n#include \"z64animation.h\"\n#include \"z64actor.h\"\n#include \"z64math.h\"\n\ntypedef enum {\n    /* 0x00 */ OSCPLATFORM_STATE_IDLE,\n    /* 0x01 */ OSCPLATFORM_STATE_MOVING\n} OscPlatformState;\n\ntypedef struct {\n    /* 0x0000 */ DynaPolyActor dyna;\n    /* 0x014C */ OscPlatformState state;\n    /* 0x0150 */ f32 initY;\n    /* 0x0154 */ f32 targetY;\n    /* 0x0158 */ f32 moveSpeed;\n    /* 0x015C */ s16 timer;\n    /* 0x015E */ s16 oscillationRange;\n    /* 0x0160 */ ColliderJntSph collider;\n    /* 0x0180 */ ColliderJntSphElement colliderElements[1];\n} OscPlatform; // size = 0x01C0\n\nvoid OscPlatform_Init(Actor* thisx, PlayState* play) {\n    OscPlatform* this = (OscPlatform*)thisx;\n    CollisionHeader* colHeader = NULL;\n    \n    Actor_ProcessInitChain(&this->dyna.actor, sInitChain);\n    DynaPolyActor_Init(&this->dyna, DPM_UNK);\n    CollisionHeader_GetVirtual(&gOscPlatformCol, &colHeader);\n    this->dyna.bgId = DynaPoly_SetBgActor(play, &play->colCtx.dyna, &this->dyna.actor, colHeader);\n    \n    this->state = OSCPLATFORM_STATE_IDLE;\n    this->initY = this->dyna.actor.world.pos.y;\n    this->oscillationRange = 100;\n    this->moveSpeed = 2.0f;\n    \n    Collider_InitJntSph(play, &this->collider);\n    Collider_SetJntSph(play, &this->collider, &this->dyna.actor, &sJntSphInit, this->colliderElements);\n    \n    Actor_SetScale(&this->dyna.actor, 0.1f);\n}\n\nvoid OscPlatform_Destroy(Actor* thisx, PlayState* play) {\n    OscPlatform* this = (OscPlatform*)thisx;\n    DynaPoly_DeleteBgActor(play, &play->colCtx.dyna, this->dyna.bgId);\n    Collider_DestroyJntSph(play, &this->collider);\n}\n\nvoid OscPlatform_Update(Actor* thisx, PlayState* play) {\n    OscPlatform* this = (OscPlatform*)thisx;\n    \n    this->timer++;\n    \n    // Smooth oscillation using sine wave\n    f32 targetY = this->initY + (Math_SinS(this->timer * 0x200) * this->oscillationRange);\n    Math_ApproachF(&this->dyna.actor.world.pos.y, targetY, 0.3f, this->moveSpeed);\n    \n    // Update collision\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Debug visualization\n    if (play->debugFlags & 1) {\n        DebugDisplay_AddObject(this->dyna.actor.world.pos.x,\n                             this->dyna.actor.world.pos.y,\n                             this->dyna.actor.world.pos.z,\n                             this->dyna.actor.world.rot.x,\n                             this->dyna.actor.world.rot.y,\n                             this->dyna.actor.world.rot.z,\n                             1.0f, 1.0f, 1.0f, 255, 255, 255, 255,\n                             4, play->state.gfxCtx);\n    }\n}\n\nvoid OscPlatform_Draw(Actor* thisx, PlayState* play) {\n    OscPlatform* this = (OscPlatform*)thisx;\n    \n    Gfx_DrawDListOpa(play, gOscPlatformDL);\n    \n    if (play->debugFlags & 1) {\n        CollisionCheck_DrawJntSph(&this->dyna.actor, play, &this->collider);\n    }\n}\n\nconst ActorProfile Obj_OscPlatform_InitVars = {\n    ACTOR_OBJ_OSC_PLATFORM,\n    ACTORCAT_BG,\n    FLAGS,\n    OBJECT_GAMEPLAY_KEEP,\n    sizeof(OscPlatform),\n    (ActorFunc)OscPlatform_Init,\n    (ActorFunc)OscPlatform_Destroy,\n    (ActorFunc)OscPlatform_Update,\n    (ActorFunc)OscPlatform_Draw\n};\n```"}
