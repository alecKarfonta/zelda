{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, using authentic collision detection and EnItem00 spawning patterns", "output": "// Authentic actor pattern following z_actor.c style\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 hitCount;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnBreakable; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_WOOD,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 40, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnBreakable_Init(Actor* thisx, PlayState* play) {\\n    EnBreakable* this = (EnBreakable*)thisx;\\n    \\n    // Authentic collision initialization\\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->hitCount = 0;\\n    this->actionState = 0;\\n    \\n    // Authentic actor setup\\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actor.colChkInfo.mass = 0xFF;\\n}\\n\\nvoid EnBreakable_Update(Actor* thisx, PlayState* play) {\\n    EnBreakable* this = (EnBreakable*)thisx;\\n    \\n    // Authentic collision check pattern\\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitCount++;\\n        if (this->hitCount >= 3) {\\n            // Spawn heart piece using authentic EnItem00 pattern\\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                      this->actor.world.pos.x,\\n                      this->actor.world.pos.y,\\n                      this->actor.world.pos.z,\\n                      0, 0, 0, ITEM00_HEART_PIECE);\\n            Actor_Kill(&this->actor);\\n            return;\\n        }\\n    }\\n    \\n    // Authentic collision update sequence\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnBreakable_Profile = {\\n    /**/ ACTOR_EN_BREAKABLE,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnBreakable),\\n    /**/ EnBreakable_Init,\\n    /**/ EnBreakable_Destroy,\\n    /**/ EnBreakable_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Implement an actor that spawns a heart piece when hit by an arrow, with proper collision detection and visual effects", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 hitCount;\\n    /* 0x0150 */ f32 scale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnHeartTarget; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 40, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartTarget_Init(Actor* thisx, PlayState* play) {\\n    EnHeartTarget* this = (EnHeartTarget*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actor.world.rot.y = 0;\\n    this->actor.colChkInfo.mass = 0xFF;\\n    \\n    this->timer = 0;\\n    this->hitCount = 0;\\n    this->scale = 1.0f;\\n}\\n\\nvoid EnHeartTarget_Update(Actor* thisx, PlayState* play) {\\n    EnHeartTarget* this = (EnHeartTarget*)thisx;\\n    \\n    this->timer++;\\n    \\n    // Authentic collision check pattern\\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->collider.base.acFlags &= ~AC_HIT;\\n        \\n        // Spawn heart piece using authentic EnItem00 pattern\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    this->actor.world.pos.x,\\n                    this->actor.world.pos.y + 50.0f,\\n                    this->actor.world.pos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n                    \\n        // Authentic effect spawn\\n        EffectSsDeadDb_Spawn(play, &this->actor.world.pos,\\n                            &gZeroVec, &gZeroVec,\\n                            100, 0, 255, 255, 255, 255,\\n                            0, 0, 0, 1, 9, true);\\n                            \\n        Actor_Kill(&this->actor);\\n        return;\\n    }\\n    \\n    // Authentic collision update sequence\\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnHeartTarget_Profile = {\\n    /**/ ACTOR_EN_HEART_TARGET,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartTarget),\\n    /**/ EnHeartTarget_Init,\\n    /**/ EnHeartTarget_Destroy,\\n    /**/ EnHeartTarget_Update,\\n    /**/ EnHeartTarget_Draw,\\n};"}
{"instruction": "Create a debugging actor that spawns a heart piece when Link gets within 100 units, then displays debug text showing the distance", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ f32 detectionRange;\\n    /* 0x0150 */ s16 hasSpawned;\\n    /* 0x0152 */ s16 debugTextId;\\n    /* 0x0154 */ f32 playerDist;\\n    /* 0x0158 */ ColliderCylinder collider;\\n} EnDbgHelp; // size = 0x1A4\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_NONE,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000000, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_NONE,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnDbgHelp_Init(Actor* thisx, PlayState* play) {\\n    EnDbgHelp* this = (EnDbgHelp*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->detectionRange = 100.0f;\\n    this->hasSpawned = false;\\n    this->debugTextId = 0;\\n    Actor_SetScale(&this->actor, 0.01f);\\n}\\n\\nvoid EnDbgHelp_Update(Actor* thisx, PlayState* play) {\\n    EnDbgHelp* this = (EnDbgHelp*)thisx;\\n    Player* player = GET_PLAYER(play);\\n    Vec3f spawnPos;\\n    \\n    // Authentic position calculation using world.pos\\n    this->playerDist = Math_Vec3f_DistXYZ(&player->actor.world.pos, &this->actor.world.pos);\\n    \\n    if (!this->hasSpawned && this->playerDist < this->detectionRange) {\\n        spawnPos = this->actor.world.pos;\\n        spawnPos.y += 40.0f;\\n        \\n        // Authentic EnItem00 spawn pattern for heart piece\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n        \\n        this->hasSpawned = true;\\n    }\\n    \\n    // Update collision using authentic pattern\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    // Display debug distance text\\n    Debug_PrintNumber(play, 0, 20, (s32)this->playerDist, 6);\\n}\\n\\nconst ActorProfile EnDbgHelp_Profile = {\\n    /**/ ACTOR_EN_DBG_HELP,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_NONE,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnDbgHelp),\\n    /**/ EnDbgHelp_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnDbgHelp_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a sequence of collectibles in a circular pattern when triggered, with proper collision detection and state management", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 spawnState;\\n    /* 0x0150 */ s16 spawnCount;\\n    /* 0x0152 */ s16 maxSpawns;\\n    /* 0x0154 */ f32 radius;\\n    /* 0x0158 */ ColliderCylinder collider;\\n} EnCollectSpawner; // size = 0x1A4\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnCollectSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnCollectSpawner* this = (EnCollectSpawner*)thisx;\\n    \\n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 30.0f);\\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->timer = 0;\\n    this->spawnState = 0;\\n    this->spawnCount = 0;\\n    this->maxSpawns = 5;\\n    this->radius = 100.0f;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n}\\n\\nvoid EnCollectSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnCollectSpawner* this = (EnCollectSpawner*)thisx;\\n    Vec3f spawnPos;\\n    f32 angle;\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->spawnState == 1 && this->spawnCount < this->maxSpawns) {\\n        if (this->timer <= 0) {\\n            angle = (M_PI * 2 * this->spawnCount) / this->maxSpawns;\\n            \\n            spawnPos.x = this->actor.world.pos.x + Math_SinS(angle) * this->radius;\\n            spawnPos.y = this->actor.world.pos.y + 50.0f;\\n            spawnPos.z = this->actor.world.pos.z + Math_CosS(angle) * this->radius;\\n            \\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, 0, 0, ITEM00_RUPEE_BLUE);\\n            \\n            this->spawnCount++;\\n            this->timer = 10;\\n        } else {\\n            this->timer--;\\n        }\\n    }\\n}\\n\\nconst ActorProfile EnCollectSpawner_Profile = {\\n    /**/ ACTOR_EN_COLLECTSPAWNER,\\n    /**/ ACTORCAT_MISC,\\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnCollectSpawner),\\n    /**/ EnCollectSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnCollectSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and state management", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->actor.world.pos.y += 20.0f;\\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actionState = 0;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    this->actor.world.pos.x,\\n                    this->actor.world.pos.y,\\n                    this->actor.world.pos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n        Actor_Kill(&this->actor);\\n    }\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_NONE,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit and breaks into smaller fragments", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 breakState;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ Vec3f fragmentVelocities[4];\n    /* 0x0184 */ ColliderCylinder collider;\n} EnBreakPot; // size = 0x1D0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnBreakPot_Init(Actor* thisx, PlayState* play) {\n    EnBreakPot* this = (EnBreakPot*)thisx;\n    s32 i;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->scale = 1.0f;\n    this->breakState = 0;\n    \n    for (i = 0; i < 4; i++) {\n        this->fragmentVelocities[i].x = Rand_CenteredFloat(8.0f);\n        this->fragmentVelocities[i].y = Rand_ZeroFloat(5.0f) + 3.0f;\n        this->fragmentVelocities[i].z = Rand_CenteredFloat(8.0f);\n    }\n}\n\nvoid EnBreakPot_Update(Actor* thisx, PlayState* play) {\n    EnBreakPot* this = (EnBreakPot*)thisx;\n    Vec3f spawnPos;\n\n    if (this->breakState == 0) {\n        // Normal state - check collisions\n        Collider_UpdateCylinder(&this->actor, &this->collider);\n        CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n        CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n        \n        if (this->collider.base.acFlags & AC_HIT) {\n            // Spawn heart piece using authentic EnItem00\n            spawnPos = this->actor.world.pos;\n            spawnPos.y += 20.0f;\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       spawnPos.x, spawnPos.y, spawnPos.z,\n                       0, 0, 0, ITEM00_HEART_PIECE);\n            \n            this->breakState = 1;\n            this->timer = 30;\n        }\n    } else {\n        // Breaking state\n        this->timer--;\n        if (this->timer <= 0) {\n            Actor_Kill(&this->actor);\n        }\n    }\n\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 0.0f, BGCHECKFLAG_GROUND);\n}\n\nconst ActorProfile EnBreakPot_Profile = {\n    /**/ ACTOR_EN_BREAK_POT,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnBreakPot),\n    /**/ EnBreakPot_Init,\n    /**/ Actor_Destroy,\n    /**/ EnBreakPot_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword and then destroys itself", "output": "// Authentic actor pattern following z_actor.c style\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 hitCount;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHitSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHitSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHitSpawner* this = (EnHitSpawner*)thisx;\\n    \\n    // Authentic collision initialization\\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->actor.world.pos.y += 20.0f;\\n    Actor_SetScale(&this->actor, 0.01f);\\n    \\n    this->hitCount = 0;\\n    this->actionState = 0;\\n}\\n\\nvoid EnHitSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHitSpawner* this = (EnHitSpawner*)thisx;\\n    \\n    // Authentic collision check pattern\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        // Spawn heart piece using authentic EnItem00 pattern\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    this->actor.world.pos.x,\\n                    this->actor.world.pos.y,\\n                    this->actor.world.pos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n                    \\n        Actor_Kill(&this->actor);\\n    }\\n}\\n\\nconst ActorProfile EnHitSpawner_Profile = {\\n    /**/ ACTOR_EN_HITSPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHitSpawner),\\n    /**/ EnHitSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHitSpawner_Update,\\n    /**/ NULL,\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and state management", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actionState = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        // Spawn heart piece using authentic EnItem00 pattern\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                   this->actor.world.pos.x,\\n                   this->actor.world.pos.y,\\n                   this->actor.world.pos.z,\\n                   0, 0, 0, ITEM00_HEART_PIECE);\\n        Actor_Kill(&this->actor);\\n    }\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by an arrow, with proper collision detection and state management", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnTargetHeart; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000004, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 25, 40, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnTargetHeart_Init(Actor* thisx, PlayState* play) {\\n    EnTargetHeart* this = (EnTargetHeart*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    \\n    this->actor.targetMode = 4;\\n    this->actionState = 0;\\n    this->timer = 0;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetFocus(&this->actor, 20.0f);\\n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\\n}\\n\\nvoid EnTargetHeart_Update(Actor* thisx, PlayState* play) {\\n    EnTargetHeart* this = (EnTargetHeart*)thisx;\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->actionState == 1) {\\n        Vec3f spawnPos;\\n        spawnPos.x = this->actor.world.pos.x;\\n        spawnPos.y = this->actor.world.pos.y + 40.0f;\\n        spawnPos.z = this->actor.world.pos.z;\\n        \\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n                    \\n        Actor_Kill(&this->actor);\\n    }\\n    \\n    if (this->actor.colChkInfo.acHitInfo != NULL) {\\n        this->actionState = 1;\\n    }\\n}\\n\\nconst ActorProfile EnTargetHeart_Profile = {\\n    /**/ ACTOR_EN_TARGET_HEART,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnTargetHeart),\\n    /**/ EnTargetHeart_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnTargetHeart_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns heart pieces in a rotating circle pattern when hit, using authentic OoT patterns", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 spawnCount;\\n    /* 0x0150 */ f32 rotationAngle;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->timer = 0;\\n    this->spawnCount = 0;\\n    this->rotationAngle = 0.0f;\\n    \\n    this->actor.targetMode = 0;\\n    this->actor.gravity = 0.0f;\\n    this->actor.flags |= ACTOR_FLAG_4;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    Vec3f spawnPos;\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        if (this->spawnCount < 4) {\\n            spawnPos.x = this->actor.world.pos.x + (Math_SinS(this->rotationAngle) * 50.0f);\\n            spawnPos.y = this->actor.world.pos.y + 40.0f;\\n            spawnPos.z = this->actor.world.pos.z + (Math_CosS(this->rotationAngle) * 50.0f);\\n            \\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, this->rotationAngle, 0, ITEM00_HEART_PIECE);\\n            \\n            this->rotationAngle += 0x4000;\\n            this->spawnCount++;\\n        } else {\\n            Actor_Kill(&this->actor);\\n        }\\n    }\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 0.0f, BGCHECKFLAG_GROUND);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ EnHeartSpawner_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and authentic OoT patterns", "output": "// Authentic actor pattern following z_actor.c\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 hitCount;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    // Authentic collision initialization from z_collision_check.c\\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->hitCount = 0;\\n    this->actionState = 0;\\n    \\n    // Authentic actor setup pattern\\n    Actor_SetScale(&this->actor, 0.01f);\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    // Authentic collision check pattern\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitCount++;\\n        if (this->hitCount >= 3) {\\n            // Authentic EnItem00 spawn pattern for heart piece\\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       this->actor.world.pos.x,\\n                       this->actor.world.pos.y,\\n                       this->actor.world.pos.z,\\n                       0, 0, 0, ITEM00_HEART_PIECE);\\n            Actor_Kill(&this->actor);\\n        }\\n    }\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit and then crumbles, using authentic OoT patterns", "output": "```c\ntypedef struct {\n    /* 0x0000 */ DynaPolyActor dyna;\n    /* 0x0164 */ s16 timer;\n    /* 0x0166 */ s16 crumbleState;\n    /* 0x0168 */ f32 shakeMagnitude;\n    /* 0x016C */ ColliderCylinder collider;\n} EnBreakRock; // size = 0x1B8\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 25, 40, 0, { 0, 0, 0 } },\n};\n\nvoid EnBreakRock_Init(Actor* thisx, PlayState* play) {\n    EnBreakRock* this = (EnBreakRock*)thisx;\n    CollisionHeader* colHeader = NULL;\n\n    DynaPolyActor_Init(&this->dyna, DPM_UNK);\n    CollisionHeader_GetVirtual(&gBreakRockCol, &colHeader);\n    this->dyna.bgId = DynaPoly_SetBgActor(play, &play->colCtx.dyna, &this->dyna.actor, colHeader);\n\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->dyna.actor, &sCylinderInit);\n\n    Actor_SetScale(&this->dyna.actor, 0.01f);\n    this->crumbleState = 0;\n    this->timer = 0;\n    this->shakeMagnitude = 0.0f;\n}\n\nvoid EnBreakRock_Update(Actor* thisx, PlayState* play) {\n    EnBreakRock* this = (EnBreakRock*)thisx;\n    Vec3f spawnPos;\n\n    if (this->crumbleState == 1) {\n        this->timer++;\n        this->shakeMagnitude = sinf(this->timer * 0.5f) * 2.0f;\n        \n        if (this->timer > 20) {\n            spawnPos = this->dyna.actor.world.pos;\n            spawnPos.y += 40.0f;\n            \n            // Spawn heart piece using authentic EnItem00 pattern\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       spawnPos.x, spawnPos.y, spawnPos.z,\n                       0, 0, 0, ITEM00_HEART_PIECE);\n                       \n            Actor_Kill(&this->dyna.actor);\n            return;\n        }\n    } else {\n        if (this->collider.base.acFlags & AC_HIT) {\n            this->crumbleState = 1;\n            this->timer = 0;\n        }\n    }\n\n    Collider_UpdateCylinder(&this->dyna.actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile En_BreakRock_InitVars = {\n    /**/ ACTOR_EN_BREAK_ROCK,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_FIELD_KEEP,\n    /**/ sizeof(EnBreakRock),\n    /**/ EnBreakRock_Init,\n    /**/ EnBreakRock_Destroy,\n    /**/ EnBreakRock_Update,\n    /**/ EnBreakRock_Draw\n};\n```"}
{"instruction": "Explain how to create an actor that spawns a heart piece when hit by the player's sword, including proper collision setup and item spawning.", "output": "```c\n// Actor that spawns heart piece when hit\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState; \n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnHeartSpawner; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 25, 40, 0, { 0, 0, 0 } },\n};\n\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actionState = 0;\n    this->timer = 0;\n}\n\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    if (this->collider.base.acFlags & AC_HIT) {\n        // Spawn heart piece using authentic EnItem00 pattern\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   this->actor.world.pos.x,\n                   this->actor.world.pos.y,\n                   this->actor.world.pos.z,\n                   0, 0, 0, ITEM00_HEART_PIECE);\n                   \n        Actor_Kill(&this->actor);\n    }\n}\n\nconst ActorProfile EnHeartSpawner_InitVars = {\n    /**/ ACTOR_EN_HEART_SPAWNER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnHeartSpawner),\n    /**/ EnHeartSpawner_Init,\n    /**/ Actor_Destroy,\n    /**/ EnHeartSpawner_Update,\n    /**/ NULL\n};\n```"}
{"instruction": "Create an actor that spawns heart pieces and rupees when hit, with proper collision handling and state management following OoT patterns", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ s16 health;\n    /* 0x0152 */ s16 hitCount;\n    /* 0x0154 */ f32 scale;\n    /* 0x0158 */ ColliderCylinder collider;\n} EnTreasureSpawner; // size = 0x1A4\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 40, 0, { 0, 0, 0 } },\n};\n\nvoid EnTreasureSpawner_Init(Actor* thisx, PlayState* play) {\n    EnTreasureSpawner* this = (EnTreasureSpawner*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.focus.pos = this->actor.world.pos;\n    this->actor.focus.pos.y += 30.0f;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->timer = 0;\n    this->actionState = 0;\n    this->health = 3;\n    this->hitCount = 0;\n    this->scale = 1.0f;\n    \n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\n    this->actor.colChkInfo.health = 3;\n}\n\nvoid EnTreasureSpawner_Update(Actor* thisx, PlayState* play) {\n    EnTreasureSpawner* this = (EnTreasureSpawner*)thisx;\n    Vec3f spawnPos;\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    if (this->actor.colChkInfo.health < this->health) {\n        this->health = this->actor.colChkInfo.health;\n        this->hitCount++;\n        \n        spawnPos = this->actor.world.pos;\n        spawnPos.y += 40.0f;\n        \n        if (this->hitCount >= 3) {\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       spawnPos.x, spawnPos.y, spawnPos.z,\n                       0, 0, 0, ITEM00_HEART_PIECE);\n            Actor_Kill(&this->actor);\n        } else {\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       spawnPos.x, spawnPos.y, spawnPos.z,\n                       0, 0, 0, ITEM00_RUPEE_BLUE);\n        }\n    }\n}\n\nconst ActorProfile EnTreasureSpawner_Profile = {\n    /**/ ACTOR_EN_TREASURE_SPAWNER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnTreasureSpawner),\n    /**/ EnTreasureSpawner_Init,\n    /**/ Actor_Destroy,\n    /**/ EnTreasureSpawner_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Explain how to create an actor that spawns a heart piece when hit by the player's sword", "output": "```c\n// Authentic pattern following z_actor.c and z_en_item00.c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ ColliderCylinder collider;\n} EnBreakable; // size = 0x19C\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnBreakable_Init(Actor* thisx, PlayState* play) {\n    EnBreakable* this = (EnBreakable*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actionState = 0;\n    this->timer = 0;\n}\n\nvoid EnBreakable_Update(Actor* thisx, PlayState* play) {\n    EnBreakable* this = (EnBreakable*)thisx;\n    \n    // Authentic collision check pattern\n    if (this->collider.base.acFlags & AC_HIT) {\n        Vec3f pos;\n        pos.x = this->actor.world.pos.x;\n        pos.y = this->actor.world.pos.y;\n        pos.z = this->actor.world.pos.z;\n        \n        // Spawn heart piece using authentic EnItem00 pattern\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   pos.x, pos.y, pos.z, 0, 0, 0, ITEM00_HEART_PIECE);\n                   \n        Actor_Kill(&this->actor);\n        return;\n    }\n    \n    // Authentic collision update sequence\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile EnBreakable_InitVars = {\n    /**/ ACTOR_EN_BREAKABLE,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnBreakable),\n    /**/ EnBreakable_Init,\n    /**/ Actor_Destroy,\n    /**/ EnBreakable_Update,\n    /**/ NULL\n};\n```"}
{"instruction": "Create an actor that spawns collectible rupees in a rotating circle pattern when interacted with, using authentic OoT patterns and collision detection", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 spawnCount;\\n    /* 0x0150 */ f32 rotationAngle;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnRupeeSpawner; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnRupeeSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnRupeeSpawner* this = (EnRupeeSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->timer = 0;\\n    this->spawnCount = 0;\\n    this->rotationAngle = 0.0f;\\n    \\n    this->actor.targetMode = 0;\\n    this->actor.flags |= ACTOR_FLAG_0;\\n    this->actor.focus.pos = this->actor.world.pos;\\n}\\n\\nvoid EnRupeeSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnRupeeSpawner* this = (EnRupeeSpawner*)thisx;\\n    Vec3f spawnPos;\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n\\n    if (this->timer > 0) {\\n        this->timer--;\\n        if ((this->timer % 4) == 0 && this->spawnCount < 5) {\\n            this->rotationAngle += (M_PI * 2) / 5;\\n            \\n            spawnPos.x = this->actor.world.pos.x + (Math_SinS(this->rotationAngle) * 50.0f);\\n            spawnPos.y = this->actor.world.pos.y + 40.0f;\\n            spawnPos.z = this->actor.world.pos.z + (Math_CosS(this->rotationAngle) * 50.0f);\\n            \\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, 0, 0, ITEM00_RUPEE_BLUE);\\n            \\n            this->spawnCount++;\\n        }\\n    } else if (Actor_HasParent(&this->actor, play)) {\\n        this->timer = 30;\\n        this->spawnCount = 0;\\n    } else {\\n        Actor_OfferCarry(&this->actor, play);\\n    }\\n}\\n\\nconst ActorProfile EnRupeeSpawner_Profile = {\\n    /**/ ACTOR_EN_RUPEE_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnRupeeSpawner),\\n    /**/ EnRupeeSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnRupeeSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, using authentic collision detection and EnItem00 spawning patterns", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 hitCount;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnBreakPot; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnBreakPot_Init(Actor* thisx, PlayState* play) {\\n    EnBreakPot* this = (EnBreakPot*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->hitCount = 0;\\n    this->actionState = 0;\\n    \\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnBreakPot_Update(Actor* thisx, PlayState* play) {\\n    EnBreakPot* this = (EnBreakPot*)thisx;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitCount++;\\n        if (this->hitCount >= 1) {\\n            Vec3f spawnPos;\\n            spawnPos.x = this->actor.world.pos.x;\\n            spawnPos.y = this->actor.world.pos.y + 20.0f;\\n            spawnPos.z = this->actor.world.pos.z;\\n            \\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, 0, 0, ITEM00_HEART_PIECE);\\n                       \\n            Actor_Kill(&this->actor);\\n            return;\\n        }\\n    }\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnBreakPot_Profile = {\\n    /**/ ACTOR_EN_BREAK_POT,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnBreakPot),\\n    /**/ EnBreakPot_Init,\\n    /**/ EnBreakPot_Destroy,\\n    /**/ EnBreakPot_Update,\\n    /**/ NULL,\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and state management", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actionState = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        Vec3f spawnPos;\\n        spawnPos.x = this->actor.world.pos.x;\\n        spawnPos.y = this->actor.world.pos.y;\\n        spawnPos.z = this->actor.world.pos.z;\\n        \\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n                    \\n        Actor_Kill(&this->actor);\\n        return;\\n    }\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Implement a torch actor that can be lit/unlit, damages the player when lit, and drops a blue rupee when extinguished. Must use authentic collision and damage patterns.", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 flamingState;\\n    /* 0x0150 */ f32 flameScale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n    /* 0x01A0 */ LightNode* lightNode;\\n    /* 0x01A4 */ LightInfo lightInfo;\\n} EnTorch; // size = 0x1B4\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_WOOD,\\n        AT_ON | AT_TYPE_ENEMY,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_2,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_WOOD,\\n        { 0x00000004, HIT_SPECIAL_EFFECT_FIRE, 0x01 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_ON | ATELEM_FIRE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 45, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnTorch_Init(Actor* thisx, PlayState* play) {\\n    EnTorch* this = (EnTorch*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->flamingState = 1;\\n    this->flameScale = 1.0f;\\n    \\n    // Authentic light node setup\\n    this->lightNode = LightContext_InsertLight(play, &play->lightCtx, &this->lightInfo);\\n    Lights_PointNoGlowSetInfo(&this->lightInfo, this->actor.world.pos.x,\\n                             this->actor.world.pos.y, this->actor.world.pos.z,\\n                             255, 200, 100, 200);\\n}\\n\\nvoid EnTorch_Update(Actor* thisx, PlayState* play) {\\n    EnTorch* this = (EnTorch*)thisx;\\n    \\n    if (this->flamingState) {\\n        // Update collision when lit\\n        Collider_UpdateCylinder(&this->actor, &this->collider);\\n        CollisionCheck_SetAT(play, &play->colChkCtx, &this->collider.base);\\n        CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n        \\n        // Update light position\\n        Lights_PointNoGlowSetInfo(&this->lightInfo, this->actor.world.pos.x,\\n                                 this->actor.world.pos.y, this->actor.world.pos.z,\\n                                 255, 200, 100, 200);\\n        \\n        // Check for water collision to extinguish\\n        if (WaterBox_GetSurfaceImpl(play, &play->colCtx, this->actor.world.pos.x,\\n                                   this->actor.world.pos.z, &this->actor.world.pos.y, NULL)) {\\n            this->flamingState = 0;\\n            \\n            // Spawn blue rupee using authentic EnItem00 pattern\\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z,\\n                       0, 0, 0, ITEM00_RUPEE_BLUE);\\n        }\\n    }\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 0.0f, BGCHECKFLAG_GROUND);\\n}\\n\\nconst ActorProfile EnTorch_Profile = {\\n    /**/ ACTOR_EN_TORCH,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnTorch),\\n    /**/ EnTorch_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnTorch_Update,\\n    /**/ NULL,\\n};"}
{"instruction": "Create an actor that spawns collectible rupees in a rotating circle pattern when activated, with proper collision detection and state management", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 spawnState;\\n    /* 0x0150 */ f32 rotationAngle;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnRupeeSpawner; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnRupeeSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnRupeeSpawner* this = (EnRupeeSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->spawnState = 0;\\n    this->timer = 0;\\n    this->rotationAngle = 0.0f;\\n    \\n    this->actor.targetMode = 0;\\n    this->actor.flags |= ACTOR_FLAG_0;\\n}\\n\\nvoid EnRupeeSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnRupeeSpawner* this = (EnRupeeSpawner*)thisx;\\n    Vec3f spawnPos;\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n\\n    if (this->spawnState == 1) {\\n        if (this->timer % 10 == 0) {\\n            spawnPos.x = this->actor.world.pos.x + (Math_SinS(this->rotationAngle) * 50.0f);\\n            spawnPos.y = this->actor.world.pos.y + 40.0f;\\n            spawnPos.z = this->actor.world.pos.z + (Math_CosS(this->rotationAngle) * 50.0f);\\n            \\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, this->rotationAngle, 0, ITEM00_RUPEE_BLUE);\\n            \\n            this->rotationAngle += 0x1000;\\n        }\\n        this->timer++;\\n        \\n        if (this->timer >= 60) {\\n            this->spawnState = 0;\\n            this->timer = 0;\\n        }\\n    }\\n}\\n\\nconst ActorProfile EnRupeeSpawner_Profile = {\\n    /**/ ACTOR_EN_RUPEE_SPAWNER,\\n    /**/ ACTORCAT_MISC,\\n    /**/ FLAGS,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnRupeeSpawner),\\n    /**/ EnRupeeSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnRupeeSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and hit response", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actionState = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        Vec3f spawnPos;\\n        spawnPos.x = this->actor.world.pos.x;\\n        spawnPos.y = this->actor.world.pos.y;\\n        spawnPos.z = this->actor.world.pos.z;\\n        \\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n                    \\n        Actor_Kill(&this->actor);\\n        return;\\n    }\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ EnHeartSpawner_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL,\\n};"}
{"instruction": "Implement a crystal switch actor that spawns a blue rupee when hit, with proper collision detection and state management following OoT patterns", "output": "// Crystal switch with rupee spawn on hit\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 switchState;\\n    /* 0x0150 */ f32 crystalScale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnCrystalSwitch; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnCrystalSwitch_Init(Actor* thisx, PlayState* play) {\\n    EnCrystalSwitch* this = (EnCrystalSwitch*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.02f);\\n    this->crystalScale = 1.0f;\\n    this->switchState = 0;\\n    this->timer = 0;\\n    \\n    this->actor.world.rot.y = 0;\\n    this->actor.flags |= ACTOR_FLAG_4;\\n}\\n\\nvoid EnCrystalSwitch_Update(Actor* thisx, PlayState* play) {\\n    EnCrystalSwitch* this = (EnCrystalSwitch*)thisx;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->collider.base.acFlags &= ~AC_HIT;\\n        \\n        if (this->switchState == 0) {\\n            this->switchState = 1;\\n            this->timer = 30;\\n            \\n            // Spawn rupee using authentic EnItem00 pattern\\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       this->actor.world.pos.x,\\n                       this->actor.world.pos.y + 50.0f,\\n                       this->actor.world.pos.z,\\n                       0, 0, 0, ITEM00_RUPEE_BLUE);\\n        }\\n    }\\n    \\n    if (this->timer > 0) {\\n        this->timer--;\\n        if (this->timer == 0) {\\n            this->switchState = 0;\\n        }\\n    }\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnCrystalSwitch_Profile = {\\n    /**/ ACTOR_EN_CRYSTAL_SWITCH,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnCrystalSwitch),\\n    /**/ EnCrystalSwitch_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnCrystalSwitch_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create a debug actor that spawns a heart piece when hit and displays collision cylinder visually", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 hitCount;\\n    /* 0x0150 */ f32 debugScale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnDbgHelp; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnDbgHelp_Init(Actor* thisx, PlayState* play) {\\n    EnDbgHelp* this = (EnDbgHelp*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->debugScale = 1.0f;\\n    this->hitCount = 0;\\n    \\n    this->actor.targetMode = 3;\\n    this->actor.colChkInfo.mass = 0xFF;\\n}\\n\\nvoid EnDbgHelp_Update(Actor* thisx, PlayState* play) {\\n    EnDbgHelp* this = (EnDbgHelp*)thisx;\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitCount++;\\n        \\n        Vec3f spawnPos;\\n        spawnPos.x = this->actor.world.pos.x;\\n        spawnPos.y = this->actor.world.pos.y + 40.0f;\\n        spawnPos.z = this->actor.world.pos.z;\\n        \\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n    }\\n}\\n\\nconst ActorProfile EnDbgHelp_Profile = {\\n    /**/ ACTOR_EN_DBG_HELP,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnDbgHelp),\\n    /**/ EnDbgHelp_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnDbgHelp_Update,\\n    /**/ Actor_Draw\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and state management", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 scale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\\n    this->actionState = 0;\\n    this->timer = 0;\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        Vec3f spawnPos;\\n        spawnPos.x = this->actor.world.pos.x;\\n        spawnPos.y = this->actor.world.pos.y + 20.0f;\\n        spawnPos.z = this->actor.world.pos.z;\\n        \\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n        \\n        Actor_Kill(&this->actor);\\n        return;\\n    }\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_NONE,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ EnHeartSpawner_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ EnHeartSpawner_Draw,\\n};"}
{"instruction": "Implement an actor that spawns a heart piece when hit by the player's sword, including proper collision setup and state management.", "output": "// Authentic actor pattern following z_actor.c and z_en_item00.c\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->actor.world.rot.y = 0;\\n    Actor_SetScale(&this->actor, 0.01f);\\n    \\n    this->actionState = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        // Spawn heart piece using authentic EnItem00 pattern\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                   this->actor.world.pos.x,\\n                   this->actor.world.pos.y,\\n                   this->actor.world.pos.z,\\n                   0, 0, 0, ITEM00_HEART_PIECE);\\n                   \\n        Actor_Kill(&this->actor);\\n        return;\\n    }\\n    \\n    // Authentic collision update sequence\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns collectible rupees in a rotating circle pattern when hit, with proper collision detection and state management", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 rotationAngle;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnRupeeSpawner; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnRupeeSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnRupeeSpawner* this = (EnRupeeSpawner*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actionState = 0;\\n    this->timer = 0;\\n    this->rotationAngle = 0.0f;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnRupeeSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnRupeeSpawner* this = (EnRupeeSpawner*)thisx;\\n    Vec3f spawnPos;\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->actionState == 1) {\\n        this->timer++;\\n        this->rotationAngle += M_PI / 8;\\n        \\n        if (this->timer % 4 == 0 && this->timer < 32) {\\n            spawnPos.x = this->actor.world.pos.x + (Math_SinS(this->rotationAngle) * 50.0f);\\n            spawnPos.y = this->actor.world.pos.y + 40.0f;\\n            spawnPos.z = this->actor.world.pos.z + (Math_CosS(this->rotationAngle) * 50.0f);\\n            \\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, this->rotationAngle, 0, ITEM00_RUPEE_BLUE);\\n        }\\n        \\n        if (this->timer >= 60) {\\n            this->actionState = 0;\\n            this->timer = 0;\\n        }\\n    }\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->actionState = 1;\\n        this->timer = 0;\\n        this->collider.base.acFlags &= ~AC_HIT;\\n    }\\n}\\n\\nconst ActorProfile EnRupeeSpawner_Profile = {\\n    /**/ ACTOR_EN_RUPEE_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnRupeeSpawner),\\n    /**/ EnRupeeSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnRupeeSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and hit effects", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 hitCount;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnBreakable; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_WOOD,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnBreakable_Init(Actor* thisx, PlayState* play) {\\n    EnBreakable* this = (EnBreakable*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->hitCount = 0;\\n    this->timer = 0;\\n    \\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnBreakable_Update(Actor* thisx, PlayState* play) {\\n    EnBreakable* this = (EnBreakable*)thisx;\\n    \\n    if (this->timer > 0) {\\n        this->timer--;\\n    }\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitCount++;\\n        this->timer = 10;\\n        \\n        if (this->hitCount >= 3) {\\n            Vec3f spawnPos;\\n            spawnPos.x = this->actor.world.pos.x;\\n            spawnPos.y = this->actor.world.pos.y;\\n            spawnPos.z = this->actor.world.pos.z;\\n            \\n            // Authentic EnItem00 spawn pattern for heart piece\\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, 0, 0, ITEM00_HEART_PIECE);\\n                       \\n            Actor_Kill(&this->actor);\\n            return;\\n        }\\n        \\n        // Authentic effect spawn\\n        EffectSsHitMark_SpawnFixedScale(play, EFFECT_HITMARK_WHITE, &this->actor.world.pos);\\n    }\\n    \\n    // Authentic collision update pattern\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnBreakable_Profile = {\\n    /**/ ACTOR_EN_BREAKABLE,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnBreakable),\\n    /**/ EnBreakable_Init,\\n    /**/ EnBreakable_Destroy,\\n    /**/ EnBreakable_Update,\\n    /**/ NULL,\\n};"}
{"instruction": "Create a debug actor that spawns a heart piece when hit and displays its current state", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 debugState;\\n    /* 0x014E */ s16 timer;\\n    /* 0x0150 */ f32 hitboxScale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnDebugHelp; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnDebugHelp_Init(Actor* thisx, PlayState* play) {\\n    EnDebugHelp* this = (EnDebugHelp*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->debugState = 0;\\n    this->timer = 0;\\n    this->hitboxScale = 1.0f;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnDebugHelp_Update(Actor* thisx, PlayState* play) {\\n    EnDebugHelp* this = (EnDebugHelp*)thisx;\\n    \\n    this->timer++;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        Vec3f spawnPos;\\n        spawnPos.x = this->actor.world.pos.x;\\n        spawnPos.y = this->actor.world.pos.y + 20.0f;\\n        spawnPos.z = this->actor.world.pos.z;\\n        \\n        // Authentic EnItem00 spawn pattern\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                   spawnPos.x, spawnPos.y, spawnPos.z,\\n                   0, 0, 0, ITEM00_HEART_PIECE);\\n                   \\n        this->debugState++;\\n    }\\n    \\n    // Authentic collision update pattern\\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnDebugHelp_Profile = {\\n    /**/ ACTOR_EN_DEBUG_HELP,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnDebugHelp),\\n    /**/ EnDebugHelp_Init,\\n    /**/ EnDebugHelp_Destroy,\\n    /**/ EnDebugHelp_Update,\\n    /**/ EnDebugHelp_Draw,\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit and has cylinder collision", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 health;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 40, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\\n    this->actor.flags |= ACTOR_FLAG_4;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->health = 3.0f;\\n    this->actionState = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    if (this->actionState == 1) {\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                   this->actor.world.pos.x,\\n                   this->actor.world.pos.y + 40.0f,\\n                   this->actor.world.pos.z,\\n                   0, 0, 0, ITEM00_HEART_PIECE);\\n        Actor_Kill(&this->actor);\\n        return;\\n    }\\n\\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->health -= 1.0f;\\n        if (this->health <= 0.0f) {\\n            this->actionState = 1;\\n        }\\n    }\\n\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ EnHeartSpawner_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ EnHeartSpawner_Draw,\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and state management", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actionState = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        // Spawn heart piece using authentic EnItem00 pattern\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                   this->actor.world.pos.x,\\n                   this->actor.world.pos.y,\\n                   this->actor.world.pos.z,\\n                   0, 0, 0, ITEM00_HEART_PIECE);\\n        Actor_Kill(&this->actor);\\n    }\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns rupees in a spiral pattern when hit, with proper collision handling and state management following OoT patterns", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 spinAngle;\n    /* 0x0154 */ s16 hitCount;\n    /* 0x0156 */ s16 spawnDelay;\n    /* 0x0158 */ ColliderCylinder collider;\n} EnRupeeSpawner; // size = 0x1A4\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 40, 0, { 0, 0, 0 } },\n};\n\nvoid EnRupeeSpawner_Init(Actor* thisx, PlayState* play) {\n    EnRupeeSpawner* this = (EnRupeeSpawner*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.world.pos.y += 40.0f;\n    Actor_SetScale(&this->actor, 0.02f);\n    Actor_SetFocus(&this->actor, 20.0f);\n    \n    this->timer = 0;\n    this->actionState = 0;\n    this->spinAngle = 0.0f;\n    this->hitCount = 3;\n    this->spawnDelay = 0;\n}\n\nvoid EnRupeeSpawner_SpawnRupees(EnRupeeSpawner* this, PlayState* play) {\n    Vec3f spawnPos;\n    f32 radius = 40.0f;\n    s32 i;\n    \n    for (i = 0; i < 5; i++) {\n        spawnPos.x = this->actor.world.pos.x + (Math_SinS(this->spinAngle + (i * 0x3333)) * radius);\n        spawnPos.y = this->actor.world.pos.y;\n        spawnPos.z = this->actor.world.pos.z + (Math_CosS(this->spinAngle + (i * 0x3333)) * radius);\n        \n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   spawnPos.x, spawnPos.y, spawnPos.z,\n                   0, 0, 0, ITEM00_RUPEE_BLUE);\n    }\n}\n\nvoid EnRupeeSpawner_Update(Actor* thisx, PlayState* play) {\n    EnRupeeSpawner* this = (EnRupeeSpawner*)thisx;\n    \n    if (this->spawnDelay > 0) {\n        this->spawnDelay--;\n    }\n    \n    if (this->hitCount > 0 && this->spawnDelay == 0) {\n        if (this->collider.base.acFlags & AC_HIT) {\n            this->collider.base.acFlags &= ~AC_HIT;\n            this->hitCount--;\n            this->spawnDelay = 20;\n            EnRupeeSpawner_SpawnRupees(this, play);\n            this->spinAngle += 0x2000;\n        }\n    }\n    \n    if (this->hitCount <= 0) {\n        Actor_Kill(&this->actor);\n        return;\n    }\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile EnRupeeSpawner_Profile = {\n    /**/ ACTOR_EN_RUPEE_SPAWNER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnRupeeSpawner),\n    /**/ EnRupeeSpawner_Init,\n    /**/ Actor_Destroy,\n    /**/ EnRupeeSpawner_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and state management", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actionState = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    this->actor.world.pos.x,\\n                    this->actor.world.pos.y,\\n                    this->actor.world.pos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n        Actor_Kill(&this->actor);\\n    }\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_NONE,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and visual effects", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 scale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\\n    this->actionState = 0;\\n    this->timer = 0;\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 25.0f, 20.0f, 0.0f, BGCHECKFLAG_GROUND);\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        Vec3f spawnPos;\\n        spawnPos.x = this->actor.world.pos.x;\\n        spawnPos.y = this->actor.world.pos.y + 40.0f;\\n        spawnPos.z = this->actor.world.pos.z;\\n        \\n        // Spawn heart piece using authentic EnItem00 pattern\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n        \\n        Actor_Kill(&this->actor);\\n        return;\\n    }\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword and then despawns", "output": "// Breakable pot that spawns heart piece when hit\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 actionState;\\n    /* 0x014E */ s16 breakTimer;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnBreakPot; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnBreakPot_Init(Actor* thisx, PlayState* play) {\\n    EnBreakPot* this = (EnBreakPot*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->actionState = 0;\\n    this->breakTimer = 0;\\n}\\n\\nvoid EnBreakPot_Update(Actor* thisx, PlayState* play) {\\n    EnBreakPot* this = (EnBreakPot*)thisx;\\n    \\n    if (this->actionState == 1) {\\n        if (this->breakTimer > 0) {\\n            this->breakTimer--;\\n            if (this->breakTimer == 0) {\\n                Actor_Kill(&this->actor);\\n                return;\\n            }\\n        }\\n    } else {\\n        if (this->collider.base.acFlags & AC_HIT) {\\n            Vec3f spawnPos;\\n            spawnPos.x = this->actor.world.pos.x;\\n            spawnPos.y = this->actor.world.pos.y;\\n            spawnPos.z = this->actor.world.pos.z;\\n            \\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, 0, 0, ITEM00_HEART_PIECE);\\n            \\n            this->actionState = 1;\\n            this->breakTimer = 5;\\n        }\\n    }\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnBreakPot_Profile = {\\n    /**/ ACTOR_EN_BREAKPOT,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnBreakPot),\\n    /**/ EnBreakPot_Init,\\n    /**/ EnBreakPot_Destroy,\\n    /**/ EnBreakPot_Update,\\n    /**/ EnBreakPot_Draw,\\n};"}
{"instruction": "Implement a moving platform actor that spawns a heart piece when hit by an arrow, using authentic OoT patterns", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 moveState;\\n    /* 0x0150 */ f32 initialY;\\n    /* 0x0154 */ f32 moveRange;\\n    /* 0x0158 */ f32 moveSpeed;\\n    /* 0x015C */ ColliderCylinder collider;\\n} EnMovingPlatform; // size = 0x1A8\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_WOOD,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 50, 20, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnMovingPlatform_Init(Actor* thisx, PlayState* play) {\\n    EnMovingPlatform* this = (EnMovingPlatform*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.1f);\\n    \\n    this->initialY = this->actor.world.pos.y;\\n    this->moveRange = 100.0f;\\n    this->moveSpeed = 2.0f;\\n    this->moveState = 0;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\\n}\\n\\nvoid EnMovingPlatform_Update(Actor* thisx, PlayState* play) {\\n    EnMovingPlatform* this = (EnMovingPlatform*)thisx;\\n    Vec3f spawnPos;\\n    \\n    // Authentic collision update pattern\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    // Check for arrow hits using authentic pattern\\n    if (this->collider.base.acFlags & AC_HIT) {\\n        if (this->collider.base.ac->category == ACTORCAT_ARROW) {\\n            // Spawn heart piece using authentic EnItem00 pattern\\n            spawnPos = this->actor.world.pos;\\n            spawnPos.y += 50.0f;\\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, 0, 0, ITEM00_HEART_PIECE);\\n            Actor_Kill(&this->actor);\\n            return;\\n        }\\n    }\\n    \\n    // Authentic movement pattern\\n    if (this->moveState == 0) {\\n        this->actor.world.pos.y = this->initialY + (Math_SinS(this->timer * 0x800) * this->moveRange);\\n        this->timer++;\\n    }\\n    \\n    // Authentic ground collision check\\n    Actor_UpdateBgCheckInfo(play, &this->actor, 0.0f, 0.0f, 0.0f, BGCHECKFLAG_GROUND);\\n}\\n\\nconst ActorProfile EnMovingPlatform_Profile = {\\n    /**/ ACTOR_EN_MOVING_PLATFORM,\\n    /**/ ACTORCAT_BG,\\n    /**/ FLAGS_NONE,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnMovingPlatform),\\n    /**/ EnMovingPlatform_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnMovingPlatform_Update,\\n    /**/ NULL,\\n};"}
{"instruction": "Create an actor that spawns a sequence of collectible items in a circular pattern when triggered, with proper collision detection and state management", "output": "// Spawner actor that creates collectibles in a pattern\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 spawnState;\\n    /* 0x0150 */ s16 itemCount;\\n    /* 0x0152 */ s16 radius;\\n    /* 0x0154 */ f32 rotationAngle;\\n    /* 0x0158 */ ColliderCylinder collider;\\n} EnSpawner; // size = 0x1A4\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnSpawner* this = (EnSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->timer = 0;\\n    this->spawnState = 0;\\n    this->itemCount = 5;\\n    this->radius = 100;\\n    this->rotationAngle = 0.0f;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n}\\n\\nvoid EnSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnSpawner* this = (EnSpawner*)thisx;\\n    Vec3f spawnPos;\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->spawnState == 1) {\\n        if (this->timer % 10 == 0 && this->itemCount > 0) {\\n            spawnPos.x = this->actor.world.pos.x + Math_SinS(this->rotationAngle) * this->radius;\\n            spawnPos.y = this->actor.world.pos.y + 50.0f;\\n            spawnPos.z = this->actor.world.pos.z + Math_CosS(this->rotationAngle) * this->radius;\\n            \\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, 0, 0, ITEM00_RUPEE_BLUE);\\n            \\n            this->rotationAngle += 0x2000;\\n            this->itemCount--;\\n        }\\n    }\\n    \\n    this->timer++;\\n}\\n\\nconst ActorProfile EnSpawner_Profile = {\\n    /**/ ACTOR_EN_SPAWNER,\\n    /**/ ACTORCAT_MISC,\\n    /**/ FLAGS_NONE,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnSpawner),\\n    /**/ EnSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnSpawner_Update,\\n    /**/ NULL,\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and state management", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actionState = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        Vec3f spawnPos;\\n        spawnPos.x = this->actor.world.pos.x;\\n        spawnPos.y = this->actor.world.pos.y;\\n        spawnPos.z = this->actor.world.pos.z;\\n        \\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n                    \\n        Actor_Kill(&this->actor);\\n    }\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ EnHeartSpawner_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL,\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit and has cylinder collision", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 scale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actor.targetMode = 3;\\n    this->actor.flags |= ACTOR_FLAG_0;\\n    \\n    this->actionState = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                   this->actor.world.pos.x,\\n                   this->actor.world.pos.y + 20.0f,\\n                   this->actor.world.pos.z,\\n                   0, 0, 0, ITEM00_HEART_PIECE);\\n        Actor_Kill(&this->actor);\\n    }\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ EnHeartSpawner_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ EnHeartSpawner_Draw,\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and state management", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actionState = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        // Spawn heart piece using authentic EnItem00 pattern\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                   this->actor.world.pos.x,\\n                   this->actor.world.pos.y,\\n                   this->actor.world.pos.z,\\n                   0, 0, 0, ITEM00_HEART_PIECE);\\n        Actor_Kill(&this->actor);\\n    }\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and state management.", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->actor.world.pos.y += 20.0f;\\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actionState = 0;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        // Spawn heart piece using authentic EnItem00 pattern\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                   this->actor.world.pos.x,\\n                   this->actor.world.pos.y,\\n                   this->actor.world.pos.z,\\n                   0, 0, 0, ITEM00_HEART_PIECE);\\n        Actor_Kill(&this->actor);\\n        return;\\n    }\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns collectible rupees in a rotating pattern when hit, with proper collision and state management following OoT patterns", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 rotationAngle;\\n    /* 0x0154 */ s16 hitCount;\\n    /* 0x0156 */ s16 spawnDelay;\\n    /* 0x0158 */ ColliderCylinder collider;\\n} EnRupeeSpawner; // size = 0x1A4\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 40, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnRupeeSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnRupeeSpawner* this = (EnRupeeSpawner*)thisx;\\n    \\n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 30.0f);\\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->actor.flags |= ACTOR_FLAG_4;\\n    Actor_SetScale(&this->actor, 0.01f);\\n    \\n    this->timer = 0;\\n    this->actionState = 0;\\n    this->hitCount = 0;\\n    this->spawnDelay = 0;\\n    this->rotationAngle = 0.0f;\\n}\\n\\nvoid EnRupeeSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnRupeeSpawner* this = (EnRupeeSpawner*)thisx;\\n    Vec3f spawnPos;\\n    \\n    this->timer++;\\n    \\n    if (this->spawnDelay > 0) {\\n        this->spawnDelay--;\\n        if (this->spawnDelay == 0 && this->hitCount > 0) {\\n            spawnPos.x = this->actor.world.pos.x + Math_SinF(this->rotationAngle) * 50.0f;\\n            spawnPos.y = this->actor.world.pos.y + 40.0f;\\n            spawnPos.z = this->actor.world.pos.z + Math_CosF(this->rotationAngle) * 50.0f;\\n            \\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, this->timer * 0x1000, 0, ITEM00_RUPEE_BLUE);\\n                       \\n            this->rotationAngle += M_PI / 4;\\n            this->spawnDelay = 5;\\n            this->hitCount--;\\n        }\\n    }\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnRupeeSpawner_Profile = {\\n    /**/ ACTOR_EN_RUPEESPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnRupeeSpawner),\\n    /**/ EnRupeeSpawner_Init,\\n    /**/ EnRupeeSpawner_Destroy,\\n    /**/ EnRupeeSpawner_Update,\\n    /**/ EnRupeeSpawner_Draw,\\n};"}
{"instruction": "Implement an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and spawn logic.", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 hitCount;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->hitCount = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitCount++;\\n        if (this->hitCount >= 3) {\\n            // Authentic EnItem00 spawn pattern for heart piece\\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       this->actor.world.pos.x,\\n                       this->actor.world.pos.y,\\n                       this->actor.world.pos.z,\\n                       0, 0, 0, ITEM00_HEART_PIECE);\\n            Actor_Kill(&this->actor);\\n            return;\\n        }\\n    }\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit and has cylinder collision", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actionState = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                   this->actor.world.pos.x,\\n                   this->actor.world.pos.y,\\n                   this->actor.world.pos.z,\\n                   0, 0, 0, ITEM00_HEART_PIECE);\\n        Actor_Kill(&this->actor);\\n    }\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision handling and state management.", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->actor.world.pos.y += 20.0f;\\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actionState = 0;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        // Spawn heart piece using authentic EnItem00 pattern\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    this->actor.world.pos.x,\\n                    this->actor.world.pos.y,\\n                    this->actor.world.pos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n        Actor_Kill(&this->actor);\\n        return;\\n    }\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Implement a treasure chest actor that spawns a heart piece when opened, with proper collision detection and state management following OoT patterns", "output": "// Authentic pattern following z_actor.c and z_en_box.c\\n\\ntypedef enum {\\n    /* 0x00 */ CHEST_STATE_CLOSED,\\n    /* 0x01 */ CHEST_STATE_OPENING,\\n    /* 0x02 */ CHEST_STATE_OPEN,\\n} ChestState;\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 openAngle;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnTreasure; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnTreasure_Init(Actor* thisx, PlayState* play) {\\n    EnTreasure* this = (EnTreasure*)thisx;\\n    \\n    // Authentic collision initialization\\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actionState = CHEST_STATE_CLOSED;\\n    this->openAngle = 0.0f;\\n    \\n    // Authentic actor setup\\n    this->actor.world.rot.y = this->actor.shape.rot.y;\\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnTreasure_Update(Actor* thisx, PlayState* play) {\\n    EnTreasure* this = (EnTreasure*)thisx;\\n    \\n    // Authentic collision update pattern\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    switch(this->actionState) {\\n        case CHEST_STATE_CLOSED:\\n            if (Actor_ProcessTalkRequest(&this->actor, play)) {\\n                this->actionState = CHEST_STATE_OPENING;\\n                this->timer = 20;\\n            }\\n            break;\\n            \\n        case CHEST_STATE_OPENING:\\n            this->openAngle += (M_PI / 20.0f);\\n            if (--this->timer <= 0) {\\n                this->actionState = CHEST_STATE_OPEN;\\n                \\n                // Authentic collectible spawn using EnItem00\\n                Vec3f spawnPos = this->actor.world.pos;\\n                spawnPos.y += 40.0f;\\n                Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                          spawnPos.x, spawnPos.y, spawnPos.z,\\n                          0, 0, 0, ITEM00_HEART_PIECE);\\n            }\\n            break;\\n            \\n        case CHEST_STATE_OPEN:\\n            break;\\n    }\\n}\\n\\nconst ActorProfile EnTreasure_Profile = {\\n    /**/ ACTOR_EN_TREASURE,\\n    /**/ ACTORCAT_CHEST,\\n    /**/ FLAGS,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnTreasure),\\n    /**/ EnTreasure_Init,\\n    /**/ EnTreasure_Destroy,\\n    /**/ EnTreasure_Update,\\n    /**/ EnTreasure_Draw,\\n};"}
{"instruction": "Create a debugging actor that spawns a heart piece when hit and displays a collision cylinder for visualization", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 hitCount;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnDebugHelp; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 40, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnDebugHelp_Init(Actor* thisx, PlayState* play) {\\n    EnDebugHelp* this = (EnDebugHelp*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->timer = 0;\\n    this->hitCount = 0;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actor.targetMode = 0;\\n}\\n\\nvoid EnDebugHelp_Update(Actor* thisx, PlayState* play) {\\n    EnDebugHelp* this = (EnDebugHelp*)thisx;\\n    \\n    this->timer++;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitCount++;\\n        this->collider.base.acFlags &= ~AC_HIT;\\n        \\n        // Spawn heart piece using authentic EnItem00 pattern\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    this->actor.world.pos.x,\\n                    this->actor.world.pos.y + 40.0f,\\n                    this->actor.world.pos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n    }\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnDebugHelp_Profile = {\\n    /**/ ACTOR_EN_DEBUG_HELP,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnDebugHelp),\\n    /**/ EnDebugHelp_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnDebugHelp_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and destruction sequence", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 hitCount;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnBreakable; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_WOOD,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 40, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnBreakable_Init(Actor* thisx, PlayState* play) {\\n    EnBreakable* this = (EnBreakable*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->hitCount = 0;\\n    this->actionState = 0;\\n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\\n}\\n\\nvoid EnBreakable_Update(Actor* thisx, PlayState* play) {\\n    EnBreakable* this = (EnBreakable*)thisx;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitCount++;\\n        if (this->hitCount >= 3) {\\n            Vec3f spawnPos;\\n            spawnPos.x = this->actor.world.pos.x;\\n            spawnPos.y = this->actor.world.pos.y + 20.0f;\\n            spawnPos.z = this->actor.world.pos.z;\\n            \\n            // Authentic EnItem00 spawn pattern\\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, 0, 0, ITEM00_HEART_PIECE);\\n            \\n            Actor_Kill(&this->actor);\\n            return;\\n        }\\n    }\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnBreakable_Profile = {\\n    /**/ ACTOR_EN_BREAKABLE,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnBreakable),\\n    /**/ EnBreakable_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnBreakable_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Implement a chest actor that spawns a blue rupee when opened, following authentic OoT patterns", "output": "// Authentic actor pattern following z_actor.c and z_en_box.c\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 openState;\\n    /* 0x0150 */ f32 lidAngle;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnChestCustom; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_WOOD,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_WOOD,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnChestCustom_Init(Actor* thisx, PlayState* play) {\\n    EnChestCustom* this = (EnChestCustom*)thisx;\\n    \\n    // Authentic collision initialization\\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->openState = 0;\\n    this->lidAngle = 0.0f;\\n    \\n    // Authentic position setup\\n    this->actor.world.pos.y += 20.0f; // Adjust height off ground\\n    this->actor.focus.pos = this->actor.world.pos;\\n}\\n\\nvoid EnChestCustom_Update(Actor* thisx, PlayState* play) {\\n    EnChestCustom* this = (EnChestCustom*)thisx;\\n    \\n    // Authentic collision checks\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->openState == 0 && Actor_HasParent(&this->actor, play)) {\\n        // Spawn rupee using authentic EnItem00 pattern\\n        Vec3f spawnPos = this->actor.world.pos;\\n        spawnPos.y += 40.0f;\\n        \\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_RUPEE_BLUE);\\n                    \\n        this->openState = 1;\\n    }\\n}\\n\\nconst ActorProfile EnChestCustom_Profile = {\\n    /**/ ACTOR_EN_CHEST_CUSTOM,\\n    /**/ ACTORCAT_CHEST,\\n    /**/ FLAGS,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnChestCustom),\\n    /**/ EnChestCustom_Init,\\n    /**/ EnChestCustom_Destroy,\\n    /**/ EnChestCustom_Update,\\n    /**/ EnChestCustom_Draw,\\n};"}
{"instruction": "Implement an actor that spawns a heart piece when hit by an arrow, with proper collision detection and state management", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 scale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnHeartTarget; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 40, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartTarget_Init(Actor* thisx, PlayState* play) {\\n    EnHeartTarget* this = (EnHeartTarget*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.02f);\\n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\\n    Actor_SetFocus(&this->actor, 20.0f);\\n    \\n    this->actionState = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnHeartTarget_Update(Actor* thisx, PlayState* play) {\\n    EnHeartTarget* this = (EnHeartTarget*)thisx;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        if (this->actionState == 0) {\\n            Vec3f spawnPos;\\n            spawnPos.x = this->actor.world.pos.x;\\n            spawnPos.y = this->actor.world.pos.y + 40.0f;\\n            spawnPos.z = this->actor.world.pos.z;\\n            \\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                spawnPos.x, spawnPos.y, spawnPos.z,\\n                0, 0, 0, ITEM00_HEART_PIECE);\\n                \\n            this->actionState = 1;\\n            this->timer = 30;\\n        }\\n    }\\n    \\n    if (this->actionState == 1) {\\n        if (this->timer <= 0) {\\n            Actor_Kill(&this->actor);\\n            return;\\n        }\\n        this->timer--;\\n    }\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnHeartTarget_Profile = {\\n    /**/ ACTOR_EN_HEART_TARGET,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_NONE,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartTarget),\\n    /**/ EnHeartTarget_Init,\\n    /**/ EnHeartTarget_Destroy,\\n    /**/ EnHeartTarget_Update,\\n    /**/ EnHeartTarget_Draw,\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit and has cylinder collision detection", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 health;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnHeartSpawner; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->health = 3.0f;\n    this->actionState = 0;\n    this->timer = 0;\n    \n    this->actor.colChkInfo.mass = 0;\n    this->actor.targetMode = 0;\n}\n\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 15.0f, 0.0f, BGCHECKFLAG_GROUND);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        this->health -= 1.0f;\n        if (this->health <= 0.0f) {\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z,\n                       0, 0, 0, ITEM00_HEART_PIECE);\n            Actor_Kill(&this->actor);\n        }\n    }\n}\n\nconst ActorProfile EnHeartSpawner_Profile = {\n    /**/ ACTOR_EN_HEART_SPAWNER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnHeartSpawner),\n    /**/ EnHeartSpawner_Init,\n    /**/ EnHeartSpawner_Destroy,\n    /**/ EnHeartSpawner_Update,\n    /**/ EnHeartSpawner_Draw,\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and state management", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->actor.world.pos.y += 20.0f;\\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actionState = 0;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    this->actor.world.pos.x,\\n                    this->actor.world.pos.y,\\n                    this->actor.world.pos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n        Actor_Kill(&this->actor);\\n    }\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Implement a moving platform actor that spawns a heart piece when hit by an arrow, using authentic OoT patterns", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 moveState;\\n    /* 0x0150 */ f32 initialY;\\n    /* 0x0154 */ f32 moveRange;\\n    /* 0x0158 */ f32 moveSpeed;\\n    /* 0x015C */ ColliderCylinder collider;\\n} EnMovingPlatform; // size = 0x1A8\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_WOOD,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 50, 20, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnMovingPlatform_Init(Actor* thisx, PlayState* play) {\\n    EnMovingPlatform* this = (EnMovingPlatform*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.1f);\\n    \\n    this->initialY = this->actor.world.pos.y;\\n    this->moveRange = 100.0f;\\n    this->moveSpeed = 2.0f;\\n    this->moveState = 0;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\\n}\\n\\nvoid EnMovingPlatform_Update(Actor* thisx, PlayState* play) {\\n    EnMovingPlatform* this = (EnMovingPlatform*)thisx;\\n    Vec3f spawnPos;\\n    \\n    // Authentic collision update pattern\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    // Check for arrow hits using authentic pattern\\n    if (this->collider.base.acFlags & AC_HIT) {\\n        if (this->collider.base.ac->category == ACTORCAT_ARROW) {\\n            // Spawn heart piece using authentic EnItem00 pattern\\n            spawnPos = this->actor.world.pos;\\n            spawnPos.y += 50.0f;\\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, 0, 0, ITEM00_HEART_PIECE);\\n            Actor_Kill(&this->actor);\\n            return;\\n        }\\n    }\\n    \\n    // Authentic movement pattern\\n    if (this->moveState == 0) {\\n        this->actor.world.pos.y = this->initialY + (Math_SinS(this->timer * 0x800) * this->moveRange);\\n        this->timer++;\\n    }\\n    \\n    // Authentic ground collision check\\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 0.0f, BGCHECKFLAG_GROUND);\\n}\\n\\nconst ActorProfile EnMovingPlatform_Profile = {\\n    /**/ ACTOR_EN_MOVING_PLATFORM,\\n    /**/ ACTORCAT_BG,\\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnMovingPlatform),\\n    /**/ EnMovingPlatform_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnMovingPlatform_Update,\\n    /**/ NULL,\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit, using authentic OoT patterns and collision detection", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 scale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actor.targetMode = 3;\\n    this->timer = 0;\\n    this->actionState = 0;\\n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        Vec3f spawnPos;\\n        spawnPos.x = this->actor.world.pos.x;\\n        spawnPos.y = this->actor.world.pos.y + 40.0f;\\n        spawnPos.z = this->actor.world.pos.z;\\n        \\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n                    \\n        Actor_Kill(&this->actor);\\n        return;\\n    }\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_NONE,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ EnHeartSpawner_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ EnHeartSpawner_Draw,\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and state management", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actionState = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n\\n    if (this->collider.base.acFlags & AC_HIT) {\\n        Vec3f spawnPos;\\n        spawnPos.x = this->actor.world.pos.x;\\n        spawnPos.y = this->actor.world.pos.y;\\n        spawnPos.z = this->actor.world.pos.z;\\n        \\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n                    \\n        Actor_Kill(&this->actor);\\n    }\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_NONE,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and state management", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actionState = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        Vec3f spawnPos;\\n        spawnPos.x = this->actor.world.pos.x;\\n        spawnPos.y = this->actor.world.pos.y;\\n        spawnPos.z = this->actor.world.pos.z;\\n        \\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n                    \\n        Actor_Kill(&this->actor);\\n        return;\\n    }\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_NONE,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ EnHeartSpawner_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Implement a chest-like actor that spawns a heart piece when opened, with proper collision detection and state management following OoT patterns", "output": "// Authentic actor implementation following z_actor.c patterns\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 openAngle;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 lidRotation;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnChestPiece; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnChestPiece_Init(Actor* thisx, PlayState* play) {\\n    EnChestPiece* this = (EnChestPiece*)thisx;\\n    \\n    // Authentic collision initialization\\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actionState = 0;\\n    this->openAngle = 0;\\n    this->lidRotation = 0.0f;\\n    \\n    // Authentic actor setup\\n    this->actor.world.rot.y = this->actor.shape.rot.y;\\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnChestPiece_Update(Actor* thisx, PlayState* play) {\\n    EnChestPiece* this = (EnChestPiece*)thisx;\\n    \\n    // Authentic collision check pattern\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    switch(this->actionState) {\\n        case 0: // Waiting for player interaction\\n            if (Actor_HasParentActor(&this->actor)) {\\n                this->actionState = 1;\\n                this->actor.parent = NULL;\\n            }\\n            break;\\n            \\n        case 1: // Opening animation\\n            this->openAngle += 0x200;\\n            if (this->openAngle >= 0x4000) {\\n                this->openAngle = 0x4000;\\n                this->actionState = 2;\\n                \\n                // Spawn heart piece using authentic EnItem00 pattern\\n                Vec3f spawnPos = this->actor.world.pos;\\n                spawnPos.y += 40.0f;\\n                Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                          spawnPos.x, spawnPos.y, spawnPos.z,\\n                          0, 0, 0, ITEM00_HEART_PIECE);\\n            }\\n            break;\\n    }\\n    \\n    // Authentic ground collision check\\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\\n}\\n\\nconst ActorProfile EnChestPiece_Profile = {\\n    /**/ ACTOR_EN_CHEST_PIECE,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnChestPiece),\\n    /**/ EnChestPiece_Init,\\n    /**/ EnChestPiece_Destroy,\\n    /**/ EnChestPiece_Update,\\n    /**/ EnChestPiece_Draw,\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit and breaks into pieces using authentic OoT patterns", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 breakState;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n    /* 0x01A0 */ Vec3f velocity;\n} EnBreakPot; // size = 0x1AC\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnBreakPot_Init(Actor* thisx, PlayState* play) {\n    EnBreakPot* this = (EnBreakPot*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    Actor_SetFocus(&this->actor, 20.0f);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->breakState = 0;\n    this->timer = 0;\n    this->scale = 1.0f;\n}\n\nvoid EnBreakPot_Update(Actor* thisx, PlayState* play) {\n    EnBreakPot* this = (EnBreakPot*)thisx;\n    \n    if (this->breakState == 0) {\n        // Update collision when intact\n        Collider_UpdateCylinder(&this->actor, &this->collider);\n        CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n        CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n        \n        // Check if hit\n        if (this->collider.base.acFlags & AC_HIT) {\n            Vec3f spawnPos;\n            Math_Vec3f_Copy(&spawnPos, &this->actor.world.pos);\n            spawnPos.y += 30.0f;\n            \n            // Spawn heart piece using authentic EnItem00\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       spawnPos.x, spawnPos.y, spawnPos.z,\n                       0, 0, 0, ITEM00_HEART_PIECE);\n                       \n            this->breakState = 1;\n            this->timer = 30;\n        }\n    } else {\n        // Handle breaking state\n        this->timer--;\n        if (this->timer <= 0) {\n            Actor_Kill(&this->actor);\n        }\n    }\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n}\n\nconst ActorProfile EnBreakPot_Profile = {\n    /**/ ACTOR_EN_BREAK_POT,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnBreakPot),\n    /**/ EnBreakPot_Init,\n    /**/ Actor_Destroy,\n    /**/ EnBreakPot_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and state management.", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnBreakable; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_WOOD,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000040, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 40, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnBreakable_Init(Actor* thisx, PlayState* play) {\\n    EnBreakable* this = (EnBreakable*)thisx;\\n    \\n    // Authentic collision initialization\\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actionState = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnBreakable_Update(Actor* thisx, PlayState* play) {\\n    EnBreakable* this = (EnBreakable*)thisx;\\n    \\n    // Authentic collision check pattern\\n    if (this->collider.base.acFlags & AC_HIT) {\\n        Vec3f spawnPos;\\n        spawnPos.x = this->actor.world.pos.x;\\n        spawnPos.y = this->actor.world.pos.y;\\n        spawnPos.z = this->actor.world.pos.z;\\n        \\n        // Authentic EnItem00 spawn pattern for heart piece\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n        \\n        Actor_Kill(&this->actor);\\n        return;\\n    }\\n    \\n    // Authentic collision update sequence\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnBreakable_Profile = {\\n    /**/ ACTOR_EN_BREAKABLE,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnBreakable),\\n    /**/ EnBreakable_Init,\\n    /**/ EnBreakable_Destroy,\\n    /**/ EnBreakable_Update,\\n    /**/ EnBreakable_Draw\\n};"}
{"instruction": "Implement a treasure chest actor that spawns a heart piece when opened, with proper collision detection and state management following OoT patterns", "output": "`\n// Authentic pattern following z_actor.c and z_en_box.c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 openingState;\n    /* 0x0150 */ f32 lidAngle;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnTreasureChest; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_WOOD,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_WOOD,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 30, 45, 0, { 0, 0, 0 } },\n};\n\nvoid EnTreasureChest_Init(Actor* thisx, PlayState* play) {\n    EnTreasureChest* this = (EnTreasureChest*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.world.rot.y = this->actor.shape.rot.y;\n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->openingState = 0;\n    this->lidAngle = 0.0f;\n}\n\nvoid EnTreasureChest_Update(Actor* thisx, PlayState* play) {\n    EnTreasureChest* this = (EnTreasureChest*)thisx;\n    \n    // Authentic collision check pattern\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    switch(this->openingState) {\n        case 0: // Closed\n            if (Actor_IsFacingAndNearPlayer(&this->actor, 80.0f, 0x3000)) {\n                this->openingState = 1;\n                this->timer = 30;\n            }\n            break;\n            \n        case 1: // Opening\n            this->lidAngle += 0.05f;\n            if (--this->timer <= 0) {\n                Vec3f spawnPos;\n                spawnPos.x = this->actor.world.pos.x;\n                spawnPos.y = this->actor.world.pos.y + 40.0f;\n                spawnPos.z = this->actor.world.pos.z;\n                \n                // Authentic EnItem00 spawn pattern for heart piece\n                Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                           spawnPos.x, spawnPos.y, spawnPos.z,\n                           0, 0, 0, ITEM00_HEART_PIECE);\n                           \n                this->openingState = 2;\n            }\n            break;\n            \n        case 2: // Opened\n            break;\n    }\n}\n\nconst ActorProfile EnTreasureChest_Profile = {\n    /**/ ACTOR_EN_TREASURE_CHEST,\n    /**/ ACTORCAT_CHEST,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnTreasureChest),\n    /**/ EnTreasureChest_Init,\n    /**/ Actor_Destroy,\n    /**/ EnTreasureChest_Update,\n    /**/ Actor_Draw,\n};`\n}"}
{"instruction": "Create a debugging actor that spawns a heart piece and displays collision info when hit", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 debugState;\\n    /* 0x0150 */ f32 displayRange;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnDbgHelp; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnDbgHelp_Init(Actor* thisx, PlayState* play) {\\n    EnDbgHelp* this = (EnDbgHelp*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->displayRange = 150.0f;\\n    this->debugState = 0;\\n    this->timer = 0;\\n    \\n    this->actor.focus.pos = this->actor.world.pos;\\n    this->actor.targetMode = 0;\\n}\\n\\nvoid EnDbgHelp_Update(Actor* thisx, PlayState* play) {\\n    EnDbgHelp* this = (EnDbgHelp*)thisx;\\n    \\n    this->timer++;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        // Spawn heart piece using authentic EnItem00 pattern\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    this->actor.world.pos.x,\\n                    this->actor.world.pos.y + 40.0f,\\n                    this->actor.world.pos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n                    \\n        this->debugState ^= 1;\\n    }\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnDbgHelp_Profile = {\\n    /**/ ACTOR_EN_DBG_HELP,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnDbgHelp),\\n    /**/ EnDbgHelp_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnDbgHelp_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece and blue rupee when hit, with proper collision handling and state management", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 hitCount;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnRewardSpawner; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnRewardSpawner_Init(Actor* thisx, PlayState* play) {\n    EnRewardSpawner* this = (EnRewardSpawner*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.targetMode = 3;\n    this->actor.colChkInfo.mass = 0xFF;\n    \n    Actor_SetFocus(&this->actor, 20.0f);\n    this->actionState = 0;\n    this->hitCount = 0;\n}\n\nvoid EnRewardSpawner_Update(Actor* thisx, PlayState* play) {\n    EnRewardSpawner* this = (EnRewardSpawner*)thisx;\n    Vec3f spawnPos;\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    if (this->collider.base.acFlags & AC_HIT) {\n        this->hitCount++;\n        spawnPos = this->actor.world.pos;\n        spawnPos.y += 40.0f;\n        \n        if (this->hitCount == 1) {\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       spawnPos.x, spawnPos.y, spawnPos.z,\n                       0, 0, 0, ITEM00_HEART_PIECE);\n        } else if (this->hitCount == 2) {\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       spawnPos.x, spawnPos.y, spawnPos.z,\n                       0, 0, 0, ITEM00_RUPEE_BLUE);\n            Actor_Kill(&this->actor);\n        }\n    }\n}\n\nconst ActorProfile EnRewardSpawner_Profile = {\n    /**/ ACTOR_EN_REWARD_SPAWNER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnRewardSpawner),\n    /**/ EnRewardSpawner_Init,\n    /**/ Actor_Destroy,\n    /**/ EnRewardSpawner_Update,\n    /**/ NULL\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, including proper collision setup and state handling", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 hitTimer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->actor.world.pos.y += 20.0f;\\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actionState = 0;\\n    this->hitTimer = 0;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    if (this->hitTimer > 0) {\\n        this->hitTimer--;\\n    }\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->collider.base.acFlags &= ~AC_HIT;\\n        \\n        if (this->hitTimer <= 0) {\\n            Vec3f spawnPos = this->actor.world.pos;\\n            spawnPos.y += 40.0f;\\n            \\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, 0, 0, ITEM00_HEART_PIECE);\\n            \\n            Actor_Kill(&this->actor);\\n            return;\\n        }\\n    }\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and state management", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\\n    this->actionState = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->actionState == 1) {\\n        if (this->timer > 0) {\\n            this->timer--;\\n        } else {\\n            Vec3f spawnPos;\\n            spawnPos.x = this->actor.world.pos.x;\\n            spawnPos.y = this->actor.world.pos.y + 40.0f;\\n            spawnPos.z = this->actor.world.pos.z;\\n            \\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, 0, 0, ITEM00_HEART_PIECE);\\n            Actor_Kill(&this->actor);\\n        }\\n    } else if (this->actor.colChkInfo.acHitInfo != NULL) {\\n        this->actionState = 1;\\n        this->timer = 10;\\n    }\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL,\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and state management", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 hitCount;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->hitCount = 0;\\n    this->actionState = 0;\\n    Actor_SetScale(&this->actor, 0.01f);\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitCount++;\\n        if (this->hitCount >= 3) {\\n            Vec3f spawnPos;\\n            spawnPos.x = this->actor.world.pos.x;\\n            spawnPos.y = this->actor.world.pos.y;\\n            spawnPos.z = this->actor.world.pos.z;\\n            \\n            // Authentic EnItem00 spawn pattern for heart piece\\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, 0, 0, ITEM00_HEART_PIECE);\\n            Actor_Kill(&this->actor);\\n            return;\\n        }\\n    }\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns collectible rupees in a rotating circle pattern when interacted with, using authentic OoT patterns and collision detection", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 spawnState;\n    /* 0x0150 */ f32 rotationAngle;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnRupeeSpawner; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnRupeeSpawner_Init(Actor* thisx, PlayState* play) {\n    EnRupeeSpawner* this = (EnRupeeSpawner*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.targetMode = 0;\n    this->actor.gravity = 0.0f;\n    \n    this->timer = 0;\n    this->spawnState = 0;\n    this->rotationAngle = 0.0f;\n    \n    Actor_SetFocus(&this->actor, 20.0f);\n}\n\nvoid EnRupeeSpawner_Update(Actor* thisx, PlayState* play) {\n    EnRupeeSpawner* this = (EnRupeeSpawner*)thisx;\n    Vec3f spawnPos;\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (this->spawnState == 1) {\n        if (this->timer % 8 == 0) {\n            spawnPos.x = this->actor.world.pos.x + (Math_SinS(this->rotationAngle) * 50.0f);\n            spawnPos.y = this->actor.world.pos.y + 40.0f;\n            spawnPos.z = this->actor.world.pos.z + (Math_CosS(this->rotationAngle) * 50.0f);\n            \n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       spawnPos.x, spawnPos.y, spawnPos.z,\n                       0, this->rotationAngle, 0, ITEM00_RUPEE_BLUE);\n                       \n            this->rotationAngle += 0x1000;\n        }\n        \n        this->timer++;\n        if (this->timer >= 64) {\n            this->spawnState = 0;\n            this->timer = 0;\n        }\n    }\n    \n    if (Actor_HasParent(&this->actor, play)) {\n        this->spawnState = 1;\n        this->timer = 0;\n    } else if (this->spawnState == 0) {\n        func_8002F580(&this->actor, play);\n    }\n}\n\nconst ActorProfile EnRupeeSpawner_Profile = {\n    /**/ ACTOR_EN_RUPEESPAWNER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnRupeeSpawner),\n    /**/ EnRupeeSpawner_Init,\n    /**/ Actor_Destroy,\n    /**/ EnRupeeSpawner_Update,\n    /**/ NULL\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, using authentic collision detection and EnItem00 spawning patterns", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnTarget; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_WOOD,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_WOOD,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 40, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnTarget_Init(Actor* thisx, PlayState* play) {\\n    EnTarget* this = (EnTarget*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->actionState = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnTarget_Update(Actor* thisx, PlayState* play) {\\n    EnTarget* this = (EnTarget*)thisx;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        // Spawn heart piece using authentic EnItem00 pattern\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                   this->actor.world.pos.x,\\n                   this->actor.world.pos.y + 40.0f,\\n                   this->actor.world.pos.z,\\n                   0, 0, 0, ITEM00_HEART_PIECE);\\n                   \\n        Actor_Kill(&this->actor);\\n        return;\\n    }\\n    \\n    // Authentic collision update sequence\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnTarget_Profile = {\\n    /**/ ACTOR_EN_TARGET,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnTarget),\\n    /**/ EnTarget_Init,\\n    /**/ EnTarget_Destroy,\\n    /**/ EnTarget_Update,\\n    /**/ NULL,\\n};"}
{"instruction": "Implement a chest actor that spawns a heart piece when opened, with proper collision detection and state management. Must follow OoT chest behavior patterns.", "output": "`\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 openingState;\n    /* 0x0150 */ f32 lidAngle;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnTreasureChest; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_WOOD,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_WOOD,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 30, 45, 0, { 0, 0, 0 } },\n};\n\nvoid EnTreasureChest_Init(Actor* thisx, PlayState* play) {\n    EnTreasureChest* this = (EnTreasureChest*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->openingState = 0;\n    this->lidAngle = 0.0f;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.focus.pos = this->actor.world.pos;\n    this->actor.focus.pos.y += 30.0f;\n}\n\nvoid EnTreasureChest_Update(Actor* thisx, PlayState* play) {\n    EnTreasureChest* this = (EnTreasureChest*)thisx;\n    Vec3f spawnPos;\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 35.0f, 15.0f, 0.0f, BGCHECKFLAG_GROUND);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    switch(this->openingState) {\n        case 0:\n            if (Actor_HasParent(&this->actor, play)) {\n                this->openingState = 1;\n                this->timer = 20;\n            } else {\n                Actor_OfferCarry(&this->actor, play);\n            }\n            break;\n            \n        case 1:\n            this->timer--;\n            this->lidAngle += 0.05f;\n            \n            if (this->timer == 0) {\n                spawnPos = this->actor.world.pos;\n                spawnPos.y += 40.0f;\n                \n                // Spawn heart piece using authentic EnItem00 pattern\n                Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                           spawnPos.x, spawnPos.y, spawnPos.z,\n                           0, 0, 0, ITEM00_HEART_PIECE);\n                           \n                this->openingState = 2;\n            }\n            break;\n    }\n}\n\nconst ActorProfile EnTreasureChest_Profile = {\n    /**/ ACTOR_EN_TREASURE_CHEST,\n    /**/ ACTORCAT_CHEST,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnTreasureChest),\n    /**/ EnTreasureChest_Init,\n    /**/ Actor_Destroy,\n    /**/ EnTreasureChest_Update,\n    /**/ Actor_Draw,\n};\n`\n}"}
{"instruction": "Create a debugging helper actor that spawns a blue rupee at its position when hit by the player's sword, then despawns itself after 30 frames", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnDbgHelper; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnDbgHelper_Init(Actor* thisx, PlayState* play) {\\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->timer = 0;\\n    this->actionState = 0;\\n}\\n\\nvoid EnDbgHelper_Destroy(Actor* thisx, PlayState* play) {\\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\\n    Collider_DestroyCylinder(play, &this->collider);\\n}\\n\\nvoid EnDbgHelper_Update(Actor* thisx, PlayState* play) {\\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\\n    \\n    if (this->actionState == 1) {\\n        this->timer++;\\n        if (this->timer >= 30) {\\n            Actor_Kill(&this->actor);\\n            return;\\n        }\\n    }\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                   this->actor.world.pos.x,\\n                   this->actor.world.pos.y,\\n                   this->actor.world.pos.z,\\n                   0, 0, 0, ITEM00_RUPEE_BLUE);\\n        this->actionState = 1;\\n    }\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnDbgHelper_Profile = {\\n    /**/ ACTOR_EN_DBG_HELPER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnDbgHelper),\\n    /**/ EnDbgHelper_Init,\\n    /**/ EnDbgHelper_Destroy, \\n    /**/ EnDbgHelper_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a sequence of collectibles in a rotating pattern when triggered, with proper collision detection and state management.", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 spawnState;\n    /* 0x0150 */ f32 rotationAngle;\n    /* 0x0154 */ s16 spawnCount;\n    /* 0x0156 */ s16 activeTime;\n    /* 0x0158 */ ColliderCylinder collider;\n} EnCollectSpawner; // size = 0x1A4\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnCollectSpawner_Init(Actor* thisx, PlayState* play) {\n    EnCollectSpawner* this = (EnCollectSpawner*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.targetMode = 0;\n    this->spawnState = 0;\n    this->timer = 0;\n    this->spawnCount = 0;\n    this->rotationAngle = 0.0f;\n    this->activeTime = 100;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnCollectSpawner_Update(Actor* thisx, PlayState* play) {\n    EnCollectSpawner* this = (EnCollectSpawner*)thisx;\n    Vec3f spawnPos;\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    switch(this->spawnState) {\n        case 0:\n            if (Actor_HasParent(&this->actor, play)) {\n                this->spawnState = 1;\n                this->timer = this->activeTime;\n            } else {\n                Actor_OfferGetItem(&this->actor, play, GI_NONE, 100.0f, 50.0f);\n            }\n            break;\n            \n        case 1:\n            this->timer--;\n            if (this->timer > 0 && this->spawnCount < 5) {\n                this->rotationAngle += M_PI / 30.0f;\n                \n                if ((this->timer % 20) == 0) {\n                    spawnPos.x = this->actor.world.pos.x + (Math_SinS(this->rotationAngle) * 50.0f);\n                    spawnPos.y = this->actor.world.pos.y + 50.0f;\n                    spawnPos.z = this->actor.world.pos.z + (Math_CosS(this->rotationAngle) * 50.0f);\n                    \n                    Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                              spawnPos.x, spawnPos.y, spawnPos.z,\n                              0, 0, 0, ITEM00_RUPEE_BLUE);\n                    this->spawnCount++;\n                }\n            } else {\n                Actor_Kill(&this->actor);\n            }\n            break;\n    }\n}\n\nconst ActorProfile EnCollectSpawner_Profile = {\n    /**/ ACTOR_EN_COLLECTSPAWNER,\n    /**/ ACTORCAT_MISC,\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnCollectSpawner),\n    /**/ EnCollectSpawner_Init,\n    /**/ Actor_Destroy,\n    /**/ EnCollectSpawner_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, using authentic OoT collision and item spawning patterns", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 hitCount;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->hitCount = 0;\\n    this->actionState = 0;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitCount++;\\n        if (this->hitCount >= 3) {\\n            // Spawn heart piece using authentic EnItem00 pattern\\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       this->actor.world.pos.x,\\n                       this->actor.world.pos.y,\\n                       this->actor.world.pos.z,\\n                       0, 0, 0, ITEM00_HEART_PIECE);\\n            Actor_Kill(&this->actor);\\n        }\\n    }\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Implement a torch actor that can be lit/unlit, damages the player when lit, and drops a blue rupee when extinguished. Must use authentic collision and damage patterns.", "output": "// Authentic pattern following z_actor.c and z_collision_check.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 isLit;\\n    /* 0x0150 */ f32 flameScale;\\n    /* 0x0154 */ LightNode* lightNode;\\n    /* 0x0158 */ ColliderCylinder collider;\\n} EnTorch; // size = 0x1A4\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_ON | AT_TYPE_ENEMY,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x20, HIT_SPECIAL_EFFECT_FIRE, 0x01 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_ON | ATELEM_FIRE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 40, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnTorch_Init(Actor* thisx, PlayState* play) {\\n    EnTorch* this = (EnTorch*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->isLit = true;\\n    this->flameScale = 1.0f;\\n    \\n    // Authentic light node setup pattern\\n    this->lightNode = LightContext_InsertLight(play, &play->lightCtx, NULL);\\n    Lights_PointNoGlowSetInfo(&this->lightNode->light, this->actor.world.pos.x,\\n        this->actor.world.pos.y + 40.0f, this->actor.world.pos.z, 255, 200, 100, 200);\\n}\\n\\nvoid EnTorch_Update(Actor* thisx, PlayState* play) {\\n    EnTorch* this = (EnTorch*)thisx;\\n    \\n    if (this->isLit) {\\n        // Authentic collision check pattern\\n        Collider_UpdateCylinder(&this->actor, &this->collider);\\n        CollisionCheck_SetAT(play, &play->colChkCtx, &this->collider.base);\\n        CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n        \\n        // Update light position using authentic pattern\\n        Lights_PointNoGlowSetInfo(&this->lightNode->light, this->actor.world.pos.x,\\n            this->actor.world.pos.y + 40.0f, this->actor.world.pos.z, 255, 200, 100, 200);\\n        \\n        // Check for water collision to extinguish\\n        if (WaterBox_GetSurfaceImpl(play, &play->colCtx, this->actor.world.pos.x,\\n            this->actor.world.pos.z, &this->actor.world.pos.y, NULL)) {\\n            this->isLit = false;\\n            \\n            // Spawn blue rupee using authentic EnItem00 pattern\\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z,\\n                       0, 0, 0, ITEM00_RUPEE_BLUE);\\n        }\\n    }\\n}\\n\\nconst ActorProfile EnTorch_Profile = {\\n    /**/ ACTOR_EN_TORCH,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnTorch),\\n    /**/ EnTorch_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnTorch_Update,\\n    /**/ NULL,\\n};"}
{"instruction": "Create a debugging actor that spawns a heart piece and displays collision info when hit by the player", "output": "// Authentic pattern following z_actor.c and z_collision_check.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 debugState;\\n    /* 0x0150 */ f32 displayRange;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnDbgHelp; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnDbgHelp_Init(Actor* thisx, PlayState* play) {\\n    EnDbgHelp* this = (EnDbgHelp*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->timer = 0;\\n    this->debugState = 0;\\n    this->displayRange = 100.0f;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n}\\n\\nvoid EnDbgHelp_Update(Actor* thisx, PlayState* play) {\\n    EnDbgHelp* this = (EnDbgHelp*)thisx;\\n    \\n    this->timer++;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        // Spawn heart piece using authentic EnItem00 pattern\\n        Vec3f spawnPos = this->actor.world.pos;\\n        spawnPos.y += 40.0f;\\n        \\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n                    \\n        this->debugState ^= 1;\\n    }\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnDbgHelp_Profile = {\\n    /**/ ACTOR_EN_DBG_HELP,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnDbgHelp),\\n    /**/ EnDbgHelp_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnDbgHelp_Update,\\n    /**/ NULL,\\n};"}
{"instruction": "Create an actor that spawns collectible rupees when hit and uses proper collision detection", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 health;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnRupeeSpawner; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 25, 40, 0, { 0, 0, 0 } },\n};\n\nvoid EnRupeeSpawner_Init(Actor* thisx, PlayState* play) {\n    EnRupeeSpawner* this = (EnRupeeSpawner*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->health = 3;\n    this->actionState = 0;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\n    Actor_SetFocus(&this->actor, 20.0f);\n}\n\nvoid EnRupeeSpawner_Update(Actor* thisx, PlayState* play) {\n    EnRupeeSpawner* this = (EnRupeeSpawner*)thisx;\n    Vec3f spawnPos;\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        this->health--;\n        \n        spawnPos = this->actor.world.pos;\n        spawnPos.y += 20.0f;\n        \n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   spawnPos.x, spawnPos.y, spawnPos.z,\n                   0, 0x4000, 0, ITEM00_RUPEE_BLUE);\n                   \n        if (this->health <= 0) {\n            Actor_Kill(&this->actor);\n        }\n    }\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 0.0f, BGCHECKFLAG_GROUND);\n}\n\nconst ActorProfile EnRupeeSpawner_Profile = {\n    /**/ ACTOR_EN_RUPEESPAWNER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnRupeeSpawner),\n    /**/ EnRupeeSpawner_Init,\n    /**/ Actor_Destroy,\n    /**/ EnRupeeSpawner_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, using authentic collision detection and EnItem00 spawning patterns", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnTarget; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_WOOD,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_WOOD,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 40, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnTarget_Init(Actor* thisx, PlayState* play) {\\n    EnTarget* this = (EnTarget*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->actionState = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnTarget_Update(Actor* thisx, PlayState* play) {\\n    EnTarget* this = (EnTarget*)thisx;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        Vec3f spawnPos;\\n        spawnPos.x = this->actor.world.pos.x;\\n        spawnPos.y = this->actor.world.pos.y + 40.0f;\\n        spawnPos.z = this->actor.world.pos.z;\\n        \\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n        \\n        Actor_Kill(&this->actor);\\n        return;\\n    }\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnTarget_Profile = {\\n    /**/ ACTOR_EN_TARGET,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnTarget),\\n    /**/ EnTarget_Init,\\n    /**/ EnTarget_Destroy,\\n    /**/ EnTarget_Update,\\n    /**/ EnTarget_Draw,\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and state management", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actionState = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        Vec3f spawnPos;\\n        spawnPos.x = this->actor.world.pos.x;\\n        spawnPos.y = this->actor.world.pos.y;\\n        spawnPos.z = this->actor.world.pos.z;\\n        \\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n                    \\n        Actor_Kill(&this->actor);\\n    }\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_NONE,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and state management", "output": "// Authentic actor pattern following z_actor.c style\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 hitCount;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->hitCount = 0;\\n    this->actionState = 0;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    // Update collision\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitCount++;\\n        if (this->hitCount >= 3) {\\n            // Spawn heart piece using authentic EnItem00 pattern\\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       this->actor.world.pos.x,\\n                       this->actor.world.pos.y,\\n                       this->actor.world.pos.z,\\n                       0, 0, 0, ITEM00_HEART_PIECE);\\n            Actor_Kill(&this->actor);\\n        }\\n    }\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns heart pieces when hit and includes proper collision detection, scaling, and state management following OoT patterns", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 scale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actor.world.pos.y += 20.0f;\\n    Actor_SetFocus(&this->actor, 20.0f);\\n    \\n    this->timer = 0;\\n    this->actionState = 0;\\n    this->scale = 1.0f;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        Vec3f spawnPos;\\n        spawnPos.x = this->actor.world.pos.x;\\n        spawnPos.y = this->actor.world.pos.y + 40.0f;\\n        spawnPos.z = this->actor.world.pos.z;\\n        \\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n                    \\n        Actor_Kill(&this->actor);\\n    }\\n    \\n    Actor_MoveXZGravity(&this->actor);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ EnHeartSpawner_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ EnHeartSpawner_Draw\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and authentic patterns", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ ColliderCylinder collider;\n} EnHeartSpawner; // size = 0x19C\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actionState = 0;\n    this->timer = 0;\n}\n\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    if (this->collider.base.acFlags & AC_HIT) {\n        // Spawn heart piece using authentic EnItem00 pattern\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   this->actor.world.pos.x,\n                   this->actor.world.pos.y + 20.0f,\n                   this->actor.world.pos.z,\n                   0, 0, 0, ITEM00_HEART_PIECE);\n                   \n        Actor_Kill(&this->actor);\n    }\n}\n\nconst ActorProfile EnHeartSpawner_Profile = {\n    /**/ ACTOR_EN_HEART_SPAWNER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnHeartSpawner),\n    /**/ EnHeartSpawner_Init,\n    /**/ Actor_Destroy,\n    /**/ EnHeartSpawner_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Implement a moving platform actor that spawns a heart piece when hit by an arrow, using authentic OoT patterns", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 moveState;\\n    /* 0x0150 */ f32 initialY;\\n    /* 0x0154 */ f32 moveRange;\\n    /* 0x0158 */ f32 moveSpeed;\\n    /* 0x015C */ ColliderCylinder collider;\\n} EnMovingPlatform; // size = 0x1A8\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_WOOD,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 50, 20, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnMovingPlatform_Init(Actor* thisx, PlayState* play) {\\n    EnMovingPlatform* this = (EnMovingPlatform*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.1f);\\n    \\n    this->initialY = this->actor.world.pos.y;\\n    this->moveRange = 100.0f;\\n    this->moveSpeed = 2.0f;\\n    this->moveState = 0;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\\n}\\n\\nvoid EnMovingPlatform_Update(Actor* thisx, PlayState* play) {\\n    EnMovingPlatform* this = (EnMovingPlatform*)thisx;\\n    Vec3f spawnPos;\\n    \\n    // Authentic collision update pattern\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    // Check for arrow hits using authentic pattern\\n    if (this->collider.base.acFlags & AC_HIT) {\\n        if (this->collider.base.ac->category == ACTORCAT_ARROW) {\\n            // Spawn heart piece using authentic EnItem00 pattern\\n            spawnPos = this->actor.world.pos;\\n            spawnPos.y += 50.0f;\\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, 0, 0, ITEM00_HEART_PIECE);\\n            Actor_Kill(&this->actor);\\n            return;\\n        }\\n    }\\n    \\n    // Authentic movement pattern\\n    if (this->moveState == 0) {\\n        this->actor.world.pos.y = this->initialY + (Math_SinS(this->timer * 0x800) * this->moveRange);\\n        this->timer++;\\n    }\\n    \\n    // Authentic ground collision check\\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 0.0f, BGCHECKFLAG_GROUND);\\n}\\n\\nconst ActorProfile EnMovingPlatform_Profile = {\\n    /**/ ACTOR_EN_MOVING_PLATFORM,\\n    /**/ ACTORCAT_BG,\\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnMovingPlatform),\\n    /**/ EnMovingPlatform_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnMovingPlatform_Update,\\n    /**/ NULL,\\n};"}
{"instruction": "Create an actor that spawns a ring of heart pieces when destroyed, with proper collision and state management", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 spinRate;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnHeartSpawner; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 40, 0, { 0, 0, 0 } },\n};\n\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.02f);\n    this->actor.colChkInfo.mass = 255;\n    this->actor.gravity = -1.0f;\n    \n    this->timer = 100;\n    this->actionState = 0;\n    this->spinRate = 0.1f;\n}\n\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    Vec3f spawnPos;\n    s32 i;\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 15.0f, 0.0f, BGCHECKFLAG_GROUND);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    \n    this->actor.world.rot.y += (s16)(this->spinRate * 0x4000);\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        for (i = 0; i < 4; i++) {\n            spawnPos.x = this->actor.world.pos.x + Math_SinS(i * 0x4000) * 50.0f;\n            spawnPos.y = this->actor.world.pos.y + 40.0f;\n            spawnPos.z = this->actor.world.pos.z + Math_CosS(i * 0x4000) * 50.0f;\n            \n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       spawnPos.x, spawnPos.y, spawnPos.z,\n                       0, 0, 0, ITEM00_HEART_PIECE);\n        }\n        Actor_Kill(&this->actor);\n    }\n    \n    Actor_MoveXZGravity(&this->actor);\n}\n\nconst ActorProfile EnHeartSpawner_Profile = {\n    /**/ ACTOR_EN_HEART_SPAWNER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnHeartSpawner),\n    /**/ EnHeartSpawner_Init,\n    /**/ EnHeartSpawner_Destroy,\n    /**/ EnHeartSpawner_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, using authentic collision detection and EnItem00 spawning patterns.", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnTarget; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_WOOD,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_WOOD,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 40, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnTarget_Init(Actor* thisx, PlayState* play) {\\n    EnTarget* this = (EnTarget*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->actionState = 0;\\n    this->timer = 0;\\n    \\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnTarget_Update(Actor* thisx, PlayState* play) {\\n    EnTarget* this = (EnTarget*)thisx;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        Vec3f spawnPos;\\n        spawnPos.x = this->actor.world.pos.x;\\n        spawnPos.y = this->actor.world.pos.y;\\n        spawnPos.z = this->actor.world.pos.z;\\n        \\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n        \\n        Actor_Kill(&this->actor);\\n        return;\\n    }\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnTarget_Profile = {\\n    /**/ ACTOR_EN_TARGET,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnTarget),\\n    /**/ EnTarget_Init,\\n    /**/ EnTarget_Destroy,\\n    /**/ EnTarget_Update,\\n    /**/ EnTarget_Draw,\\n};"}
{"instruction": "Create a debugging actor that spawns a heart piece when hit and displays collision cylinder visually", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 hitCount;\\n    /* 0x0150 */ f32 debugScale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnDbgHelp; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 40, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnDbgHelp_Init(Actor* thisx, PlayState* play) {\\n    EnDbgHelp* this = (EnDbgHelp*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->timer = 0;\\n    this->hitCount = 0;\\n    this->debugScale = 1.0f;\\n}\\n\\nvoid EnDbgHelp_Update(Actor* thisx, PlayState* play) {\\n    EnDbgHelp* this = (EnDbgHelp*)thisx;\\n    \\n    this->timer++;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitCount++;\\n        \\n        // Spawn heart piece using authentic EnItem00 pattern\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    this->actor.world.pos.x,\\n                    this->actor.world.pos.y + 50.0f,\\n                    this->actor.world.pos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n    }\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnDbgHelp_Profile = {\\n    /**/ ACTOR_EN_DBG_HELP,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnDbgHelp),\\n    /**/ EnDbgHelp_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnDbgHelp_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, using authentic collision detection and EnItem00 spawning patterns", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 hitCount;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnBreakableHeart; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnBreakableHeart_Init(Actor* thisx, PlayState* play) {\\n    EnBreakableHeart* this = (EnBreakableHeart*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->hitCount = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnBreakableHeart_Update(Actor* thisx, PlayState* play) {\\n    EnBreakableHeart* this = (EnBreakableHeart*)thisx;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitCount++;\\n        if (this->hitCount >= 3) {\\n            // Spawn heart piece using authentic EnItem00 pattern\\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       this->actor.world.pos.x,\\n                       this->actor.world.pos.y,\\n                       this->actor.world.pos.z,\\n                       0, 0, 0, ITEM00_HEART_PIECE);\\n            Actor_Kill(&this->actor);\\n            return;\\n        }\\n    }\\n    \\n    // Authentic collision update sequence\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnBreakableHeart_Profile = {\\n    /**/ ACTOR_EN_BREAKABLE_HEART,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnBreakableHeart),\\n    /**/ EnBreakableHeart_Init,\\n    /**/ EnBreakableHeart_Destroy,\\n    /**/ EnBreakableHeart_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Implement a chest actor that spawns a heart piece when opened, with proper collision detection and state management following OoT patterns", "output": "// Authentic actor pattern following z_actor.c and z_en_box.c\\n\\ntypedef enum {\\n    /* 0x00 */ CHEST_STATE_CLOSED,\\n    /* 0x01 */ CHEST_STATE_OPENING,\\n    /* 0x02 */ CHEST_STATE_OPENED\\n} ChestState;\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 openAngle;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnChestPiece; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_WOOD,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_WOOD,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 30, 40, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnChestPiece_Init(Actor* thisx, PlayState* play) {\\n    EnChestPiece* this = (EnChestPiece*)thisx;\\n    \\n    // Authentic collision initialization\\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actionState = CHEST_STATE_CLOSED;\\n    this->openAngle = 0.0f;\\n    \\n    // Authentic actor setup\\n    this->actor.world.rot.y = this->actor.shape.rot.y;\\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnChestPiece_Update(Actor* thisx, PlayState* play) {\\n    EnChestPiece* this = (EnChestPiece*)thisx;\\n    \\n    // Authentic collision update pattern\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    switch(this->actionState) {\\n        case CHEST_STATE_CLOSED:\\n            if (Actor_ProcessInteract(&this->actor, &play->actorCtx.targetCtx)) {\\n                this->actionState = CHEST_STATE_OPENING;\\n                Audio_PlayActorSound2(&this->actor, NA_SE_EV_TREASURE_BOX_OPEN);\\n            }\\n            break;\\n            \\n        case CHEST_STATE_OPENING:\\n            this->openAngle += 3.0f * M_PI / 180.0f;\\n            if (this->openAngle >= M_PI / 2) {\\n                this->openAngle = M_PI / 2;\\n                this->actionState = CHEST_STATE_OPENED;\\n                \\n                // Authentic EnItem00 spawn pattern for heart piece\\n                Vec3f spawnPos = this->actor.world.pos;\\n                spawnPos.y += 40.0f;\\n                Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                          spawnPos.x, spawnPos.y, spawnPos.z,\\n                          0, 0, 0, ITEM00_HEART_PIECE);\\n            }\\n            break;\\n    }\\n}\\n\\nconst ActorProfile EnChestPiece_Profile = {\\n    /**/ ACTOR_EN_CHEST_PIECE,\\n    /**/ ACTORCAT_CHEST,\\n    /**/ FLAGS,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnChestPiece),\\n    /**/ EnChestPiece_Init,\\n    /**/ EnChestPiece_Destroy,\\n    /**/ EnChestPiece_Update,\\n    /**/ EnChestPiece_Draw,\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit and has cylinder collision", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 hitCount;\\n    /* 0x0150 */ f32 scale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->timer = 0;\\n    this->hitCount = 3;\\n    this->scale = 1.0f;\\n    \\n    this->actor.targetMode = 0;\\n    this->actor.gravity = -1.0f;\\n    this->actor.flags |= ACTOR_FLAG_0;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    this->timer++;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitCount--;\\n        if (this->hitCount <= 0) {\\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                      this->actor.world.pos.x,\\n                      this->actor.world.pos.y,\\n                      this->actor.world.pos.z,\\n                      0, 0, 0, ITEM00_HEART_PIECE);\\n            Actor_Kill(&this->actor);\\n            return;\\n        }\\n    }\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ EnHeartSpawner_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ EnHeartSpawner_Draw,\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision handling and state management", "output": "// Authentic actor pattern following z_actor.c style\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actionState = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n\\n    if (this->collider.base.acFlags & AC_HIT) {\\n        Vec3f spawnPos;\\n        spawnPos.x = this->actor.world.pos.x;\\n        spawnPos.y = this->actor.world.pos.y;\\n        spawnPos.z = this->actor.world.pos.z;\\n        \\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n                    \\n        Actor_Kill(&this->actor);\\n    }\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Implement a crystal switch actor that spawns a blue rupee when hit, with proper collision detection and state management following OoT patterns", "output": "// Authentic pattern following z_actor.c and z_collision_check.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 switchState;\\n    /* 0x0150 */ f32 crystalScale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnCrystalSwitch; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 35, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnCrystalSwitch_Init(Actor* thisx, PlayState* play) {\\n    EnCrystalSwitch* this = (EnCrystalSwitch*)thisx;\\n    \\n    // Authentic collision initialization\\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->switchState = 0;\\n    this->timer = 0;\\n    this->crystalScale = 1.0f;\\n    \\n    Actor_SetScale(&this->actor, 0.1f);\\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnCrystalSwitch_Update(Actor* thisx, PlayState* play) {\\n    EnCrystalSwitch* this = (EnCrystalSwitch*)thisx;\\n    \\n    // Authentic collision check pattern\\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->collider.base.acFlags &= ~AC_HIT;\\n        \\n        if (this->switchState == 0) {\\n            this->switchState = 1;\\n            this->timer = 30;\\n            \\n            // Spawn rupee using authentic EnItem00 pattern\\n            Vec3f spawnPos = this->actor.world.pos;\\n            spawnPos.y += 50.0f;\\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, 0, 0, ITEM00_RUPEE_BLUE);\\n        }\\n    }\\n    \\n    if (this->timer > 0) {\\n        this->timer--;\\n        if (this->timer == 0) {\\n            this->switchState = 0;\\n        }\\n    }\\n    \\n    // Authentic collision update sequence\\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnCrystalSwitch_Profile = {\\n    /**/ ACTOR_EN_CRYSTAL_SWITCH,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnCrystalSwitch),\\n    /**/ EnCrystalSwitch_Init,\\n    /**/ EnCrystalSwitch_Destroy,\\n    /**/ EnCrystalSwitch_Update,\\n    /**/ EnCrystalSwitch_Draw,\\n};"}
{"instruction": "Implement an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and state management.", "output": "// Authentic actor pattern following z_actor.c style\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 hitCount;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 scale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->hitCount = 0;\\n    this->actionState = 0;\\n    \\n    this->actor.targetMode = 3;\\n    this->actor.colChkInfo.mass = 0xFF;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitCount++;\\n        if (this->hitCount >= 3) {\\n            Vec3f spawnPos;\\n            spawnPos.x = this->actor.world.pos.x;\\n            spawnPos.y = this->actor.world.pos.y;\\n            spawnPos.z = this->actor.world.pos.z;\\n            \\n            // Authentic EnItem00 spawn pattern for heart piece\\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, 0, 0, ITEM00_HEART_PIECE);\\n            \\n            Actor_Kill(&this->actor);\\n            return;\\n        }\\n    }\\n    \\n    // Authentic collision update pattern\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece and blue rupee when hit, with proper collision detection and state management", "output": "// Authentic actor pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 rewardScale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnReward; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnReward_Init(Actor* thisx, PlayState* play) {\\n    EnReward* this = (EnReward*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actor.focus.pos = this->actor.world.pos;\\n    this->actor.targetMode = 3;\\n    \\n    this->timer = 0;\\n    this->actionState = 0;\\n    this->rewardScale = 1.0f;\\n}\\n\\nvoid EnReward_Update(Actor* thisx, PlayState* play) {\\n    EnReward* this = (EnReward*)thisx;\\n    \\n    this->timer++;\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 15.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        Vec3f spawnPos = this->actor.world.pos;\\n        spawnPos.y += 40.0f;\\n        \\n        // Spawn heart piece using authentic EnItem00 pattern\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n                    \\n        spawnPos.x += 20.0f;\\n        // Spawn blue rupee using authentic EnItem00 pattern\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_RUPEE_BLUE);\\n                    \\n        Actor_Kill(&this->actor);\\n    }\\n}\\n\\nconst ActorProfile EnReward_Profile = {\\n    /**/ ACTOR_EN_REWARD,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnReward),\\n    /**/ EnReward_Init,\\n    /**/ EnReward_Destroy,\\n    /**/ EnReward_Update,\\n    /**/ EnReward_Draw,\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and hit response.", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 hitCount;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->hitCount = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitCount++;\\n        if (this->hitCount >= 3) {\\n            // Spawn heart piece using authentic EnItem00 pattern\\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       this->actor.world.pos.x,\\n                       this->actor.world.pos.y,\\n                       this->actor.world.pos.z,\\n                       0, 0, 0, ITEM00_HEART_PIECE);\\n            Actor_Kill(&this->actor);\\n            return;\\n        }\\n        this->timer = 10;\\n    }\\n    \\n    if (this->timer > 0) {\\n        this->timer--;\\n    }\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create a debug actor that spawns a heart piece when Link gets within 100 units, with visual radius indicator and collision", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ f32 detectionRadius;\\n    /* 0x0150 */ s16 hasSpawned;\\n    /* 0x0152 */ s16 debugState;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnDebugHelp; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 100, 50, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnDebugHelp_Init(Actor* thisx, PlayState* play) {\\n    EnDebugHelp* this = (EnDebugHelp*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->detectionRadius = 100.0f;\\n    this->hasSpawned = false;\\n    this->debugState = 0;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n}\\n\\nvoid EnDebugHelp_Update(Actor* thisx, PlayState* play) {\\n    EnDebugHelp* this = (EnDebugHelp*)thisx;\\n    Player* player = GET_PLAYER(play);\\n    \\n    if (!this->hasSpawned) {\\n        Vec3f dist;\\n        dist.x = player->actor.world.pos.x - this->actor.world.pos.x;\\n        dist.y = player->actor.world.pos.y - this->actor.world.pos.y;\\n        dist.z = player->actor.world.pos.z - this->actor.world.pos.z;\\n        \\n        if (Math_Vec3f_DistXYZ(&dist) < this->detectionRadius) {\\n            Vec3f spawnPos = this->actor.world.pos;\\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, 0, 0, ITEM00_HEART_PIECE);\\n            this->hasSpawned = true;\\n        }\\n    }\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnDebugHelp_Profile = {\\n    /**/ ACTOR_EN_DEBUG_HELP,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_NONE,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnDebugHelp),\\n    /**/ EnDebugHelp_Init,\\n    /**/ EnDebugHelp_Destroy,\\n    /**/ EnDebugHelp_Update,\\n    /**/ NULL,\\n};"}
{"instruction": "Create an actor that spawns rupees in a circular pattern when hit, with proper collision detection and state management", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 spinRadius;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnRupeeSpawner; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnRupeeSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnRupeeSpawner* this = (EnRupeeSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actor.world.rot.y = 0;\\n    this->spinRadius = 50.0f;\\n    this->actionState = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnRupeeSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnRupeeSpawner* this = (EnRupeeSpawner*)thisx;\\n    Vec3f spawnPos;\\n    s32 i;\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->actionState == 1) {\\n        if (this->timer > 0) {\\n            this->timer--;\\n            if ((this->timer % 4) == 0) {\\n                for (i = 0; i < 8; i++) {\\n                    spawnPos.x = this->actor.world.pos.x + (Math_SinS(i * 0x2000) * this->spinRadius);\\n                    spawnPos.y = this->actor.world.pos.y + 40.0f;\\n                    spawnPos.z = this->actor.world.pos.z + (Math_CosS(i * 0x2000) * this->spinRadius);\\n                    \\n                    Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                               spawnPos.x, spawnPos.y, spawnPos.z,\\n                               0, 0, 0, ITEM00_RUPEE_BLUE);\\n                }\\n            }\\n        } else {\\n            this->actionState = 0;\\n        }\\n    }\\n}\\n\\nconst ActorProfile EnRupeeSpawner_Profile = {\\n    /**/ ACTOR_EN_RUPEESPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnRupeeSpawner),\\n    /**/ EnRupeeSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnRupeeSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and state management.", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 scale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actionState = 0;\\n    this->timer = 0;\\n    \\n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        Vec3f spawnPos;\\n        spawnPos.x = this->actor.world.pos.x;\\n        spawnPos.y = this->actor.world.pos.y + 40.0f;\\n        spawnPos.z = this->actor.world.pos.z;\\n        \\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n                    \\n        Actor_Kill(&this->actor);\\n        return;\\n    }\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_NONE,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ EnHeartSpawner_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create a debug actor that spawns a heart piece when hit and displays its current state with color-coded debug text", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 debugState;\\n    /* 0x014E */ s16 timer;\\n    /* 0x0150 */ f32 hitEffect;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnDbgHelp; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnDbgHelp_Init(Actor* thisx, PlayState* play) {\\n    EnDbgHelp* this = (EnDbgHelp*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->debugState = 0;\\n    this->timer = 0;\\n    this->hitEffect = 0.0f;\\n}\\n\\nvoid EnDbgHelp_Update(Actor* thisx, PlayState* play) {\\n    EnDbgHelp* this = (EnDbgHelp*)thisx;\\n    \\n    this->timer++;\\n    \\n    if (this->hitEffect > 0.0f) {\\n        this->hitEffect -= 0.1f;\\n    }\\n\\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitEffect = 1.0f;\\n        this->debugState++;\\n        if (this->debugState >= 3) {\\n            this->debugState = 0;\\n        }\\n        \\n        // Spawn heart piece using authentic EnItem00 pattern\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                   this->actor.world.pos.x,\\n                   this->actor.world.pos.y + 40.0f,\\n                   this->actor.world.pos.z,\\n                   0, 0, 0, ITEM00_HEART_PIECE);\\n    }\\n    \\n    // Authentic collision update pattern\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnDbgHelp_Profile = {\\n    /**/ ACTOR_EN_DBG_HELP,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnDbgHelp),\\n    /**/ EnDbgHelp_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnDbgHelp_Update,\\n    /**/ Actor_Draw\\n};"}
{"instruction": "Create an actor that spawns heart pieces in a rotating circle pattern when hit, using authentic OoT patterns", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 hitCount;\n    /* 0x0150 */ f32 rotationAngle;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnHeartSpawner; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.world.pos.y += 20.0f;\n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\n    \n    this->timer = 0;\n    this->hitCount = 0;\n    this->rotationAngle = 0.0f;\n}\n\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    Vec3f spawnPos;\n    s32 i;\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    if (this->collider.base.acFlags & AC_HIT) {\n        this->hitCount++;\n        this->collider.base.acFlags &= ~AC_HIT;\n        \n        // Spawn heart pieces in a circle\n        for (i = 0; i < 4; i++) {\n            spawnPos.x = this->actor.world.pos.x + (Math_SinS(this->rotationAngle + (i * 0x4000)) * 30.0f);\n            spawnPos.y = this->actor.world.pos.y + 40.0f;\n            spawnPos.z = this->actor.world.pos.z + (Math_CosS(this->rotationAngle + (i * 0x4000)) * 30.0f);\n            \n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       spawnPos.x, spawnPos.y, spawnPos.z,\n                       0, 0, 0, ITEM00_HEART_PIECE);\n        }\n        \n        this->rotationAngle += 0x2000;\n        \n        if (this->hitCount >= 3) {\n            Actor_Kill(&this->actor);\n        }\n    }\n    \n    this->timer++;\n}\n\nconst ActorProfile EnHeartSpawner_Profile = {\n    /**/ ACTOR_EN_HEART_SPAWNER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnHeartSpawner),\n    /**/ EnHeartSpawner_Init,\n    /**/ Actor_Destroy,\n    /**/ EnHeartSpawner_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and spawn logic following OoT patterns", "output": "// Authentic pattern following z_en_item00.c and z_collision_check.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actionState = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        // Spawn heart piece using authentic EnItem00 pattern\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                   this->actor.world.pos.x,\\n                   this->actor.world.pos.y,\\n                   this->actor.world.pos.z,\\n                   0, 0, 0, ITEM00_HEART_PIECE);\\n        Actor_Kill(&this->actor);\\n    }\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit and includes proper collision detection, scaling, and state management following OoT patterns", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnHeartSpawner; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 30.0f);\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.flags |= ACTOR_FLAG_4;\n    this->actor.targetMode = 4;\n    \n    this->timer = 0;\n    this->actionState = 0;\n    this->scale = 1.0f;\n}\n\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   this->actor.world.pos.x,\n                   this->actor.world.pos.y + 20.0f,\n                   this->actor.world.pos.z,\n                   0, 0, 0, ITEM00_HEART_PIECE);\n        Actor_Kill(&this->actor);\n    }\n}\n\nconst ActorProfile EnHeartSpawner_Profile = {\n    /**/ ACTOR_EN_HEART_SPAWNER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnHeartSpawner),\n    /**/ EnHeartSpawner_Init,\n    /**/ EnHeartSpawner_Destroy,\n    /**/ EnHeartSpawner_Update,\n    /**/ EnHeartSpawner_Draw,\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and state management", "output": "// Authentic actor pattern following z_actor.c\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 hitCount;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    // Authentic collision initialization\\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->hitCount = 0;\\n    this->actionState = 0;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    // Authentic collision check pattern\\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitCount++;\\n        if (this->hitCount >= 3) {\\n            // Spawn heart piece using authentic EnItem00 pattern\\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       this->actor.world.pos.x,\\n                       this->actor.world.pos.y,\\n                       this->actor.world.pos.z,\\n                       0, 0, 0, ITEM00_HEART_PIECE);\\n            Actor_Kill(&this->actor);\\n            return;\\n        }\\n    }\\n    \\n    // Authentic collision update sequence\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns heart pieces when hit by the player's sword, with proper collision detection and state management", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 hitCount;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 scale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->hitCount = 0;\\n    this->actionState = 0;\\n    this->scale = 1.0f;\\n    \\n    this->actor.world.pos.y += 20.0f;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitCount++;\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                   this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z,\\n                   0, 0, 0, ITEM00_HEART_PIECE);\\n        Actor_Kill(&this->actor);\\n    }\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Explain how to create an actor that spawns a heart piece when hit by the player's sword, using authentic OoT patterns", "output": "```c\n// Authentic actor structure with proper memory layout\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnHeartSpawner; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000010, 0x00, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actionState = 0;\n    this->timer = 0;\n}\n\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    // Authentic collision check pattern\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    if (this->collider.base.acFlags & AC_HIT) {\n        // Spawn heart piece using authentic EnItem00 pattern\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   this->actor.world.pos.x,\n                   this->actor.world.pos.y,\n                   this->actor.world.pos.z,\n                   0, 0, 0, ITEM00_HEART_PIECE);\n                   \n        Actor_Kill(&this->actor);\n    }\n}\n\nconst ActorProfile EnHeartSpawner_InitVars = {\n    /**/ ACTOR_EN_HEART_SPAWNER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnHeartSpawner),\n    /**/ EnHeartSpawner_Init,\n    /**/ EnHeartSpawner_Destroy,\n    /**/ EnHeartSpawner_Update,\n    /**/ NULL\n};\n```"}
