{"instruction": "I'm making a heavily armored knight enemy for my OoT romhack. It should only take damage from bombs or hammer strikes, have 3 HP, and play a metal 'clang' sound when hit incorrectly. Can you provide the full actor code with proper collision setup and debug logs for testing? It should use the standard OoT enemy patterns.", "output": "```c\n/**\n * File: z_en_armored_knight.c\n * Description: Armored Knight enemy implementation\n */\n\n#include \"z_en_armored_knight.h\"\n#include \"overlays/actors/ovl_Player/z_player.h\"\n#include \"assets/objects/object_sk2/object_sk2.h\"\n\n#define FLAGS (ACTOR_FLAG_0 | ACTOR_FLAG_2 | ACTOR_FLAG_4)\n\ntypedef enum {\n    /* 0 */ KNIGHT_IDLE,\n    /* 1 */ KNIGHT_CHASE,\n    /* 2 */ KNIGHT_DAMAGED,\n    /* 3 */ KNIGHT_DEATH\n} ArmoredKnightState;\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ Vec3s jointTable[20];\n    /* 0x0214 */ Vec3s morphTable[20];\n    /* 0x0298 */ s16 actionState;\n    /* 0x029A */ s16 timer;\n    /* 0x029C */ s16 damageTimer;\n    /* 0x029E */ s16 health;\n    /* 0x02A0 */ f32 scale;\n    /* 0x02A4 */ Vec3f velocity;\n    /* 0x02B0 */ ColliderCylinder bodyCollider;\n    /* 0x02FC */ ColliderCylinder damageCollider;\n} EnArmoredKnight; // size = 0x0348\n\nstatic ColliderCylinderInit sBodyColliderInit = {\n    {\n        COLTYPE_HIT0,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 25, 70, 0, { 0, 0, 0 } },\n};\n\nvoid EnArmoredKnight_Init(Actor* thisx, PlayState* play) {\n    EnArmoredKnight* this = (EnArmoredKnight*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.015f);\n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\n    this->health = 3;\n    this->actionState = KNIGHT_IDLE;\n    \n    Collider_InitCylinder(play, &this->bodyCollider);\n    Collider_SetCylinder(play, &this->bodyCollider, &this->actor, &sBodyColliderInit);\n    \n    this->actor.colChkInfo.health = 3;\n    this->actor.gravity = -2.0f;\n    this->actor.velocity.y = 0.0f;\n    \n    // Debug\n    osSyncPrintf(\"\\nArmored Knight initialized [%08x]\\n\", (uintptr_t)this);\n}\n\nvoid EnArmoredKnight_Destroy(Actor* thisx, PlayState* play) {\n    EnArmoredKnight* this = (EnArmoredKnight*)thisx;\n    Collider_DestroyCylinder(play, &this->bodyCollider);\n}\n\nvoid EnArmoredKnight_HandleDamage(EnArmoredKnight* this, PlayState* play) {\n    if (this->damageTimer > 0) {\n        this->damageTimer--;\n        return;\n    }\n\n    if (this->actor.colChkInfo.damageEffect != 0) {\n        // Only take damage from bombs or hammer\n        if (this->actor.colChkInfo.damageEffect == 0x0F || // Bomb damage\n            this->actor.colChkInfo.damageEffect == 0x06) { // Hammer damage\n            \n            this->health--;\n            this->damageTimer = 30;\n            this->actionState = KNIGHT_DAMAGED;\n            \n            if (this->health <= 0) {\n                this->actionState = KNIGHT_DEATH;\n                Actor_PlaySfx(&this->actor, NA_SE_EN_STAL_DEAD);\n            } else {\n                Actor_PlaySfx(&this->actor, NA_SE_EN_STAL_DAMAGE);\n            }\n            \n            // Debug\n            osSyncPrintf(\"Knight damaged! HP: %d\\n\", this->health);\n            \n        } else {\n            // Wrong damage type - play clang sound\n            Actor_PlaySfx(&this->actor, NA_SE_IT_SHIELD_REFLECT_SW);\n        }\n        \n        this->actor.colChkInfo.damageEffect = 0;\n    }\n}\n\nvoid EnArmoredKnight_Update(Actor* thisx, PlayState* play) {\n    EnArmoredKnight* this = (EnArmoredKnight*)thisx;\n    \n    EnArmoredKnight_HandleDamage(this, play);\n    \n    // Basic state machine\n    switch (this->actionState) {\n        case KNIGHT_IDLE:\n            if (Actor_WorldDistXZToActor(&this->actor, &GET_PLAYER(play)->actor) < 200.0f) {\n                this->actionState = KNIGHT_CHASE;\n            }\n            break;\n            \n        case KNIGHT_CHASE:\n            // Move toward player\n            break;\n            \n        case KNIGHT_DAMAGED:\n            if (this->damageTimer <= 0) {\n                this->actionState = KNIGHT_IDLE;\n            }\n            break;\n            \n        case KNIGHT_DEATH:\n            Actor_Kill(&this->actor);\n            break;\n    }\n    \n    // Update colliders\n    Collider_UpdateCylinder(&this->actor, &this->bodyCollider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->bodyCollider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->bodyCollider.base);\n}\n\nvoid EnArmoredKnight_Draw(Actor* thisx, PlayState* play) {\n    EnArmoredKnight* this = (EnArmoredKnight*)thisx;\n    \n    // Basic drawing code - would need proper model setup\n    Actor_DrawOpa(play, &this->actor);\n}\n\nconst ActorProfile En_ArmoredKnight_InitVars = {\n    ACTOR_EN_ARMORED_KNIGHT,\n    ACTORCAT_ENEMY,\n    FLAGS,\n    OBJECT_SK2,\n    sizeof(EnArmoredKnight),\n    (ActorFunc)EnArmoredKnight_Init,\n    (ActorFunc)EnArmoredKnight_Destroy,\n    (ActorFunc)EnArmoredKnight_Update,\n    (ActorFunc)EnArmoredKnight_Draw\n};\n```"}
{"instruction": "I'm trying to create a traveling merchant NPC that lets players buy and sell items using rupees. He should track the player, have a dialogue menu for buying/selling, and maintain inventory state. Can you help me implement this with proper OoT actor patterns and collision handling?", "output": "```c\n// EnMerchant.h\n#ifndef Z_EN_MERCHANT_H\n#define Z_EN_MERCHANT_H\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ EnMerchantActionFunc actionFunc;\n    /* 0x0194 */ NpcInteractInfo interactInfo;\n    /* 0x01BC */ ColliderCylinder collider;\n    /* 0x0208 */ s16 dialogState;\n    /* 0x020A */ s16 blinkTimer;\n    /* 0x020C */ s16 eyeState;\n    /* 0x020E */ s16 inventoryState;\n    /* 0x0210 */ u8 itemStock[8];\n    /* 0x0218 */ u16 itemPrices[8];\n    /* 0x0228 */ f32 dialogRadius;\n    /* 0x022C */ Vec3s jointTable[20];\n    /* 0x02A4 */ Vec3s morphTable[20];\n} EnMerchant; // size = 0x031C\n\n// EnMerchant.c\n#include \"z_en_merchant.h\"\n#include \"assets/objects/object_merchant/object_merchant.h\"\n\n#define MERCHANT_DIALOGUE_RADIUS 100.0f\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000004, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 60, 0, { 0, 0, 0 } },\n};\n\nvoid EnMerchant_Init(Actor* thisx, PlayState* play) {\n    EnMerchant* this = (EnMerchant*)thisx;\n    \n    Actor_ProcessInitChain(&this->actor, sInitChain);\n    Actor_SetScale(&this->actor, 0.01f);\n    \n    this->dialogRadius = MERCHANT_DIALOGUE_RADIUS;\n    this->dialogState = TEXT_STATE_NONE;\n    this->inventoryState = 0;\n    \n    // Initialize collision\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    // Initialize tracking\n    this->interactInfo.talkState = NPC_TALK_STATE_IDLE;\n    this->actionFunc = EnMerchant_Idle;\n}\n\nvoid EnMerchant_Destroy(Actor* thisx, PlayState* play) {\n    EnMerchant* this = (EnMerchant*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\ns16 EnMerchant_GetTextId(Actor* thisx, PlayState* play) {\n    EnMerchant* this = (EnMerchant*)thisx;\n    \n    if (Message_GetState(&play->msgCtx) == TEXT_STATE_NONE) {\n        return 0x1000; // Initial greeting message ID\n    }\n    return -1;\n}\n\nvoid EnMerchant_UpdateTalkState(Actor* thisx, PlayState* play) {\n    EnMerchant* this = (EnMerchant*)thisx;\n    \n    if (Message_GetState(&play->msgCtx) == TEXT_STATE_CLOSING) {\n        this->dialogState = TEXT_STATE_NONE;\n        this->actionFunc = EnMerchant_Idle;\n    }\n}\n\nvoid EnMerchant_Idle(EnMerchant* this, PlayState* play) {\n    Player* player = GET_PLAYER(play);\n    \n    // Update tracking\n    this->interactInfo.trackPos = player->actor.world.pos;\n    this->interactInfo.yOffset = !LINK_IS_ADULT ? 0.0f : -10.0f;\n    Npc_TrackPoint(&this->actor, &this->interactInfo, 4, NPC_TRACKING_FULL);\n    \n    // Handle dialogue\n    if (Actor_ProcessTalkRequest(&this->actor, play)) {\n        this->actionFunc = EnMerchant_Talk;\n        this->dialogState = TEXT_STATE_TALKING;\n    } else {\n        Npc_UpdateTalking(play, &this->actor, &this->interactInfo.talkState,\n                         this->dialogRadius, EnMerchant_GetTextId, EnMerchant_UpdateTalkState);\n    }\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnMerchant_Update(Actor* thisx, PlayState* play) {\n    EnMerchant* this = (EnMerchant*)thisx;\n    this->actionFunc(this, play);\n}\n\nvoid EnMerchant_Draw(Actor* thisx, PlayState* play) {\n    EnMerchant* this = (EnMerchant*)thisx;\n    \n    // Draw model and handle blinking\n    func_800943C8(play->state.gfxCtx);\n    SkelAnime_DrawOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable, NULL, NULL, this);\n}\n```"}
{"instruction": "I need help creating a smart Stalfos-like enemy that follows the player and enters different combat states (idle, chase, attack, damaged). It should use proper cylinder collision detection and handle damage states like vanilla enemies. Can you provide a complete actor implementation with proper state management and collision handling?", "output": "```c\n// Custom Enemy Implementation - Stalfos-like behavior\n#include \"z_en_custom.h\"\n#include \"assets/objects/object_sk/object_sk.h\"\n\ntypedef enum {\n    /* 0x00 */ ENEMY_STATE_IDLE,\n    /* 0x01 */ ENEMY_STATE_CHASE,\n    /* 0x02 */ ENEMY_STATE_ATTACK,\n    /* 0x03 */ ENEMY_STATE_DAMAGED,\n    /* 0x04 */ ENEMY_STATE_DEATH\n} EnemyState;\n\ntypedef struct EnCustom {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ Vec3s jointTable[20];\n    /* 0x0200 */ Vec3s morphTable[20];\n    /* 0x0270 */ s16 actionState;\n    /* 0x0272 */ s16 attackTimer;\n    /* 0x0274 */ s16 damageTimer;\n    /* 0x0276 */ s16 stunTimer;\n    /* 0x0278 */ f32 targetYaw;\n    /* 0x027C */ Vec3f targetPos;\n    /* 0x0288 */ ColliderCylinder bodyCollider;\n    /* 0x02D4 */ ColliderCylinder weaponCollider;\n} EnCustom; // size = 0x0320\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_HIT0,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 25, 60, 0, { 0, 0, 0 } },\n};\n\nvoid EnCustom_Init(Actor* thisx, PlayState* play) {\n    EnCustom* this = (EnCustom*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.colChkInfo.mass = MASS_HEAVY;\n    this->actor.colChkInfo.health = 4;\n    this->actor.gravity = -1.0f;\n    \n    Collider_InitCylinder(play, &this->bodyCollider);\n    Collider_SetCylinderType1(play, &this->bodyCollider, &this->actor, &sCylinderInit);\n    \n    this->actionState = ENEMY_STATE_IDLE;\n    this->actor.flags |= ACTOR_FLAG_0;\n    \n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 30.0f);\n    SkelAnime_InitFlex(play, &this->skelAnime, &gStalfosSkel, &gStalfosIdleAnim, this->jointTable, this->morphTable, 20);\n}\n\nvoid EnCustom_Destroy(Actor* thisx, PlayState* play) {\n    EnCustom* this = (EnCustom*)thisx;\n    Collider_DestroyCylinder(play, &this->bodyCollider);\n}\n\nvoid EnCustom_SetState(EnCustom* this, s16 newState) {\n    this->actionState = newState;\n    this->attackTimer = 0;\n    \n    switch (newState) {\n        case ENEMY_STATE_IDLE:\n            Animation_Change(&this->skelAnime, &gStalfosIdleAnim, 1.0f, 0.0f, \n                           Animation_GetLastFrame(&gStalfosIdleAnim), ANIMMODE_LOOP, -8.0f);\n            break;\n        case ENEMY_STATE_CHASE:\n            Animation_Change(&this->skelAnime, &gStalfosWalkAnim, 1.0f, 0.0f,\n                           Animation_GetLastFrame(&gStalfosWalkAnim), ANIMMODE_LOOP, -8.0f);\n            break;\n        case ENEMY_STATE_DAMAGED:\n            this->damageTimer = 20;\n            Audio_PlayActorSound2(&this->actor, NA_SE_EN_STAL_DAMAGE);\n            break;\n    }\n}\n\nvoid EnCustom_Update(Actor* thisx, PlayState* play) {\n    EnCustom* this = (EnCustom*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    SkelAnime_Update(&this->skelAnime);\n    \n    if (this->damageTimer > 0) {\n        this->damageTimer--;\n        if (this->damageTimer == 0) {\n            EnCustom_SetState(this, ENEMY_STATE_CHASE);\n        }\n    }\n    \n    if (this->actionState != ENEMY_STATE_DAMAGED && this->actionState != ENEMY_STATE_DEATH) {\n        f32 dist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n        \n        if (dist < 100.0f && this->actionState == ENEMY_STATE_IDLE) {\n            EnCustom_SetState(this, ENEMY_STATE_CHASE);\n        }\n        \n        if (this->actionState == ENEMY_STATE_CHASE) {\n            Math_SmoothStepToS(&this->actor.shape.rot.y, \n                              Math_Atan2S(this->actor.world.pos.z - player->actor.world.pos.z,\n                                        this->actor.world.pos.x - player->actor.world.pos.x) + 0x8000,\n                              0x800, 0x100, 0);\n            this->actor.world.rot.y = this->actor.shape.rot.y;\n            this->actor.speedXZ = 6.0f;\n        }\n    }\n    \n    if (this->actor.colChkInfo.health == 0) {\n        Enemy_StartFinishingBlow(play, &this->actor);\n        Actor_Kill(&this->actor);\n        return;\n    }\n    \n    Collider_UpdateCylinder(&this->actor, &this->bodyCollider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->bodyCollider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->bodyCollider.base);\n    Actor_MoveForward(&this->actor);\n    Actor_UpdateBgCheckInfo(play, &this->actor, 35.0f, 60.0f, 60.0f,\n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n}\n\nvoid EnCustom_Draw(Actor* thisx, PlayState* play) {\n    EnCustom* this = (EnCustom*)thisx;\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                         this->skelAnime.dListCount, NULL, NULL, this);\n}\n```"}
{"instruction": "I'm making a swordsman enemy with 3 attack patterns (slash, thrust, spin) based on distance to player. Need complete collision setup, damage detection, and state machine. Must use vanilla OoT functions and handle all edge cases. Please provide a complete implementation I can drop into my rom.", "output": "```c\n// EnSwordsman.h\n#ifndef Z_EN_SWORDSMAN_H\n#define Z_EN_SWORDSMAN_H\n\ntypedef enum {\n    /* 0x00 */ SWORDSMAN_IDLE,\n    /* 0x01 */ SWORDSMAN_CHASE,\n    /* 0x02 */ SWORDSMAN_SLASH,\n    /* 0x03 */ SWORDSMAN_THRUST,\n    /* 0x04 */ SWORDSMAN_SPIN,\n    /* 0x05 */ SWORDSMAN_DAMAGED,\n    /* 0x06 */ SWORDSMAN_DEATH\n} SwordsmanState;\n\ntypedef struct EnSwordsman {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ Vec3s jointTable[20];\n    /* 0x0204 */ Vec3s morphTable[20];\n    /* 0x0278 */ s16 actionState;\n    /* 0x027A */ s16 attackTimer;\n    /* 0x027C */ s16 damageTimer;\n    /* 0x027E */ s16 spinRotation;\n    /* 0x0280 */ f32 attackRange;\n    /* 0x0284 */ ColliderCylinder bodyCollider;\n    /* 0x02D0 */ ColliderQuad swordCollider;\n    /* 0x0350 */ Vec3f swordTip;\n    /* 0x035C */ Vec3f swordBase;\n} EnSwordsman; // size = 0x0368\n\n#endif\n\n// EnSwordsman.c\n#include \"z_en_swordsman.h\"\n#include \"assets/objects/object_sk2/object_sk2.h\"\n\n#define SWORDSMAN_HEALTH 8\n#define ATTACK_RANGE_SLASH 150.0f\n#define ATTACK_RANGE_THRUST 200.0f\n#define ATTACK_RANGE_SPIN 100.0f\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_HIT0,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 70, 0, { 0, 0, 0 } },\n};\n\nstatic ColliderQuadInit sQuadInit = {\n    {\n        COLTYPE_NONE,\n        AT_ON | AT_TYPE_ENEMY,\n        AC_NONE,\n        OC1_NONE,\n        OC2_NONE,\n        COLSHAPE_QUAD,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0xFFCFFFFF, 0x00, 0x08 },\n        { 0x00000000, 0x00, 0x00 },\n        TOUCH_ON | TOUCH_SFX_NORMAL,\n        BUMP_NONE,\n        OCELEM_NONE,\n    },\n    { { { 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 0.0f } } },\n};\n\nvoid EnSwordsman_Init(Actor* thisx, PlayState* play) {\n    EnSwordsman* this = (EnSwordsman*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    SkelAnime_InitFlex(play, &this->skelAnime, &gStalfosSkel, &gStalfosIdleAnim, this->jointTable, this->morphTable, 20);\n    \n    Collider_InitCylinder(play, &this->bodyCollider);\n    Collider_SetCylinderType1(play, &this->bodyCollider, &this->actor, &sCylinderInit);\n    \n    Collider_InitQuad(play, &this->swordCollider);\n    Collider_SetQuad(play, &this->swordCollider, &this->actor, &sQuadInit);\n    \n    this->actor.colChkInfo.health = SWORDSMAN_HEALTH;\n    this->actionState = SWORDSMAN_IDLE;\n    this->attackRange = ATTACK_RANGE_SLASH;\n    \n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 30.0f);\n    this->actor.targetMode = 3;\n}\n\nvoid EnSwordsman_Destroy(Actor* thisx, PlayState* play) {\n    EnSwordsman* this = (EnSwordsman*)thisx;\n    \n    Collider_DestroyCylinder(play, &this->bodyCollider);\n    Collider_DestroyQuad(play, &this->swordCollider);\n}\n\nvoid EnSwordsman_SetupSlash(EnSwordsman* this) {\n    Animation_Change(&this->skelAnime, &gStalfosSlashAnim, 1.0f, 0.0f,\n                    Animation_GetLastFrame(&gStalfosSlashAnim), ANIMMODE_ONCE, 0.0f);\n    this->actionState = SWORDSMAN_SLASH;\n    this->attackTimer = 20;\n}\n\nvoid EnSwordsman_UpdateSlash(EnSwordsman* this, PlayState* play) {\n    if (SkelAnime_Update(&this->skelAnime)) {\n        if (--this->attackTimer <= 0) {\n            this->actionState = SWORDSMAN_CHASE;\n        }\n    }\n    \n    // Update sword collider during slash frames\n    if (this->skelAnime.curFrame > 5 && this->skelAnime.curFrame < 12) {\n        CollisionCheck_SetAT(play, &play->colChkCtx, &this->swordCollider.base);\n    }\n}\n\nvoid EnSwordsman_Update(Actor* thisx, PlayState* play) {\n    EnSwordsman* this = (EnSwordsman*)thisx;\n    \n    if (this->damageTimer > 0) {\n        this->damageTimer--;\n    }\n    \n    // State machine\n    switch (this->actionState) {\n        case SWORDSMAN_IDLE:\n            if (Actor_WorldDistXZToActor(&this->actor, &GET_PLAYER(play)->actor) < 300.0f) {\n                this->actionState = SWORDSMAN_CHASE;\n            }\n            break;\n            \n        case SWORDSMAN_CHASE: {\n            f32 dist = Actor_WorldDistXZToActor(&this->actor, &GET_PLAYER(play)->actor);\n            \n            if (dist < ATTACK_RANGE_SPIN) {\n                EnSwordsman_SetupSlash(this);\n            } else if (dist < ATTACK_RANGE_THRUST) {\n                // Setup thrust attack\n                this->actionState = SWORDSMAN_THRUST;\n            }\n            \n            // Move toward player\n            Math_SmoothStepToS(&this->actor.shape.rot.y, \n                              Math_Vec3f_Yaw(&this->actor.world.pos, &GET_PLAYER(play)->actor.world.pos),\n                              3, 2000, 0);\n            this->actor.world.rot.y = this->actor.shape.rot.y;\n            this->actor.speedXZ = 6.0f;\n            break;\n        }\n        \n        case SWORDSMAN_SLASH:\n            EnSwordsman_UpdateSlash(this, play);\n            break;\n            \n        case SWORDSMAN_DAMAGED:\n            if (this->damageTimer <= 0) {\n                this->actionState = SWORDSMAN_CHASE;\n            }\n            break;\n    }\n    \n    // Update colliders\n    Collider_UpdateCylinder(&this->actor, &this->bodyCollider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->bodyCollider.base);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->bodyCollider.base);\n    \n    // Handle damage\n    if (this->bodyCollider.base.acFlags & AC_HIT) {\n        this->damageTimer = 10;\n        this->actionState = SWORDSMAN_DAMAGED;\n        Actor_SetColorFilter(&this->actor, COLORFILTER_COLORFLAG_RED, 255, COLORFILTER_BUFFLAG_OPA, 10);\n        \n        s16 damage = Actor_ApplyDamage(&this->actor);\n        if (damage <= 0) {\n            Enemy_StartFinishingBlow(play, &this->actor);\n            this->actionState = SWORDSMAN_DEATH;\n        }\n    }\n    \n    Actor_MoveXZGravity(&this->actor);\n}\n\nvoid EnSwordsman_Draw(Actor* thisx, PlayState* play) {\n    EnSwordsman* this = (EnSwordsman*)thisx;\n    \n    func_80093D18(play->state.gfxCtx);\n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable, this->skelAnime.dListCount, NULL, NULL,\n                         this);\n}\n```"}
{"instruction": "I need help creating a branching NPC dialogue system for my shopkeeper. I want him to track the player, have multiple conversation paths based on what items Link has, and show different text for child/adult. The shopkeeper should turn to face Link and respond differently if Link has a bottle vs not having one. Please provide complete code including proper actor setup and dialogue handling.", "output": "```c\n#include \"z_en_shop.h\"\n#include \"assets/objects/object_shop/object_shop.h\"\n\n#define FLAGS (ACTOR_FLAG_0 | ACTOR_FLAG_3)\n\ntypedef enum {\n    /* 0 */ SHOP_STATE_IDLE,\n    /* 1 */ SHOP_STATE_TALKING,\n    /* 2 */ SHOP_STATE_POST_TALK\n} ShopState;\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ ShopState actionState;\n    /* 0x0194 */ NpcInteractInfo interactInfo;\n    /* 0x01BC */ ColliderCylinder collider;\n    /* 0x0208 */ s16 dialogState;\n    /* 0x020A */ s16 blinkTimer;\n    /* 0x020C */ s16 eyeState;\n    /* 0x020E */ Vec3s jointTable[16];\n    /* 0x026E */ Vec3s morphTable[16];\n    /* 0x02CE */ f32 dialogRadius;\n} EnShop; // size = 0x02D2\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_NONE,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000000, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_NONE,\n        OCELEM_ON,\n    },\n    { 18, 63, 0, { 0, 0, 0 } },\n};\n\nstatic InitChainEntry sInitChain[] = {\n    ICHAIN_VEC3F_DIV1000(scale, 100, ICHAIN_CONTINUE),\n    ICHAIN_F32(uncullZoneForward, 1000, ICHAIN_CONTINUE),\n    ICHAIN_F32(uncullZoneScale, 100, ICHAIN_CONTINUE),\n    ICHAIN_F32(uncullZoneDownward, 1000, ICHAIN_STOP),\n};\n\nvoid EnShop_Init(Actor* thisx, PlayState* play) {\n    EnShop* this = (EnShop*)thisx;\n    \n    Actor_ProcessInitChain(&this->actor, sInitChain);\n    SkelAnime_InitFlex(play, &this->skelAnime, &gShopkeeperSkel, &gShopkeeperIdleAnim, \n                       this->jointTable, this->morphTable, 16);\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->dialogRadius = 100.0f;\n    this->actionState = SHOP_STATE_IDLE;\n    this->dialogState = TEXT_STATE_NONE;\n    this->actor.targetMode = 6;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\ns16 EnShop_GetTextId(Actor* thisx, PlayState* play) {\n    EnShop* this = (EnShop*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    if (LINK_IS_ADULT) {\n        if (Player_HasBottle(play)) {\n            return 0x1050; // \"Welcome! I see you have a bottle...\"\n        } else {\n            return 0x1051; // \"Welcome! You'll need a bottle...\"\n        }\n    } else {\n        return 0x1052; // \"Hello young one!\"\n    }\n}\n\nvoid EnShop_UpdateTalkState(Actor* thisx, PlayState* play) {\n    EnShop* this = (EnShop*)thisx;\n    \n    if (this->dialogState == TEXT_STATE_CLOSING) {\n        this->actionState = SHOP_STATE_POST_TALK;\n        this->dialogState = TEXT_STATE_NONE;\n    }\n}\n\nvoid EnShop_Update(Actor* thisx, PlayState* play) {\n    EnShop* this = (EnShop*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    this->interactInfo.trackPos = player->actor.world.pos;\n    this->interactInfo.yOffset = !LINK_IS_ADULT ? 10.0f : 0.0f;\n    \n    Npc_TrackPoint(&this->actor, &this->interactInfo, 15, \n                   NPC_TRACKING_HEAD_AND_TORSO);\n                   \n    if (this->actionState != SHOP_STATE_TALKING) {\n        Npc_UpdateTalking(play, &this->actor, &this->dialogState, \n                         this->dialogRadius, EnShop_GetTextId, \n                         EnShop_UpdateTalkState);\n        if (this->dialogState != TEXT_STATE_NONE) {\n            this->actionState = SHOP_STATE_TALKING;\n        }\n    }\n    \n    SkelAnime_Update(&this->skelAnime);\n}\n\nvoid EnShop_Draw(Actor* thisx, PlayState* play) {\n    EnShop* this = (EnShop*)thisx;\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                         this->skelAnime.dListCount, NULL, NULL, this);\n}\n\nvoid EnShop_Destroy(Actor* thisx, PlayState* play) {\n    EnShop* this = (EnShop*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nconst ActorProfile En_Shop_InitVars = {\n    ACTOR_EN_SHOP,\n    ACTORCAT_NPC,\n    FLAGS,\n    OBJECT_SHOP,\n    sizeof(EnShop),\n    (ActorFunc)EnShop_Init,\n    (ActorFunc)EnShop_Destroy,\n    (ActorFunc)EnShop_Update,\n    (ActorFunc)EnShop_Draw\n};\n```"}
