{
  "metadata": {
    "generated_at": "2025-07-05T13:06:45.749681",
    "generator_version": "Enhanced Phase 1",
    "total_examples": 5,
    "average_quality": 8.940000000000001,
    "authentic_patterns_used": true,
    "validation_applied": true
  },
  "examples": [
    {
      "type": "CODE_EXPLANATION",
      "instruction": "Explain what the function Actor_UpdateBgCheckInfo does in OoT",
      "input": null,
      "output": "Actor_UpdateBgCheckInfo is a core function in the OoT actor system that handles background collision checking for actors. Here's its authentic signature:\n\n```c\nvoid Actor_UpdateBgCheckInfo(PlayState* play, Actor* actor, f32 wallCheckHeight, f32 wallCheckRadius, f32 ceilingCheckHeight, s32 flags)\n```\n\n**Parameters:**\n- `PlayState* play` - The current game state context\n- `Actor* actor` - The actor to update collision for\n- `f32 wallCheckHeight` - Height to check for walls (typically 26.0f)\n- `f32 wallCheckRadius` - Radius around actor to check (typically 10.0f)  \n- `f32 ceilingCheckHeight` - How high to check for ceilings\n- `s32 flags` - Collision flags (BGCHECKFLAG_GROUND, BGCHECKFLAG_WALL, etc.)\n\n**What it does:**\n1. Performs collision checks against the background geometry\n2. Updates actor->floorHeight with the floor Y position below the actor\n3. Sets actor->floorPoly to the polygon the actor is standing on\n4. Updates actor->bgCheckFlags with collision state bits\n5. Handles wall collision detection and actor->wallPoly assignment\n\n**Common usage pattern:**\n```c\nvoid ActorName_Update(Actor* thisx, PlayState* play) {\n    ActorName* this = (ActorName*)thisx;\n    \n    // Standard collision checking for most actors\n    Actor_UpdateBgCheckInfo(play, &this->actor, 26.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n    \n    // Now you can safely check collision state\n    if (this->actor.bgCheckFlags & BGCHECKFLAG_GROUND) {\n        // Actor is on ground\n    }\n}\n```\n\nThis function is essential for any actor that needs to interact with the environment, preventing actors from falling through floors or walking through walls.",
      "quality_score": 8.5,
      "validation_notes": "Uses correct PlayState signature. Applied authentic pattern corrections. ",
      "metadata": {
        "authentic_patterns": [
          "PlayState* play",
          "Actor* actor",
          "BGCHECKFLAG_GROUND",
          "actor->floorHeight",
          "actor->bgCheckFlags"
        ],
        "function_accuracy": true,
        "uses_real_signatures": true
      }
    },
    {
      "type": "FEATURE_IMPLEMENTATION",
      "instruction": "Create a rupee actor that bounces when dropped and glows with a jingle",
      "input": null,
      "output": "Here's a complete bouncing rupee actor implementation using authentic OoT patterns:\n\n```c\n#include \"z_en_rupee_bounce.h\"\n#include \"overlays/actors/ovl_En_Item00/z_en_item00.h\"\n\n#define FLAGS (ACTOR_FLAG_ATTENTION_ENABLED | ACTOR_FLAG_FRIENDLY)\n\nvoid EnRupeeBounce_Init(Actor* thisx, PlayState* play);\nvoid EnRupeeBounce_Destroy(Actor* thisx, PlayState* play);\nvoid EnRupeeBounce_Update(Actor* thisx, PlayState* play);\nvoid EnRupeeBounce_Draw(Actor* thisx, PlayState* play);\n\nvoid EnRupeeBounce_Bounce(EnRupeeBounce* this, PlayState* play);\nvoid EnRupeeBounce_Collected(EnRupeeBounce* this, PlayState* play);\n\nActorProfile En_Rupee_Bounce_Profile = {\n    /**/ ACTOR_EN_RUPEE_BOUNCE,\n    /**/ ACTORCAT_MISC,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnRupeeBounce),\n    /**/ EnRupeeBounce_Init,\n    /**/ EnRupeeBounce_Destroy,\n    /**/ EnRupeeBounce_Update,\n    /**/ EnRupeeBounce_Draw,\n};\n\ntypedef struct EnRupeeBounce {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 bounceTimer;\n    /* 0x014E */ s16 glowPhase;\n    /* 0x0150 */ f32 bounceVelocity;\n    /* 0x0154 */ u8 rupeeValue; // 0=green, 1=blue, 2=red\n    /* 0x0155 */ u8 hasPlayedJingle;\n    /* 0x0156 */ s16 collectTimer;\n    /* 0x0158 */ ColliderCylinder collider;\n    /* 0x01A4 */ EnRupeeBounceActionFunc actionFunc;\n} EnRupeeBounce; // size = 0x01A8\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_NONE,\n        OC2_NONE,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_NONE,\n    },\n    { 8, 16, 0, { 0, 0, 0 } },\n};\n\nstatic InitChainEntry sInitChain[] = {\n    ICHAIN_VEC3F_DIV1000(scale, 15, ICHAIN_CONTINUE),\n    ICHAIN_F32(lockOnArrowOffset, 2000, ICHAIN_CONTINUE),\n    ICHAIN_F32(gravity, -1.2f, ICHAIN_CONTINUE),\n    ICHAIN_F32(minVelocityY, -20.0f, ICHAIN_STOP),\n};\n\nvoid EnRupeeBounce_Init(Actor* thisx, PlayState* play) {\n    EnRupeeBounce* this = (EnRupeeBounce*)thisx;\n    \n    Actor_ProcessInitChain(&this->actor, sInitChain);\n    \n    // Initialize collider\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    // Extract rupee type from params\n    this->rupeeValue = PARAMS_GET_S(this->actor.params, 0, 2);\n    this->bounceVelocity = 8.0f;\n    this->bounceTimer = 0;\n    this->glowPhase = 0;\n    this->hasPlayedJingle = false;\n    this->collectTimer = 0;\n    \n    // Set initial upward velocity for bounce\n    this->actor.velocity.y = this->bounceVelocity;\n    this->actor.velocity.x = Rand_CenteredFloat(4.0f);\n    this->actor.velocity.z = Rand_CenteredFloat(4.0f);\n    \n    // Start in bouncing state\n    this->actionFunc = EnRupeeBounce_Bounce;\n}\n\nvoid EnRupeeBounce_Bounce(EnRupeeBounce* this, PlayState* play) {\n    // Update collision\n    Actor_UpdateBgCheckInfo(play, &this->actor, 18.0f, 8.0f, 0.0f, BGCHECKFLAG_GROUND);\n    \n    // Check if hit ground\n    if ((this->actor.bgCheckFlags & BGCHECKFLAG_GROUND) && this->actor.velocity.y <= 0.0f) {\n        // Bounce!\n        this->bounceVelocity *= 0.7f; // Reduce bounce each time\n        \n        if (this->bounceVelocity > 2.0f) {\n            this->actor.velocity.y = this->bounceVelocity;\n            Audio_PlayActorSound2(&this->actor, NA_SE_EV_BOMB_BOUND);\n        } else {\n            // Stop bouncing, settle on ground\n            this->actor.velocity.y = 0.0f;\n            this->actor.velocity.x *= 0.8f;\n            this->actor.velocity.z *= 0.8f;\n            \n            if (!this->hasPlayedJingle) {\n                Audio_PlayActorSound2(&this->actor, NA_SE_SY_TRE_BOX_APPEAR);\n                this->hasPlayedJingle = true;\n            }\n        }\n    }\n    \n    // Glowing animation\n    this->glowPhase += 0x400;\n    \n    // Check for player collection\n    if (Actor_OfferGetItem(&this->actor, play, GI_RUPEE_GREEN + this->rupeeValue, 30.0f, 30.0f)) {\n        this->actionFunc = EnRupeeBounce_Collected;\n    }\n}\n\nvoid EnRupeeBounce_Collected(EnRupeeBounce* this, PlayState* play) {\n    if (Actor_HasParent(&this->actor, play)) {\n        Actor_Kill(&this->actor);\n    } else {\n        Actor_OfferGetItem(&this->actor, play, GI_RUPEE_GREEN + this->rupeeValue, 30.0f, 30.0f);\n    }\n}\n\nvoid EnRupeeBounce_Update(Actor* thisx, PlayState* play) {\n    EnRupeeBounce* this = (EnRupeeBounce*)thisx;\n    \n    // Update collider\n    Collider_Update(play, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Call current action\n    this->actionFunc(this, play);\n    \n    // Apply movement\n    Actor_MoveXZGravity(&this->actor);\n}\n\nvoid EnRupeeBounce_Draw(Actor* thisx, PlayState* play) {\n    EnRupeeBounce* this = (EnRupeeBounce*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx, \"../z_en_rupee_bounce.c\", 187);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    // Glowing effect\n    f32 glowIntensity = (Math_SinS(this->glowPhase) + 1.0f) * 0.5f;\n    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 255, 255, 200, (u8)(150 + glowIntensity * 105));\n    \n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_RotateY(BINANG_TO_RAD(this->actor.shape.rot.y), MTXMODE_APPLY);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, this->actor.scale.z, MTXMODE_APPLY);\n    \n    gSPMatrix(POLY_OPA_DISP++, MATRIX_NEWMTX(play->state.gfxCtx), G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n    gSPDisplayList(POLY_OPA_DISP++, gRupeeDL);\n    \n    CLOSE_DISPS(play->state.gfxCtx, \"../z_en_rupee_bounce.c\", 203);\n}\n```\n\nThis implementation demonstrates authentic OoT patterns:\n- Proper ActorProfile structure with correct categories\n- Authentic collision setup with ColliderCylinder\n- Real function signatures (PlayState* play, Actor* thisx)\n- Proper memory layout with exact field offsets\n- Action function pattern used throughout OoT\n- Authentic audio and effect calls\n- Real parameter extraction using PARAMS_GET_S",
      "quality_score": 9.2,
      "validation_notes": "Uses correct PlayState signature. Applied authentic pattern corrections. ",
      "metadata": {
        "authentic_patterns": [
          "ActorProfile",
          "ColliderCylinder",
          "Actor_UpdateBgCheckInfo",
          "PlayState* play",
          "ACTORCAT_MISC"
        ],
        "complete_implementation": true,
        "uses_real_structures": true
      }
    },
    {
      "type": "DEBUGGING_HELP",
      "instruction": "My NPC actor is crashing when Link gets close. Here's my code:",
      "input": "void MyNpc_Update(Actor* thisx, GlobalContext* globalCtx) {\n    MyNpc* this = (MyNpc*)thisx;\n    \n    Player* player = GET_PLAYER(globalCtx);\n    f32 dist = Math_Vec3f_DistXZ(&this->actor.pos, &player->actor.pos);\n    \n    if (dist < 100.0f) {\n        Actor_OfferTalk(&this->actor, globalCtx, 50.0f);\n    }\n}",
      "output": "I can see several issues in your code that are causing crashes. Here are the problems and authentic fixes:\n\n**Issue 1: Outdated Function Signature**\n```c\n// \u274c Old/incorrect signature\nvoid MyNpc_Update(Actor* thisx, GlobalContext* globalCtx)\n\n// \u2705 Authentic OoT signature\nvoid MyNpc_Update(Actor* thisx, PlayState* play)\n```\n\n**Issue 2: Incorrect Position Field Access**\n```c\n// \u274c Wrong field name\n&this->actor.pos\n\n// \u2705 Authentic field name from decompilation\n&this->actor.world.pos\n```\n\n**Issue 3: Missing Background Collision Check**\nYour actor isn't updating its collision info, which can cause crashes when the actor tries to interact with the world.\n\n**Here's the corrected, crash-free code:**\n\n```c\nvoid MyNpc_Update(Actor* thisx, PlayState* play) {\n    MyNpc* this = (MyNpc*)thisx;\n    \n    // CRITICAL: Update background collision info first\n    Actor_UpdateBgCheckInfo(play, &this->actor, 26.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n    \n    // Safe player distance check with authentic field names\n    Player* player = GET_PLAYER(play);\n    f32 dist = Math_Vec3f_DistXZ(&this->actor.world.pos, &player->actor.world.pos);\n    \n    if (dist < 100.0f) {\n        // Check if player is facing NPC before offering talk\n        if (Actor_IsFacingPlayer(&this->actor, 0x4000)) { // 90 degree range\n            if (Actor_OfferTalk(&this->actor, play, 50.0f)) {\n                this->actionFunc = MyNpc_Talk;\n            }\n        }\n    }\n    \n    // Update any colliders if you have them\n    if (this->collider.base.atFlags & AT_HIT) {\n        this->collider.base.atFlags &= ~AT_HIT;\n        // Handle collision\n    }\n}\n```\n\n**Additional Debugging Tips:**\n\n1. **Always validate your ActorProfile size:**\n```c\nActorProfile My_Npc_Profile = {\n    /**/ ACTOR_MY_NPC,\n    /**/ ACTORCAT_NPC,  // Correct category\n    /**/ FLAGS,\n    /**/ OBJECT_MY_NPC,\n    /**/ sizeof(MyNpc), // CRITICAL: Must match your struct size exactly\n    /**/ MyNpc_Init,\n    /**/ MyNpc_Destroy,\n    /**/ MyNpc_Update,\n    /**/ MyNpc_Draw,\n};\n```\n\n2. **Check object dependencies in Init:**\n```c\nvoid MyNpc_Init(Actor* thisx, PlayState* play) {\n    MyNpc* this = (MyNpc*)thisx;\n    \n    // Verify object is loaded before proceeding\n    s32 objBankIndex = Object_GetSlot(&play->objectCtx, OBJECT_MY_NPC);\n    if (objBankIndex < 0) {\n        Actor_Kill(&this->actor); // Object not loaded, can't continue\n        return;\n    }\n    \n    Actor_SetObjectDependency(play, &this->actor);\n    // ... rest of init\n}\n```\n\n3. **Always initialize colliders properly:**\n```c\n// In Init function\nCollider_InitCylinder(play, &this->collider);\nCollider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n```\n\nThese changes follow authentic OoT patterns and should eliminate your crashes.",
      "quality_score": 8.8,
      "validation_notes": "Uses correct PlayState signature. Applied authentic pattern corrections. ",
      "metadata": {
        "fixes_applied": [
          "GlobalContext->PlayState",
          "pos->world.pos",
          "Added collision checking"
        ],
        "crash_prevention": true,
        "authentic_debugging": true
      }
    },
    {
      "type": "ACTOR_CREATION",
      "instruction": "Create a complete simple enemy actor with collision detection and animation",
      "input": null,
      "output": "Here's a complete simple enemy actor implementation following authentic OoT patterns:\n\n```c\n#include \"z_en_simple_enemy.h\"\n\n#define FLAGS (ACTOR_FLAG_ATTENTION_ENABLED | ACTOR_FLAG_HOSTILE | ACTOR_FLAG_UPDATE_CULLING_DISABLED)\n\nvoid EnSimpleEnemy_Init(Actor* thisx, PlayState* play);\nvoid EnSimpleEnemy_Destroy(Actor* thisx, PlayState* play);\nvoid EnSimpleEnemy_Update(Actor* thisx, PlayState* play);\nvoid EnSimpleEnemy_Draw(Actor* thisx, PlayState* play);\n\nvoid EnSimpleEnemy_Idle(EnSimpleEnemy* this, PlayState* play);\nvoid EnSimpleEnemy_Chase(EnSimpleEnemy* this, PlayState* play);\nvoid EnSimpleEnemy_Attack(EnSimpleEnemy* this, PlayState* play);\nvoid EnSimpleEnemy_Stunned(EnSimpleEnemy* this, PlayState* play);\nvoid EnSimpleEnemy_Dead(EnSimpleEnemy* this, PlayState* play);\n\nActorProfile En_Simple_Enemy_Profile = {\n    /**/ ACTOR_EN_SIMPLE_ENEMY,\n    /**/ ACTORCAT_ENEMY,\n    /**/ FLAGS,\n    /**/ OBJECT_SIMPLE_ENEMY,\n    /**/ sizeof(EnSimpleEnemy),\n    /**/ EnSimpleEnemy_Init,\n    /**/ EnSimpleEnemy_Destroy,\n    /**/ EnSimpleEnemy_Update,\n    /**/ EnSimpleEnemy_Draw,\n};\n\ntypedef struct EnSimpleEnemy {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ Vec3s jointTable[SIMPLE_ENEMY_LIMB_MAX];\n    /* 0x01E4 */ Vec3s morphTable[SIMPLE_ENEMY_LIMB_MAX];\n    /* 0x0238 */ EnSimpleEnemyActionFunc actionFunc;\n    /* 0x023C */ s16 timer;\n    /* 0x023E */ s16 health;\n    /* 0x0240 */ s16 damageTimer;\n    /* 0x0242 */ s16 chaseTimer;\n    /* 0x0244 */ f32 targetYaw;\n    /* 0x0248 */ f32 moveSpeed;\n    /* 0x024C */ ColliderCylinder colliderBody;\n    /* 0x0298 */ ColliderJntSph colliderSphere;\n    /* 0x02B8 */ ColliderJntSphElement colliderSphereElement;\n} EnSimpleEnemy; // size = 0x02F8\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_HIT5,\n        AT_ON | AT_TYPE_ENEMY,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0xFFCFFFFF, HIT_BACKLASH_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_ON | ATELEM_SFX_NORMAL,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 16, 32, 0, { 0, 0, 0 } },\n};\n\nstatic ColliderJntSphElementInit sSphereElementInit = {\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_NONE,\n    },\n    { 0, { { 0, 0, 0 }, 12 }, 100 },\n};\n\nstatic ColliderJntSphInit sJntSphInit = {\n    {\n        COL_MATERIAL_HIT0,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_NONE,\n        OC2_NONE,\n        COLSHAPE_JNTSPH,\n    },\n    1,\n    (ColliderJntSphElement*)&sSphereElementInit,\n};\n\nstatic InitChainEntry sInitChain[] = {\n    ICHAIN_VEC3F_DIV1000(scale, 8, ICHAIN_CONTINUE),\n    ICHAIN_F32(lockOnArrowOffset, 35, ICHAIN_CONTINUE),\n    ICHAIN_S8(naviEnemyId, NAVI_ENEMY_DEFAULT, ICHAIN_CONTINUE),\n    ICHAIN_U8(targetMode, 2, ICHAIN_CONTINUE),\n    ICHAIN_F32(gravity, -3.5f, ICHAIN_CONTINUE),\n    ICHAIN_F32(minVelocityY, -15.0f, ICHAIN_STOP),\n};\n\nvoid EnSimpleEnemy_Init(Actor* thisx, PlayState* play) {\n    EnSimpleEnemy* this = (EnSimpleEnemy*)thisx;\n    s32 pad;\n    \n    Actor_ProcessInitChain(&this->actor, sInitChain);\n    \n    // Initialize skeleton and animation\n    SkelAnime_Init(play, &this->skelAnime, &gSimpleEnemySkel, &gSimpleEnemyIdleAnim, \n                   this->jointTable, this->morphTable, SIMPLE_ENEMY_LIMB_MAX);\n    \n    // Initialize colliders\n    Collider_InitCylinder(play, &this->colliderBody);\n    Collider_SetCylinder(play, &this->colliderBody, &this->actor, &sCylinderInit);\n    \n    Collider_InitJntSph(play, &this->colliderSphere);\n    Collider_SetJntSph(play, &this->colliderSphere, &this->actor, &sJntSphInit, \n                        &this->colliderSphereElement);\n    \n    // Set up actor properties\n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 25.0f);\n    Actor_SetScale(&this->actor, 0.008f);\n    \n    // Initialize enemy state\n    this->health = 3;\n    this->timer = 0;\n    this->damageTimer = 0;\n    this->chaseTimer = 0;\n    this->moveSpeed = 1.0f;\n    this->targetYaw = this->actor.world.rot.y;\n    \n    // Start in idle state\n    this->actionFunc = EnSimpleEnemy_Idle;\n}\n\nvoid EnSimpleEnemy_Idle(EnSimpleEnemy* this, PlayState* play) {\n    Player* player = GET_PLAYER(play);\n    f32 distToPlayer = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    // Look around randomly\n    if (this->timer <= 0) {\n        this->targetYaw = this->actor.world.rot.y + Rand_CenteredFloat(0x4000);\n        this->timer = Rand_ZeroFloat(60.0f) + 30.0f;\n    }\n    \n    Math_ApproachS(&this->actor.world.rot.y, this->targetYaw, 3, 0x200);\n    this->actor.shape.rot.y = this->actor.world.rot.y;\n    \n    // Start chasing if player gets close\n    if (distToPlayer < 150.0f) {\n        this->actionFunc = EnSimpleEnemy_Chase;\n        this->chaseTimer = 300; // 5 seconds\n        Animation_Change(&this->skelAnime, &gSimpleEnemyWalkAnim, 1.0f, 0.0f,\n                        Animation_GetLastFrame(&gSimpleEnemyWalkAnim), ANIMMODE_LOOP, -10.0f);\n    }\n}\n\nvoid EnSimpleEnemy_Chase(EnSimpleEnemy* this, PlayState* play) {\n    Player* player = GET_PLAYER(play);\n    f32 distToPlayer = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    // Face towards player\n    s16 yawToPlayer = Actor_WorldYawTowardActor(&this->actor, &player->actor);\n    Math_ApproachS(&this->actor.world.rot.y, yawToPlayer, 3, 0x400);\n    this->actor.shape.rot.y = this->actor.world.rot.y;\n    \n    // Move towards player\n    if (distToPlayer > 30.0f) {\n        this->actor.speed = this->moveSpeed;\n    } else {\n        this->actor.speed = 0.0f;\n        // Close enough to attack\n        this->actionFunc = EnSimpleEnemy_Attack;\n        Animation_Change(&this->skelAnime, &gSimpleEnemyAttackAnim, 1.0f, 0.0f,\n                        Animation_GetLastFrame(&gSimpleEnemyAttackAnim), ANIMMODE_ONCE, -5.0f);\n        return;\n    }\n    \n    // Give up chase if too far or timer expires\n    if (distToPlayer > 300.0f || --this->chaseTimer <= 0) {\n        this->actionFunc = EnSimpleEnemy_Idle;\n        this->actor.speed = 0.0f;\n        Animation_Change(&this->skelAnime, &gSimpleEnemyIdleAnim, 1.0f, 0.0f,\n                        Animation_GetLastFrame(&gSimpleEnemyIdleAnim), ANIMMODE_LOOP, -10.0f);\n    }\n}\n\nvoid EnSimpleEnemy_Attack(EnSimpleEnemy* this, PlayState* play) {\n    if (SkelAnime_Update(&this->skelAnime)) {\n        // Attack animation finished, return to chase\n        this->actionFunc = EnSimpleEnemy_Chase;\n        Animation_Change(&this->skelAnime, &gSimpleEnemyWalkAnim, 1.0f, 0.0f,\n                        Animation_GetLastFrame(&gSimpleEnemyWalkAnim), ANIMMODE_LOOP, -5.0f);\n    }\n}\n\nvoid EnSimpleEnemy_Update(Actor* thisx, PlayState* play) {\n    EnSimpleEnemy* this = (EnSimpleEnemy*)thisx;\n    \n    // Update background collision\n    Actor_UpdateBgCheckInfo(play, &this->actor, 26.0f, 15.0f, 0.0f, BGCHECKFLAG_GROUND | BGCHECKFLAG_WALL);\n    \n    // Update animation\n    SkelAnime_Update(&this->skelAnime);\n    \n    // Handle damage timer\n    if (this->damageTimer > 0) {\n        this->damageTimer--;\n    }\n    \n    // Update colliders\n    Collider_Update(play, &this->colliderBody);\n    Collider_Update(play, &this->colliderSphere);\n    \n    // Check for damage taken\n    if (this->colliderBody.base.acFlags & AC_HIT) {\n        this->colliderBody.base.acFlags &= ~AC_HIT;\n        \n        if (this->damageTimer == 0) {\n            this->health--;\n            this->damageTimer = 20;\n            \n            if (this->health <= 0) {\n                this->actionFunc = EnSimpleEnemy_Dead;\n                Animation_Change(&this->skelAnime, &gSimpleEnemyDeathAnim, 1.0f, 0.0f,\n                                Animation_GetLastFrame(&gSimpleEnemyDeathAnim), ANIMMODE_ONCE, -5.0f);\n            } else {\n                // Knockback\n                this->actor.speed = -5.0f;\n                Actor_PlaySfx(&this->actor, NA_SE_EN_GOMA_JR_FREEZE);\n            }\n        }\n    }\n    \n    // Set collision\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->colliderBody.base);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->colliderBody.base);\n    \n    if (this->actionFunc != EnSimpleEnemy_Dead) {\n        CollisionCheck_SetAT(play, &play->colChkCtx, &this->colliderSphere.base);\n    }\n    \n    // Call current action\n    this->actionFunc(this, play);\n    \n    // Apply movement\n    Actor_MoveXZGravity(&this->actor);\n    \n    // Update timers\n    if (this->timer > 0) {\n        this->timer--;\n    }\n}\n\nvoid EnSimpleEnemy_Draw(Actor* thisx, PlayState* play) {\n    EnSimpleEnemy* this = (EnSimpleEnemy*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx, \"../z_en_simple_enemy.c\", 312);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    // Damage flash effect\n    if (this->damageTimer > 0 && (this->damageTimer & 1)) {\n        POLY_OPA_DISP = Gfx_SetFog(POLY_OPA_DISP, 255, 0, 0, 255, 900, 1099);\n    }\n    \n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                          this->skelAnime.dListCount, NULL, NULL, this);\n    \n    CLOSE_DISPS(play->state.gfxCtx, \"../z_en_simple_enemy.c\", 324);\n}\n```\n\nThis implementation demonstrates all key authentic OoT enemy patterns:\n- Complete state machine with action functions\n- Proper collision setup for both damage and environmental collision\n- Authentic animation system integration\n- Real enemy behavior patterns (idle, chase, attack)\n- Proper damage handling and visual feedback\n- Correct memory layout and sizing",
      "quality_score": 9.5,
      "validation_notes": "Uses correct PlayState signature. Applied authentic pattern corrections. ",
      "metadata": {
        "complete_actor": true,
        "authentic_patterns": [
          "ActionFunc",
          "SkelAnime",
          "ColliderCylinder",
          "ColliderJntSph",
          "Actor_UpdateBgCheckInfo"
        ],
        "state_machine": true,
        "collision_system": true
      }
    },
    {
      "type": "FUNCTION_USAGE",
      "instruction": "Show me how to use Math_ApproachF for smooth movement in OoT",
      "input": null,
      "output": "Math_ApproachF is a fundamental function in OoT for smooth interpolation between values. Here's how to use it effectively:\n\n**Authentic Function Signature:**\n```c\ns32 Math_ApproachF(f32* pValue, f32 target, f32 scale, f32 maxStep)\n```\n\n**Parameters:**\n- `f32* pValue` - Pointer to the value being modified\n- `f32 target` - Target value to approach\n- `f32 scale` - Scale factor (0.0-1.0, higher = faster approach)\n- `f32 maxStep` - Maximum change per frame (prevents overshooting)\n\n**Return Value:**\nReturns 1 when target is reached, 0 otherwise.\n\n**Common Usage Patterns:**\n\n**1. Smooth Actor Movement:**\n```c\nvoid ActorName_Update(Actor* thisx, PlayState* play) {\n    ActorName* this = (ActorName*)thisx;\n    \n    // Smooth approach to target position\n    Math_ApproachF(&this->actor.world.pos.x, this->targetPos.x, 0.1f, 2.0f);\n    Math_ApproachF(&this->actor.world.pos.y, this->targetPos.y, 0.1f, 2.0f);\n    Math_ApproachF(&this->actor.world.pos.z, this->targetPos.z, 0.1f, 2.0f);\n}\n```\n\n**2. Smooth Speed Changes:**\n```c\n// Gradually increase speed to maximum\nif (Math_ApproachF(&this->actor.speed, this->maxSpeed, 0.2f, 0.5f)) {\n    // Reached max speed\n}\n\n// Gradually stop\nMath_ApproachF(&this->actor.speed, 0.0f, 0.8f, 1.0f);\n```\n\n**3. Camera-like Smooth Following:**\n```c\nvoid FollowPlayer(ActorName* this, PlayState* play) {\n    Player* player = GET_PLAYER(play);\n    Vec3f targetPos;\n    \n    // Calculate follow position behind player\n    targetPos.x = player->actor.world.pos.x - Math_SinS(player->actor.shape.rot.y) * 100.0f;\n    targetPos.y = player->actor.world.pos.y + 50.0f;\n    targetPos.z = player->actor.world.pos.z - Math_CosS(player->actor.shape.rot.y) * 100.0f;\n    \n    // Smooth camera-like following\n    Math_ApproachF(&this->actor.world.pos.x, targetPos.x, 0.05f, 3.0f);\n    Math_ApproachF(&this->actor.world.pos.y, targetPos.y, 0.1f, 2.0f);\n    Math_ApproachF(&this->actor.world.pos.z, targetPos.z, 0.05f, 3.0f);\n}\n```\n\n**4. Smooth Scale Animation:**\n```c\n// Grow effect\nif (this->isGrowing) {\n    if (Math_ApproachF(&this->currentScale, 0.02f, 0.15f, 0.002f)) {\n        this->isGrowing = false; // Finished growing\n    }\n    Actor_SetScale(&this->actor, this->currentScale);\n}\n\n// Shrink and destroy\nif (this->isShrinking) {\n    if (Math_ApproachF(&this->currentScale, 0.0f, 0.2f, 0.001f)) {\n        Actor_Kill(&this->actor); // Completely shrunk\n    }\n    Actor_SetScale(&this->actor, this->currentScale);\n}\n```\n\n**5. Smooth Color Transitions:**\n```c\n// Fade between colors smoothly\nMath_ApproachF(&this->currentColor.r, this->targetColor.r, 0.1f, 5.0f);\nMath_ApproachF(&this->currentColor.g, this->targetColor.g, 0.1f, 5.0f);\nMath_ApproachF(&this->currentColor.b, this->targetColor.b, 0.1f, 5.0f);\n```\n\n**6. Advanced: Eased Movement with Different Phases:**\n```c\nvoid SmoothApproach_MultiPhase(ActorName* this) {\n    f32 distance = fabsf(this->targetValue - this->currentValue);\n    \n    if (distance > 50.0f) {\n        // Far away - fast approach\n        Math_ApproachF(&this->currentValue, this->targetValue, 0.2f, 8.0f);\n    } else if (distance > 10.0f) {\n        // Medium distance - medium speed\n        Math_ApproachF(&this->currentValue, this->targetValue, 0.1f, 3.0f);\n    } else {\n        // Close - very precise, slow approach\n        Math_ApproachF(&this->currentValue, this->targetValue, 0.05f, 0.5f);\n    }\n}\n```\n\n**Performance Tips:**\n- Use appropriate scale values (0.05-0.2 typical range)\n- Set maxStep to prevent large jumps between frames\n- For very precise control, use smaller scale and maxStep values\n- Return value helps detect when movement is complete for state changes\n\n**Common Scale/MaxStep Combinations:**\n- **Fast approach**: scale=0.3f, maxStep=5.0f\n- **Medium smooth**: scale=0.1f, maxStep=2.0f  \n- **Slow precise**: scale=0.05f, maxStep=0.5f\n- **Camera-like**: scale=0.02f, maxStep=1.0f\n\nThis function is used extensively throughout OoT for smooth, natural-feeling movements and transitions.",
      "quality_score": 8.7,
      "validation_notes": "Uses correct PlayState signature. Applied authentic pattern corrections. ",
      "metadata": {
        "function_focus": "Math_ApproachF",
        "usage_patterns": 6,
        "authentic_examples": true,
        "performance_tips": true
      }
    }
  ]
}