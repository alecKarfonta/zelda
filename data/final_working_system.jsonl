{"instruction": "I need help creating a moving platform for the Forest Temple - specifically one that moves up and down between two positions when a switch is activated. I want it to move smoothly like the existing platforms in the temple. Could you provide the complete actor code including collision and switch handling?", "output": "```c\n#include \"z_bg_forest_lift.h\"\n#include \"assets/objects/object_forest_objects/object_forest_objects.h\"\n\n#define FLAGS (ACTOR_FLAG_4 | ACTOR_FLAG_5)\n#define MOVE_SPEED 3.0f\n#define PLATFORM_HEIGHT 100.0f\n\ntypedef enum {\n    /* 0 */ LIFT_WAIT,\n    /* 1 */ LIFT_MOVE_UP,\n    /* 2 */ LIFT_MOVE_DOWN\n} ForestLiftState;\n\ntypedef struct {\n    /* 0x0000 */ DynaPolyActor dyna;\n    /* 0x0164 */ s16 moveState;\n    /* 0x0166 */ s16 timer;\n    /* 0x0168 */ f32 initialY;\n    /* 0x016C */ f32 targetY;\n    /* 0x0170 */ ColliderJntSph collider;\n    /* 0x0190 */ ColliderJntSphElement colliderElements[1];\n} BgForestLift; // size = 0x01D0\n\nvoid BgForestLift_Init(Actor* thisx, PlayState* play);\nvoid BgForestLift_Destroy(Actor* thisx, PlayState* play);\nvoid BgForestLift_Update(Actor* thisx, PlayState* play);\nvoid BgForestLift_Draw(Actor* thisx, PlayState* play);\n\nconst ActorProfile Bg_Forest_Lift_InitVars = {\n    ACTOR_BG_FOREST_LIFT,\n    ACTORCAT_BG,\n    FLAGS,\n    OBJECT_FOREST_OBJECTS,\n    sizeof(BgForestLift),\n    (ActorFunc)BgForestLift_Init,\n    (ActorFunc)BgForestLift_Destroy,\n    (ActorFunc)BgForestLift_Update,\n    (ActorFunc)BgForestLift_Draw\n};\n\nvoid BgForestLift_Init(Actor* thisx, PlayState* play) {\n    BgForestLift* this = (BgForestLift*)thisx;\n    CollisionHeader* colHeader = NULL;\n    \n    Actor_ProcessInitChain(&this->dyna.actor, sInitChain);\n    DynaPolyActor_Init(&this->dyna, DPM_UNK);\n    CollisionHeader_GetVirtual(&gForestLiftCol, &colHeader);\n    this->dyna.bgId = DynaPoly_SetBgActor(play, &play->colCtx.dyna, &this->dyna.actor, colHeader);\n    \n    this->initialY = this->dyna.actor.world.pos.y;\n    this->targetY = this->initialY;\n    this->moveState = LIFT_WAIT;\n    \n    // Setup collision\n    Collider_InitJntSph(play, &this->collider);\n    Collider_SetJntSph(play, &this->collider, &this->dyna.actor, &sJntSphInit, this->colliderElements);\n    \n    Actor_SetScale(&this->dyna.actor, 0.1f);\n}\n\nvoid BgForestLift_Destroy(Actor* thisx, PlayState* play) {\n    BgForestLift* this = (BgForestLift*)thisx;\n    DynaPoly_DeleteBgActor(play, &play->colCtx.dyna, this->dyna.bgId);\n    Collider_DestroyJntSph(play, &this->collider);\n}\n\nvoid BgForestLift_Update(Actor* thisx, PlayState* play) {\n    BgForestLift* this = (BgForestLift*)thisx;\n    \n    // Check switch state (params & 0x3F = switch flag)\n    if (Flags_GetSwitch(play, this->dyna.actor.params & 0x3F)) {\n        if (this->moveState == LIFT_WAIT) {\n            this->moveState = LIFT_MOVE_UP;\n            this->targetY = this->initialY + PLATFORM_HEIGHT;\n            Actor_PlaySfx(&this->dyna.actor, NA_SE_EV_ELEVATOR_START);\n        }\n    } else {\n        if (this->moveState != LIFT_WAIT) {\n            this->moveState = LIFT_MOVE_DOWN;\n            this->targetY = this->initialY;\n        }\n    }\n    \n    // Handle movement\n    switch (this->moveState) {\n        case LIFT_MOVE_UP:\n        case LIFT_MOVE_DOWN:\n            if (Math_StepToF(&this->dyna.actor.world.pos.y, this->targetY, MOVE_SPEED)) {\n                this->moveState = LIFT_WAIT;\n                Actor_PlaySfx(&this->dyna.actor, NA_SE_EV_ELEVATOR_STOP);\n            } else {\n                Actor_PlaySfx(&this->dyna.actor, NA_SE_EV_ELEVATOR_MOVE - SFX_FLAG);\n            }\n            break;\n    }\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->dyna.actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid BgForestLift_Draw(Actor* thisx, PlayState* play) {\n    Gfx_DrawDListOpa(play, gForestLiftDL);\n}\n```"}
{"instruction": "I want to create a door that opens when Zelda's Lullaby is played nearby, like the ones in the Temple of Time. It should have a good activation radius and smooth opening animation. Can you help me write the full actor code for this?", "output": "```c\n#include \"z_obj_song_door.h\"\n#include \"assets/objects/gameplay_keep/gameplay_keep.h\"\n#include \"vt.h\"\n\n#define FLAGS (ACTOR_FLAG_4 | ACTOR_FLAG_25)\n#define ACTIVATION_RADIUS 200.0f\n\ntypedef enum {\n    /* 0 */ SONGDOOR_WAIT,\n    /* 1 */ SONGDOOR_OPENING,\n    /* 2 */ SONGDOOR_OPENED\n} SongDoorState;\n\ntypedef struct {\n    /* 0x0000 */ DynaPolyActor dyna;\n    /* 0x0164 */ s16 doorState;\n    /* 0x0166 */ s16 openTimer;\n    /* 0x0168 */ f32 openAngle;\n    /* 0x016C */ Vec3f effectPos;\n    /* 0x0178 */ LightNode* lightNode;\n    /* 0x017C */ LightInfo lightInfo;\n} ObjSongDoor; // size = 0x018C\n\nvoid ObjSongDoor_Init(Actor* thisx, PlayState* play) {\n    ObjSongDoor* this = (ObjSongDoor*)thisx;\n    CollisionHeader* colHeader = NULL;\n    \n    Actor_ProcessInitChain(&this->dyna.actor, sInitChain);\n    DynaPolyActor_Init(&this->dyna, DPM_UNK);\n    CollisionHeader_GetVirtual(&gSongDoorCol, &colHeader);\n    this->dyna.bgId = DynaPoly_SetBgActor(play, &play->colCtx.dyna, &this->dyna.actor, colHeader);\n    \n    this->doorState = SONGDOOR_WAIT;\n    this->openAngle = 0.0f;\n    Actor_SetScale(&this->dyna.actor, 0.1f);\n    \n    this->lightNode = LightContext_InsertLight(play, &play->lightCtx, &this->lightInfo);\n    Lights_PointNoGlowSetInfo(&this->lightInfo, this->dyna.actor.world.pos.x, \n        this->dyna.actor.world.pos.y + 80.0f, this->dyna.actor.world.pos.z, 255, 255, 255, 200);\n}\n\nvoid ObjSongDoor_Destroy(Actor* thisx, PlayState* play) {\n    ObjSongDoor* this = (ObjSongDoor*)thisx;\n    DynaPoly_DeleteBgActor(play, &play->colCtx.dyna, this->dyna.bgId);\n    LightContext_RemoveLight(play, &play->lightCtx, this->lightNode);\n}\n\nvoid ObjSongDoor_Update(Actor* thisx, PlayState* play) {\n    ObjSongDoor* this = (ObjSongDoor*)thisx;\n    Player* player = GET_PLAYER(play);\n    f32 dist;\n    \n    if (this->doorState == SONGDOOR_WAIT) {\n        dist = Math_Vec3f_DistXZ(&this->dyna.actor.world.pos, &player->actor.world.pos);\n        \n        if (dist < ACTIVATION_RADIUS && play->msgCtx.ocarinaMode == OCARINA_MODE_04) {\n            if (play->msgCtx.lastPlayedSong == OCARINA_SONG_LULLABY) {\n                this->doorState = SONGDOOR_OPENING;\n                Actor_PlaySfx(&this->dyna.actor, NA_SE_EV_STONE_STATUE_OPEN);\n                \n                // Spawn light effect\n                this->effectPos.x = this->dyna.actor.world.pos.x;\n                this->effectPos.y = this->dyna.actor.world.pos.y + 80.0f;\n                this->effectPos.z = this->dyna.actor.world.pos.z;\n                EffectSsKiraKira_SpawnSmall(play, &this->effectPos, &velocity_zero, &accel_zero, 255, 10);\n            }\n        }\n    }\n    \n    switch (this->doorState) {\n        case SONGDOOR_OPENING:\n            Math_ApproachF(&this->openAngle, M_PI / 2, 0.1f, 0.05f);\n            this->dyna.actor.world.rot.y = this->dyna.actor.home.rot.y + \n                (s16)(this->openAngle * (32768.0f / M_PI));\n            \n            if (this->openAngle >= M_PI / 2 - 0.01f) {\n                this->doorState = SONGDOOR_OPENED;\n                Actor_PlaySfx(&this->dyna.actor, NA_SE_EV_STONE_BOUND);\n            }\n            break;\n            \n        case SONGDOOR_OPENED:\n            break;\n    }\n}\n\nvoid ObjSongDoor_Draw(Actor* thisx, PlayState* play) {\n    ObjSongDoor* this = (ObjSongDoor*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx, \"obj_song_door_draw\");\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, \"obj_song_door_draw\"),\n        G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n    gSPDisplayList(POLY_OPA_DISP++, gSongDoorDL);\n    \n    CLOSE_DISPS(play->state.gfxCtx, \"obj_song_door_draw\");\n}\n\nconst ActorProfile Obj_Song_Door_InitVars = {\n    ACTOR_OBJ_SONG_DOOR,\n    ACTORCAT_BG,\n    FLAGS,\n    OBJECT_GAMEPLAY_KEEP,\n    sizeof(ObjSongDoor),\n    (ActorFunc)ObjSongDoor_Init,\n    (ActorFunc)ObjSongDoor_Destroy,\n    (ActorFunc)ObjSongDoor_Update,\n    (ActorFunc)ObjSongDoor_Draw\n};\n```"}
{"instruction": "I'm creating a Water Temple water level mechanism similar to vanilla OoT. Need an object that raises/lowers water when Link plays Zelda's Lullaby at specific spots. Should track global water level state and trigger water plane actors. Please provide the full actor code with proper collision detection and state management.", "output": "// WaterController.h\n#ifndef WATER_CONTROLLER_H\n#define WATER_CONTROLLER_H\n\n#include \"ultra64.h\"\n#include \"global.h\"\n\ntypedef enum {\n    /* 0x00 */ WATER_LEVEL_LOW,\n    /* 0x01 */ WATER_LEVEL_MID,\n    /* 0x02 */ WATER_LEVEL_HIGH\n} WaterLevel;\n\ntypedef struct {\n    /* 0x0000 */ DynaPolyActor dyna;\n    /* 0x0164 */ s16 waterLevel;\n    /* 0x0166 */ s16 triggerTimer;\n    /* 0x0168 */ f32 targetY;\n    /* 0x016C */ f32 currentY;\n    /* 0x0170 */ ColliderCylinder collider;\n    /* 0x01BC */ u8 isTriggerable;\n    /* 0x01BD */ u8 switchFlag;\n} WaterControllerActor; // size = 0x01C0\n\n#endif\n\n// WaterController.c\n#include \"WaterController.h\"\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000010, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 50, 80, 0, { 0, 0, 0 } }\n};\n\nvoid WaterController_Init(Actor* thisx, PlayState* play) {\n    WaterControllerActor* this = (WaterControllerActor*)thisx;\n    \n    Actor_ProcessInitChain(&this->dyna.actor, sInitChain);\n    Actor_SetScale(&this->dyna.actor, 0.1f);\n    \n    this->waterLevel = (this->dyna.actor.params >> 8) & 0xFF;\n    this->switchFlag = this->dyna.actor.params & 0xFF;\n    this->isTriggerable = true;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->dyna.actor, &sCylinderInit);\n    \n    // Set initial water height based on level\n    switch(this->waterLevel) {\n        case WATER_LEVEL_LOW:\n            this->targetY = -280.0f;\n            break;\n        case WATER_LEVEL_MID:\n            this->targetY = 0.0f;\n            break;\n        case WATER_LEVEL_HIGH:\n            this->targetY = 280.0f;\n            break;\n    }\n    \n    this->currentY = this->targetY;\n}\n\nvoid WaterController_Destroy(Actor* thisx, PlayState* play) {\n    WaterControllerActor* this = (WaterControllerActor*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid WaterController_Update(Actor* thisx, PlayState* play) {\n    WaterControllerActor* this = (WaterControllerActor*)thisx;\n    \n    if (this->triggerTimer > 0) {\n        this->triggerTimer--;\n        if (this->triggerTimer == 0) {\n            this->isTriggerable = true;\n        }\n    }\n    \n    // Check for Zelda's Lullaby activation\n    if (this->isTriggerable && \n        (this->collider.base.acFlags & AC_HIT) && \n        (play->msgCtx.ocarinaMode == OCARINA_MODE_04)) {\n        \n        this->collider.base.acFlags &= ~AC_HIT;\n        this->isTriggerable = false;\n        this->triggerTimer = 100;\n        \n        // Toggle water level and set new target\n        Flags_SetSwitch(play, this->switchFlag);\n        Actor_PlaySfx(&this->dyna.actor, NA_SE_EV_WATER_LEVEL_DOWN);\n        \n        // Broadcast water level change to all water planes\n        play->roomCtx.unk_74[0] = ((this->waterLevel + 1) % 3) * 1000;\n    }\n    \n    // Update water height\n    Math_ApproachF(&this->currentY, this->targetY, 0.1f, 2.0f);\n    \n    // Update collision detection\n    Collider_UpdateCylinder(&this->dyna.actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid WaterController_Draw(Actor* thisx, PlayState* play) {\n    WaterControllerActor* this = (WaterControllerActor*)thisx;\n    \n    // Draw trigger area indicator (only visible with debug flags)\n    if (play->debugFlags & 1) {\n        Gfx_DrawDListOpa(play, gDebugCylinderDL);\n    }\n}\n\nconst ActorProfile Water_Controller_InitVars = {\n    ACTOR_WATER_CONTROLLER,\n    ACTORCAT_BG,\n    FLAGS_NONE,\n    OBJECT_GAMEPLAY_KEEP,\n    sizeof(WaterControllerActor),\n    (ActorFunc)WaterController_Init,\n    (ActorFunc)WaterController_Destroy,\n    (ActorFunc)WaterController_Update,\n    (ActorFunc)WaterController_Draw\n};\n"}
{"instruction": "I need a special pressure switch that activates hidden passages based on checking for items in Link's inventory (like if Link has bow & arrows). Should check for multiple items and use the switch flag system to open passages. Please include initialization, collision, and documentation for integrating with door actors.", "output": "```c\n#include \"z_obj_switch.h\"\n#include \"assets/objects/object_d_switch/object_d_switch.h\"\n\ntypedef enum {\n    /* 0x00 */ ITEM_SWITCH_IDLE,\n    /* 0x01 */ ITEM_SWITCH_PRESSED,\n    /* 0x02 */ ITEM_SWITCH_ACTIVATED\n} ItemSwitchState;\n\ntypedef struct {\n    /* 0x0000 */ DynaPolyActor dyna;\n    /* 0x0164 */ s16 switchState;\n    /* 0x0166 */ s16 pressTimer;\n    /* 0x0168 */ f32 yOffset;\n    /* 0x016C */ ColliderCylinder collider;\n    /* 0x01B8 */ u8 requiredItems[3]; // Up to 3 required items\n    /* 0x01BB */ u8 itemCount;\n} ObjItemSwitch; // size = 0x01BC\n\n/**\n * Item Switch params:\n * (params >> 8) & 0xFF  = Switch Flag to set\n * (params >> 0) & 0xFF  = First required item\n * (params >> 16) & 0xFF = Second required item (optional)\n * (params >> 24) & 0xFF = Third required item (optional)\n */\nvoid ObjItemSwitch_Init(Actor* thisx, PlayState* play) {\n    ObjItemSwitch* this = (ObjItemSwitch*)thisx;\n    CollisionHeader* colHeader = NULL;\n    \n    Actor_ProcessInitChain(&this->dyna.actor, sInitChain);\n    DynaPolyActor_Init(&this->dyna, DPM_UNK);\n    CollisionHeader_GetVirtual(&gSwitchCol, &colHeader);\n    this->dyna.bgId = DynaPoly_SetBgActor(play, &play->colCtx.dyna, &this->dyna.actor, colHeader);\n    \n    // Setup collision cylinder\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->dyna.actor, &sCylinderInit);\n    \n    // Extract required items from params\n    this->requiredItems[0] = this->dyna.actor.params & 0xFF;\n    this->requiredItems[1] = (this->dyna.actor.params >> 16) & 0xFF;\n    this->requiredItems[2] = (this->dyna.actor.params >> 24) & 0xFF;\n    this->itemCount = 1;\n    \n    if (this->requiredItems[1] != 0) this->itemCount++;\n    if (this->requiredItems[2] != 0) this->itemCount++;\n    \n    this->switchState = ITEM_SWITCH_IDLE;\n    Actor_SetScale(&this->dyna.actor, 0.1f);\n}\n\nvoid ObjItemSwitch_Destroy(Actor* thisx, PlayState* play) {\n    ObjItemSwitch* this = (ObjItemSwitch*)thisx;\n    DynaPoly_DeleteBgActor(play, &play->colCtx.dyna, this->dyna.bgId);\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\ns32 ObjItemSwitch_CheckItems(ObjItemSwitch* this, PlayState* play) {\n    Player* player = GET_PLAYER(play);\n    s32 i;\n    s32 hasAllItems = true;\n    \n    for (i = 0; i < this->itemCount; i++) {\n        if (!INV_CONTENT(ITEM_SLOT_BOW + this->requiredItems[i])) {\n            hasAllItems = false;\n            break;\n        }\n    }\n    \n    return hasAllItems;\n}\n\nvoid ObjItemSwitch_Update(Actor* thisx, PlayState* play) {\n    ObjItemSwitch* this = (ObjItemSwitch*)thisx;\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        this->collider.base.acFlags &= ~AC_HIT;\n        \n        // Only activate if player has required items\n        if (ObjItemSwitch_CheckItems(this, play)) {\n            this->switchState = ITEM_SWITCH_PRESSED;\n            this->pressTimer = 20;\n            Actor_PlaySfx(&this->dyna.actor, NA_SE_SY_CORRECT_CHIME);\n        } else {\n            Actor_PlaySfx(&this->dyna.actor, NA_SE_SY_ERROR);\n        }\n    }\n    \n    switch (this->switchState) {\n        case ITEM_SWITCH_IDLE:\n            Math_ApproachF(&this->yOffset, 0.0f, 0.3f, 1.0f);\n            break;\n            \n        case ITEM_SWITCH_PRESSED:\n            Math_ApproachF(&this->yOffset, -5.0f, 0.3f, 1.0f);\n            if (--this->pressTimer <= 0) {\n                this->switchState = ITEM_SWITCH_ACTIVATED;\n                Flags_SetSwitch(play, (this->dyna.actor.params >> 8) & 0xFF);\n                Actor_PlaySfx(&this->dyna.actor, NA_SE_SY_SWITCH_ON);\n            }\n            break;\n            \n        case ITEM_SWITCH_ACTIVATED:\n            Math_ApproachF(&this->yOffset, -5.0f, 0.3f, 1.0f);\n            break;\n    }\n    \n    this->dyna.actor.world.pos.y = this->dyna.actor.home.pos.y + this->yOffset;\n    \n    Collider_UpdateCylinder(&this->dyna.actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile Obj_ItemSwitch_InitVars = {\n    ACTOR_OBJ_ITEM_SWITCH,\n    ACTORCAT_SWITCH,\n    FLAGS,\n    OBJECT_D_SWITCH,\n    sizeof(ObjItemSwitch),\n    (ActorFunc)ObjItemSwitch_Init,\n    (ActorFunc)ObjItemSwitch_Destroy,\n    (ActorFunc)ObjItemSwitch_Update,\n    NULL\n};\n```"}
{"instruction": "I want to create a Stalfos-like enemy that patrols between points and attacks the player with a sword. It should have proper collision detection, health management, and different attack patterns based on player distance. Can you help me implement this with proper OoT-style code organization?", "output": "```c\n#include \"z_en_stalfo.h\"\n#include \"assets/objects/object_sk/object_sk.h\"\n#include \"overlays/effects/ovl_Effect_Ss_Dead_Sound/z_eff_ss_dead_sound.h\"\n\n#define STALFO_HEALTH 4\n#define PATROL_RADIUS 200.0f\n#define CHASE_RANGE 300.0f\n#define ATTACK_RANGE 60.0f\n\nenum StalfoState {\n    /* 0 */ STALFO_IDLE,\n    /* 1 */ STALFO_PATROL,\n    /* 2 */ STALFO_CHASE,\n    /* 3 */ STALFO_ATTACK,\n    /* 4 */ STALFO_DAMAGED,\n    /* 5 */ STALFO_DEATH\n};\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ s16 health;\n    /* 0x0152 */ s16 invincibilityTimer;\n    /* 0x0154 */ f32 attackRange;\n    /* 0x0158 */ Vec3f homePos;\n    /* 0x0164 */ Vec3f targetPos;\n    /* 0x0170 */ SkelAnime skelAnime;\n    /* 0x01B4 */ ColliderCylinder bodyCollider;\n    /* 0x0200 */ ColliderQuad swordCollider;\n} EnStalfo; // size = 0x0250\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_HIT0,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 70, 0, { 0, 0, 0 } },\n};\n\nvoid EnStalfo_Init(Actor* thisx, PlayState* play) {\n    EnStalfo* this = (EnStalfo*)thisx;\n    \n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 30.0f);\n    SkelAnime_InitFlex(play, &this->skelAnime, &gStalfosSkel, &gStalfosIdleAnim, NULL, NULL, 0);\n    \n    Collider_InitCylinder(play, &this->bodyCollider);\n    Collider_SetCylinder(play, &this->bodyCollider, &this->actor, &sCylinderInit);\n    \n    this->actor.colChkInfo.health = STALFO_HEALTH;\n    this->actor.colChkInfo.mass = MASS_HEAVY;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    \n    this->actionState = STALFO_IDLE;\n    this->health = this->actor.colChkInfo.health;\n    Math_Vec3f_Copy(&this->homePos, &this->actor.world.pos);\n    \n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 30.0f);\n    this->actor.targetMode = 3;\n    this->actor.flags |= ACTOR_FLAG_0;\n    this->actor.enemyFlags = ENEMY_FLAG_VISIBLE;\n}\n\nvoid EnStalfo_Destroy(Actor* thisx, PlayState* play) {\n    EnStalfo* this = (EnStalfo*)thisx;\n    Collider_DestroyCylinder(play, &this->bodyCollider);\n    Collider_DestroyQuad(play, &this->swordCollider);\n}\n\nvoid EnStalfo_Update(Actor* thisx, PlayState* play) {\n    EnStalfo* this = (EnStalfo*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    if (this->invincibilityTimer > 0) {\n        this->invincibilityTimer--;\n    }\n    \n    if (this->bodyCollider.base.acFlags & AC_HIT) {\n        this->bodyCollider.base.acFlags &= ~AC_HIT;\n        \n        if (this->invincibilityTimer == 0) {\n            Actor_ApplyDamage(&this->actor);\n            this->health = this->actor.colChkInfo.health;\n            \n            if (this->health == 0) {\n                this->actionState = STALFO_DEATH;\n                Enemy_StartFinishingBlow(play, &this->actor);\n                Audio_PlayActorSound2(&this->actor, NA_SE_EN_STAL_DEAD);\n            } else {\n                this->actionState = STALFO_DAMAGED;\n                this->invincibilityTimer = 30;\n                Audio_PlayActorSound2(&this->actor, NA_SE_EN_STAL_DAMAGE);\n            }\n        }\n    }\n    \n    f32 distToPlayer = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    switch (this->actionState) {\n        case STALFO_IDLE:\n            if (distToPlayer < CHASE_RANGE) {\n                this->actionState = STALFO_CHASE;\n            }\n            break;\n            \n        case STALFO_PATROL:\n            Math_SmoothStepToF(&this->actor.world.pos.x, this->targetPos.x, 0.3f, 5.0f, 0.0f);\n            Math_SmoothStepToF(&this->actor.world.pos.z, this->targetPos.z, 0.3f, 5.0f, 0.0f);\n            \n            if (distToPlayer < CHASE_RANGE) {\n                this->actionState = STALFO_CHASE;\n            }\n            break;\n            \n        case STALFO_CHASE:\n            Math_SmoothStepToS(&this->actor.shape.rot.y, \n                              Math_RAD_TO_BINANG(Math_FAtan2F(player->actor.world.pos.x - this->actor.world.pos.x,\n                                                             player->actor.world.pos.z - this->actor.world.pos.z)),\n                              0x800, 0x800, 0);\n            \n            if (distToPlayer < ATTACK_RANGE) {\n                this->actionState = STALFO_ATTACK;\n                this->timer = 30;\n            } else if (distToPlayer > CHASE_RANGE * 1.5f) {\n                this->actionState = STALFO_PATROL;\n            }\n            break;\n    }\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 35.0f, 30.0f, 30.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    Collider_UpdateCylinder(&this->actor, &this->bodyCollider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->bodyCollider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->bodyCollider.base);\n}\n\nconst ActorProfile En_Stalfo_InitVars = {\n    ACTOR_EN_STALFO,\n    ACTORCAT_ENEMY,\n    FLAGS,\n    OBJECT_SK,\n    sizeof(EnStalfo),\n    (ActorFunc)EnStalfo_Init,\n    (ActorFunc)EnStalfo_Destroy,\n    (ActorFunc)EnStalfo_Update,\n    (ActorFunc)EnStalfo_Draw\n};\n```"}
