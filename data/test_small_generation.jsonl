{"instruction": "I need help creating a pressure plate object that controls water levels, similar to the ones in Water Temple. It should rise when Link steps on it, lower when he steps off, and control a water level in its assigned room. Need all the actor code including collision and water control.", "output": "```c\n// Obj_WaterSwitch - Water level control pressure plate\n#include \"z_obj_water_switch.h\"\n\ntypedef enum {\n    /* 0x00 */ WATERSWITCH_IDLE,\n    /* 0x01 */ WATERSWITCH_PRESSED,\n    /* 0x02 */ WATERSWITCH_RISING,\n    /* 0x03 */ WATERSWITCH_FALLING\n} WaterSwitchState;\n\ntypedef struct {\n    /* 0x0000 */ DynaPolyActor dyna;\n    /* 0x0164 */ WaterSwitchState state;\n    /* 0x0168 */ f32 targetY;\n    /* 0x016C */ f32 initialY;\n    /* 0x0170 */ s16 timer;\n    /* 0x0172 */ s16 switchFlag;\n    /* 0x0174 */ ColliderCylinder collider;\n} ObjWaterSwitch; // size = 0x01C0\n\nvoid ObjWaterSwitch_Init(Actor* thisx, PlayState* play) {\n    ObjWaterSwitch* this = (ObjWaterSwitch*)thisx;\n    CollisionHeader* colHeader = NULL;\n    \n    Actor_ProcessInitChain(&this->dyna.actor, sInitChain);\n    DynaPolyActor_Init(&this->dyna, DPM_UNK);\n    CollisionHeader_GetVirtual(&gWaterSwitchCol, &colHeader);\n    this->dyna.bgId = DynaPoly_SetBgActor(play, &play->colCtx.dyna, &this->dyna.actor, colHeader);\n    \n    this->switchFlag = (this->dyna.actor.params >> 8) & 0x3F;\n    this->initialY = this->dyna.actor.world.pos.y;\n    this->targetY = this->initialY;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->dyna.actor, &sColliderInit);\n    \n    this->state = WATERSWITCH_IDLE;\n    Actor_SetScale(&this->dyna.actor, 0.1f);\n}\n\nvoid ObjWaterSwitch_Destroy(Actor* thisx, PlayState* play) {\n    ObjWaterSwitch* this = (ObjWaterSwitch*)thisx;\n    DynaPoly_DeleteBgActor(play, &play->colCtx.dyna, this->dyna.bgId);\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid ObjWaterSwitch_Update(Actor* thisx, PlayState* play) {\n    ObjWaterSwitch* this = (ObjWaterSwitch*)thisx;\n    \n    if (this->collider.base.ocFlags1 & OC1_HIT) {\n        this->state = WATERSWITCH_PRESSED;\n        this->targetY = this->initialY - 15.0f;\n        if (!Flags_GetSwitch(play, this->switchFlag)) {\n            Flags_SetSwitch(play, this->switchFlag);\n            Audio_PlayActorSound2(&this->dyna.actor, NA_SE_EV_FOOT_SWITCH);\n        }\n    } else if (this->state == WATERSWITCH_PRESSED) {\n        this->state = WATERSWITCH_RISING;\n        this->targetY = this->initialY;\n        Flags_UnsetSwitch(play, this->switchFlag);\n    }\n\n    // Handle movement\n    switch (this->state) {\n        case WATERSWITCH_RISING:\n        case WATERSWITCH_FALLING:\n            Math_ApproachF(&this->dyna.actor.world.pos.y, this->targetY, 0.5f, 2.0f);\n            if (fabsf(this->dyna.actor.world.pos.y - this->targetY) < 0.1f) {\n                this->state = WATERSWITCH_IDLE;\n            }\n            break;\n    }\n    \n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    Actor_UpdateBgCheckInfo(play, &this->dyna.actor, 0.0f, 0.0f, 0.0f, UPDBGCHECKINFO_FLAG_2);\n}\n\nvoid ObjWaterSwitch_Draw(Actor* thisx, PlayState* play) {\n    ObjWaterSwitch* this = (ObjWaterSwitch*)thisx;\n    Gfx_DrawDListOpa(play, gWaterSwitchDL);\n}\n\nconst ActorProfile Obj_WaterSwitch_InitVars = {\n    ACTOR_OBJ_WATER_SWITCH,\n    ACTORCAT_SWITCH,\n    FLAGS,\n    OBJECT_WATER_SWITCH,\n    sizeof(ObjWaterSwitch),\n    (ActorFunc)ObjWaterSwitch_Init,\n    (ActorFunc)ObjWaterSwitch_Destroy,\n    (ActorFunc)ObjWaterSwitch_Update,\n    (ActorFunc)ObjWaterSwitch_Draw\n};\n```"}
{"instruction": "I'm trying to implement Goron transformation mechanics similar to MM. I need code for an enemy-style actor that handles the transformation state, rolling physics, and punch attacks. It should use proper collision detection and damage calculations like other OoT enemies. Can you provide the full actor implementation with proper initialization, state handling, and cleanup?", "output": "```c\n/* Forward declarations */\ntypedef enum {\n    /* 0x00 */ GORON_STATE_IDLE,\n    /* 0x01 */ GORON_STATE_ROLL,\n    /* 0x02 */ GORON_STATE_PUNCH,\n    /* 0x03 */ GORON_STATE_TRANSFORM\n} GoronState;\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ ColliderCylinder collider;\n    /* 0x01DC */ GoronState actionState;\n    /* 0x01DE */ s16 timer;\n    /* 0x01E0 */ f32 rollSpeed;\n    /* 0x01E4 */ Vec3f prevPos;\n    /* 0x01F0 */ s16 damageTimer;\n    /* 0x01F2 */ s16 transformTimer;\n    /* 0x01F4 */ u8 isRolling;\n    /* 0x01F5 */ u8 isTransforming;\n} EnGoron; // size = 0x01F8\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_HIT0,\n        AT_ON | AT_TYPE_PLAYER,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0xFFCFFFFF, 0x00, 0x04 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_ON | TOUCH_SFX_NORMAL,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 45, 0, { 0, 0, 0 } },\n};\n\nvoid EnGoron_Init(Actor* thisx, PlayState* play) {\n    EnGoron* this = (EnGoron*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    Actor_ProcessInitChain(&this->actor, sInitChain);\n    \n    this->actor.colChkInfo.mass = MASS_HEAVY;\n    this->actor.colChkInfo.health = 8;\n    this->actor.gravity = -2.0f;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinderType1(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actionState = GORON_STATE_IDLE;\n    this->isRolling = false;\n    this->isTransforming = false;\n    this->rollSpeed = 0.0f;\n    \n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 30.0f);\n}\n\nvoid EnGoron_Destroy(Actor* thisx, PlayState* play) {\n    EnGoron* this = (EnGoron*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnGoron_SetupRoll(EnGoron* this) {\n    this->actionState = GORON_STATE_ROLL;\n    this->rollSpeed = 8.0f;\n    this->timer = 0;\n    Actor_PlaySfx(&this->actor, NA_SE_PL_ROLL);\n}\n\nvoid EnGoron_UpdateRoll(EnGoron* this, PlayState* play) {\n    this->actor.world.rot.y = this->actor.shape.rot.y;\n    this->actor.speedXZ = this->rollSpeed;\n    \n    if (this->timer++ > 120) {\n        this->actionState = GORON_STATE_IDLE;\n        this->rollSpeed = 0.0f;\n    }\n    \n    Actor_MoveXZGravity(&this->actor);\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 50.0f,\n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n}\n\nvoid EnGoron_Update(Actor* thisx, PlayState* play) {\n    EnGoron* this = (EnGoron*)thisx;\n    \n    if (this->damageTimer > 0) {\n        this->damageTimer--;\n    }\n    \n    switch (this->actionState) {\n        case GORON_STATE_IDLE:\n            if (CHECK_BTN_ALL(play->state.input[0].press.button, BTN_B)) {\n                EnGoron_SetupRoll(this);\n            }\n            break;\n            \n        case GORON_STATE_ROLL:\n            EnGoron_UpdateRoll(this, play);\n            break;\n            \n        case GORON_STATE_TRANSFORM:\n            if (this->transformTimer-- <= 0) {\n                this->actionState = GORON_STATE_IDLE;\n                this->isTransforming = false;\n            }\n            break;\n    }\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAT(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (this->actionState == GORON_STATE_ROLL) {\n        CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    }\n}\n\nvoid EnGoron_Draw(Actor* thisx, PlayState* play) {\n    EnGoron* this = (EnGoron*)thisx;\n    \n    func_8002EBCC(&this->actor, play, 0);\n    // Draw model and effects here\n}\n```"}
{"instruction": "I need help creating a Gossip Stone actor that displays random hints from a predefined list when struck with the sword. It should handle collisions properly, play the correct jingle, and have proper error checking. The hints should be stored in an array and cycle through them each time the stone is hit. Can you show me the complete code following OoT's patterns?", "output": "```c\n#include \"z_en_gs.h\"\n#include \"assets/objects/object_gs/object_gs.h\"\n\n#define NUM_HINTS 8\n\ntypedef struct {\n    /* 0x0000 */ DynaPolyActor dyna;\n    /* 0x014C */ ColliderCylinder collider;\n    /* 0x0198 */ s16 hintIndex;\n    /* 0x019A */ s16 actionTimer;\n    /* 0x019C */ GsActionFunc actionFunc;\n} EnGs; // size = 0x01A0\n\nstatic const char* sHintMessages[NUM_HINTS] = {\n    \"They say the temple contains a hidden chest...\",\n    \"They say the forest holds many secrets...\",\n    \"They say the mountain summit is treacherous...\",\n    \"They say the lake holds an ancient power...\",\n    \"They say the desert winds hide something...\",\n    \"They say the graveyard has restless spirits...\",\n    \"They say the castle has hidden passages...\",\n    \"They say the mask shop owner knows more...\"\n};\n\nvoid EnGs_Init(Actor* thisx, PlayState* play) {\n    EnGs* this = (EnGs*)thisx;\n    \n    Actor_ProcessInitChain(&this->dyna.actor, sInitChain);\n    Actor_SetScale(&this->dyna.actor, 0.01f);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->dyna.actor, &sCylinderInit);\n    \n    this->hintIndex = 0;\n    this->actionTimer = 0;\n    this->actionFunc = EnGs_Wait;\n    \n    ActorShape_Init(&this->dyna.actor.shape, 0.0f, ActorShadow_DrawCircle, 20.0f);\n}\n\nvoid EnGs_Destroy(Actor* thisx, PlayState* play) {\n    EnGs* this = (EnGs*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnGs_Wait(EnGs* this, PlayState* play) {\n    if (this->collider.base.acFlags & AC_HIT) {\n        this->collider.base.acFlags &= ~AC_HIT;\n        this->actionTimer = 30;\n        this->actionFunc = EnGs_DisplayHint;\n        \n        // Play Gossip Stone jingle\n        Audio_PlayActorSfx2(&this->dyna.actor, NA_SE_EV_STONE_STATUE_OPEN);\n        \n        // Increment hint index with wraparound\n        this->hintIndex = (this->hintIndex + 1) % NUM_HINTS;\n    }\n}\n\nvoid EnGs_DisplayHint(EnGs* this, PlayState* play) {\n    if (this->actionTimer > 0) {\n        this->actionTimer--;\n        \n        // Display hint message\n        Message_StartTextbox(play, sHintMessages[this->hintIndex], NULL);\n        \n        if (this->actionTimer == 0) {\n            this->actionFunc = EnGs_Wait;\n        }\n    }\n}\n\nvoid EnGs_Update(Actor* thisx, PlayState* play) {\n    EnGs* this = (EnGs*)thisx;\n    \n    // Update collision detection\n    Collider_UpdateCylinder(&this->dyna.actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Run current action function\n    if (this->actionFunc != NULL) {\n        this->actionFunc(this, play);\n    }\n}\n\nvoid EnGs_Draw(Actor* thisx, PlayState* play) {\n    EnGs* this = (EnGs*)thisx;\n    \n    // Draw Gossip Stone model\n    Gfx_DrawDListOpa(play, gGossipStoneDL);\n}\n\nconst ActorProfile En_Gs_InitVars = {\n    ACTOR_EN_GS,\n    ACTORCAT_PROP,\n    FLAGS_NONE,\n    OBJECT_GS,\n    sizeof(EnGs),\n    (ActorFunc)EnGs_Init,\n    (ActorFunc)EnGs_Destroy,\n    (ActorFunc)EnGs_Update,\n    (ActorFunc)EnGs_Draw\n};\n```"}
{"instruction": "I need help creating a guide NPC that acts as an item storage keeper, similar to the bean seller but for storing and retrieving items. The NPC should have collision detection, proper state management for dialog/trading, and handle edge cases like full inventories. Can you provide the full actor code with proper OoT-style initialization and interaction handling?", "output": "```c\n// Guide NPC with item storage functionality\n#include \"z_en_guide.h\"\n#include \"assets/objects/object_guide/object_guide.h\"\n\ntypedef enum {\n    /* 0x00 */ GUIDE_STATE_IDLE,\n    /* 0x01 */ GUIDE_STATE_TALKING,\n    /* 0x02 */ GUIDE_STATE_STORE_ITEM,\n    /* 0x03 */ GUIDE_STATE_RETRIEVE_ITEM,\n    /* 0x04 */ GUIDE_STATE_ERROR\n} GuideState;\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ ColliderCylinder collider;\n    /* 0x01DC */ GuideState actionState;\n    /* 0x01DE */ s16 dialogTimer;\n    /* 0x01E0 */ s16 storedItemCount;\n    /* 0x01E2 */ s16 blinkTimer;\n    /* 0x01E4 */ u8 storedItems[10]; // Max 10 items\n    /* 0x01EE */ u8 exchangeItemId;\n} EnGuide; // size = 0x01F0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000010, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 60, 0, { 0, 0, 0 } },\n};\n\nvoid EnGuide_Init(Actor* thisx, PlayState* play) {\n    EnGuide* this = (EnGuide*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    Actor_ProcessInitChain(&this->actor, sInitChain);\n    \n    // Setup collision\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    // Initialize actor properties\n    this->actor.targetMode = 6;\n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\n    this->actionState = GUIDE_STATE_IDLE;\n    this->dialogTimer = 0;\n    this->storedItemCount = 0;\n    \n    // Setup animations\n    SkelAnime_InitFlex(play, &this->skelAnime, &gGuideSkel, &gGuideIdleAnim, NULL, NULL, 0);\n}\n\nvoid EnGuide_Destroy(Actor* thisx, PlayState* play) {\n    EnGuide* this = (EnGuide*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnGuide_HandleDialog(EnGuide* this, PlayState* play) {\n    if (Actor_ProcessTalkRequest(&this->actor, play)) {\n        if (this->actionState == GUIDE_STATE_IDLE) {\n            Message_ContinueTextbox(play, 0x1000); // Custom message ID\n            this->actionState = GUIDE_STATE_TALKING;\n        }\n    } else if (this->actionState != GUIDE_STATE_IDLE &&\n               Message_GetState(&play->msgCtx) == TEXT_STATE_NONE) {\n        this->actionState = GUIDE_STATE_IDLE;\n    }\n}\n\nvoid EnGuide_StoreItem(EnGuide* this, PlayState* play) {\n    if (this->storedItemCount >= 10) {\n        // Storage full error\n        Message_ContinueTextbox(play, 0x1001);\n        this->actionState = GUIDE_STATE_ERROR;\n        return;\n    }\n    \n    // Store currently held item\n    this->storedItems[this->storedItemCount++] = this->exchangeItemId;\n    Actor_PlaySfx(&this->actor, NA_SE_EV_PUT_IN_POT);\n}\n\nvoid EnGuide_Update(Actor* thisx, PlayState* play) {\n    EnGuide* this = (EnGuide*)thisx;\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Handle interaction range\n    if (Actor_WorldDistXZToActor(&this->actor, &GET_PLAYER(play)->actor) < 100.0f) {\n        this->actor.textId = 0x1000;\n        func_8002F2CC(&this->actor, play, 100.0f);\n    }\n    \n    EnGuide_HandleDialog(this, play);\n    \n    // Update animation\n    SkelAnime_Update(&this->skelAnime);\n}\n\nvoid EnGuide_Draw(Actor* thisx, PlayState* play) {\n    EnGuide* this = (EnGuide*)thisx;\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                         this->skelAnime.dListCount, NULL, NULL, this);\n}\n```"}
{"instruction": "I need help implementing a Song of Storms rain effect object that creates a rainstorm when a switch is activated (like in OoT's Kakariko windmill). It should spawn rain particles, trigger sound effects, and eventually fade out. Can you provide complete code matching OoT's style?", "output": "```c\n// Defines for rain effect object\n#include \"z_en_item00.h\"\n#include \"assets/objects/gameplay_keep/gameplay_keep.h\"\n\n#define RAIN_DURATION 100\n#define RAIN_PARTICLE_COUNT 20\n#define RAIN_RADIUS 300.0f\n\ntypedef enum {\n    /* 0x00 */ RAIN_STATE_OFF,\n    /* 0x01 */ RAIN_STATE_ACTIVE,\n    /* 0x02 */ RAIN_STATE_FADE\n} RainState;\n\ntypedef struct {\n    /* 0x0000 */ DynaPolyActor dyna;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 switchFlag;\n    /* 0x0150 */ RainState state;\n    /* 0x0154 */ f32 alpha;\n    /* 0x0158 */ Vec3f rainOrigin;\n} ObjRainEffect; // size = 0x0164\n\nvoid ObjRainEffect_Init(Actor* thisx, PlayState* play) {\n    ObjRainEffect* this = (ObjRainEffect*)thisx;\n    \n    Actor_ProcessInitChain(&this->dyna.actor, sInitChain);\n    Actor_SetScale(&this->dyna.actor, 1.0f);\n    \n    this->switchFlag = (this->dyna.actor.params >> 8) & 0xFF;\n    this->state = RAIN_STATE_OFF;\n    this->timer = 0;\n    this->alpha = 0.0f;\n    \n    this->rainOrigin = this->dyna.actor.world.pos;\n}\n\nvoid ObjRainEffect_Destroy(Actor* thisx, PlayState* play) {\n    ObjRainEffect* this = (ObjRainEffect*)thisx;\n    // Cleanup if needed\n}\n\nvoid ObjRainEffect_Update(Actor* thisx, PlayState* play) {\n    ObjRainEffect* this = (ObjRainEffect*)thisx;\n    \n    switch(this->state) {\n        case RAIN_STATE_OFF:\n            if (Flags_GetSwitch(play, this->switchFlag)) {\n                this->state = RAIN_STATE_ACTIVE;\n                this->timer = RAIN_DURATION;\n                Audio_PlayActorSound2(&this->dyna.actor, NA_SE_EV_RAIN_START);\n            }\n            break;\n            \n        case RAIN_STATE_ACTIVE:\n            if (this->timer > 0) {\n                this->timer--;\n                Math_ApproachF(&this->alpha, 255.0f, 1.0f, 10.0f);\n                \n                for (s32 i = 0; i < RAIN_PARTICLE_COUNT; i++) {\n                    Vec3f pos;\n                    pos.x = this->rainOrigin.x + Rand_CenteredFloat(RAIN_RADIUS);\n                    pos.y = this->rainOrigin.y + 200.0f;\n                    pos.z = this->rainOrigin.z + Rand_CenteredFloat(RAIN_RADIUS);\n                    \n                    EffectSsGSplash_Spawn(play, &pos, NULL, NULL, 0, 800);\n                }\n                \n                Audio_PlayActorSound2(&this->dyna.actor, NA_SE_EV_RAIN_CONTINUE - SFX_FLAG);\n            } else {\n                this->state = RAIN_STATE_FADE;\n            }\n            break;\n            \n        case RAIN_STATE_FADE:\n            Math_ApproachF(&this->alpha, 0.0f, 1.0f, 5.0f);\n            if (this->alpha <= 0.0f) {\n                this->state = RAIN_STATE_OFF;\n                Audio_PlayActorSound2(&this->dyna.actor, NA_SE_EV_RAIN_STOP);\n            }\n            break;\n    }\n}\n\nvoid ObjRainEffect_Draw(Actor* thisx, PlayState* play) {\n    ObjRainEffect* this = (ObjRainEffect*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx, \"rain_effect\");\n    \n    Gfx_SetupDL_25Xlu(play->state.gfxCtx);\n    gDPSetPrimColor(POLY_XLU_DISP++, 0, 0, 155, 155, 255, (u8)this->alpha);\n    \n    // Draw rain effect here if needed beyond particles\n    \n    CLOSE_DISPS(play->state.gfxCtx, \"rain_effect\");\n}\n\nconst ActorProfile Obj_RainEffect_InitVars = {\n    ACTOR_OBJ_RAIN_EFFECT,\n    ACTORCAT_PROP,\n    FLAGS_NONE,\n    OBJECT_GAMEPLAY_KEEP,\n    sizeof(ObjRainEffect),\n    (ActorFunc)ObjRainEffect_Init,\n    (ActorFunc)ObjRainEffect_Destroy,\n    (ActorFunc)ObjRainEffect_Update,\n    (ActorFunc)ObjRainEffect_Draw\n};\n```"}
