{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and visual effects", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 hitTimer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnHeartSpawner; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->hitTimer = 0;\n    this->actionState = 0;\n    this->scale = 1.0f;\n    \n    this->actor.colChkInfo.mass = 0;\n    Actor_SetFocus(&this->actor, 20.0f);\n}\n\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    if (this->hitTimer > 0) {\n        this->hitTimer--;\n    }\n\n    if (this->collider.base.acFlags & AC_HIT) {\n        if (this->hitTimer == 0) {\n            // Spawn heart piece using authentic EnItem00 pattern\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       this->actor.world.pos.x,\n                       this->actor.world.pos.y + 40.0f,\n                       this->actor.world.pos.z,\n                       0, 0, 0, ITEM00_HEART_PIECE);\n                       \n            Actor_PlaySfx(&this->actor, NA_SE_IT_HEART_PIECE_APPEAR);\n            this->hitTimer = 30;\n        }\n        this->collider.base.acFlags &= ~AC_HIT;\n    }\n\n    // Authentic collision update sequence\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile EnHeartSpawner_Profile = {\n    /**/ ACTOR_EN_HEART_SPAWNER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnHeartSpawner),\n    /**/ EnHeartSpawner_Init,\n    /**/ EnHeartSpawner_Destroy,\n    /**/ EnHeartSpawner_Update,\n    /**/ NULL\n};\n```"}
{"instruction": "Implement a crystal switch actor that toggles between blue/red states, spawns rupees when hit, and has proper collision detection. Must follow OoT patterns exactly.", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 switchState;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n    /* 0x01A0 */ LightNode* lightNode;\n    /* 0x01A4 */ LightInfo lightInfo;\n} EnCrystalSwitch; // size = 0x1B4\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 35, 0, { 0, 0, 0 } },\n};\n\nvoid EnCrystalSwitch_Init(Actor* thisx, PlayState* play) {\n    EnCrystalSwitch* this = (EnCrystalSwitch*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.1f);\n    this->actor.focus.pos = this->actor.world.pos;\n    this->actor.focus.pos.y += 20.0f;\n    \n    this->switchState = 0;\n    this->timer = 0;\n    \n    LightContext_InsertLight(play, &play->lightCtx, &this->lightInfo);\n}\n\nvoid EnCrystalSwitch_Update(Actor* thisx, PlayState* play) {\n    EnCrystalSwitch* this = (EnCrystalSwitch*)thisx;\n    Vec3f spawnPos;\n    \n    this->timer++;\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        this->collider.base.acFlags &= ~AC_HIT;\n        this->switchState ^= 1;\n        \n        // Spawn rupee reward using authentic EnItem00 pattern\n        spawnPos = this->actor.world.pos;\n        spawnPos.y += 40.0f;\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   spawnPos.x, spawnPos.y, spawnPos.z,\n                   0, 0, 0, ITEM00_RUPEE_BLUE);\n                   \n        Actor_PlaySfx(&this->actor, NA_SE_SY_CORRECT_CHIME);\n    }\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Update lighting\n    this->lightInfo.params.point.x = this->actor.world.pos.x;\n    this->lightInfo.params.point.y = this->actor.world.pos.y;\n    this->lightInfo.params.point.z = this->actor.world.pos.z;\n}\n\nconst ActorProfile EnCrystalSwitch_Profile = {\n    /**/ ACTOR_EN_CRYSTAL_SWITCH,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnCrystalSwitch),\n    /**/ EnCrystalSwitch_Init,\n    /**/ EnCrystalSwitch_Destroy,\n    /**/ EnCrystalSwitch_Update,\n    /**/ EnCrystalSwitch_Draw\n};\n```"}
{"instruction": "Create a debugging helper actor that displays collision info and spawns rupees when triggered", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 debugState;\n    /* 0x0150 */ f32 detectionRange;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnDbgHelper; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnDbgHelper_Init(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->detectionRange = 100.0f;\n    Actor_SetScale(&this->actor, 0.01f);\n    this->debugState = 0;\n    this->timer = 0;\n}\n\nvoid EnDbgHelper_Update(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    if (Actor_WorldDistXYZToActor(&player->actor, &this->actor) < this->detectionRange) {\n        if (Player_IsFacingActor(&this->actor, player, 0x2000)) {\n            if (this->debugState == 0) {\n                // Spawn debug rupee using authentic EnItem00 pattern\n                Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                    this->actor.world.pos.x, this->actor.world.pos.y + 40.0f,\n                    this->actor.world.pos.z, 0, 0, 0, ITEM00_RUPEE_BLUE);\n                    \n                this->debugState = 1;\n                Player_PlaySfx(player, NA_SE_IT_SWORD_IMPACT);\n            }\n        }\n    } else {\n        this->debugState = 0;\n    }\n    \n    // Authentic collision update pattern\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile EnDbgHelper_Profile = {\n    /**/ ACTOR_EN_DBG_HELPER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnDbgHelper),\n    /**/ EnDbgHelper_Init,\n    /**/ Actor_Destroy,\n    /**/ EnDbgHelper_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when hit and plays a chime sound, using authentic OoT patterns", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 hitboxScale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnHeartSpawner; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.world.rot.y = 0;\n    this->actor.shape.rot.y = 0;\n    Actor_SetScale(&this->actor, 0.01f);\n    Actor_SetFocus(&this->actor, 20.0f);\n    \n    this->timer = 0;\n    this->actionState = 0;\n    this->hitboxScale = 1.0f;\n}\n\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        Actor_PlaySfx(&this->actor, NA_SE_EV_HEART_OF_GROTTO_APPEAR);\n        \n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   this->actor.world.pos.x,\n                   this->actor.world.pos.y + 40.0f,\n                   this->actor.world.pos.z,\n                   0, 0, 0, ITEM00_HEART_PIECE);\n                   \n        Actor_Kill(&this->actor);\n    }\n}\n\nconst ActorProfile EnHeartSpawner_Profile = {\n    /**/ ACTOR_EN_HEART_SPAWNER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnHeartSpawner),\n    /**/ EnHeartSpawner_Init,\n    /**/ Actor_Destroy,\n    /**/ EnHeartSpawner_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, plays a sound effect, and disappears in a sparkle effect", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 hitCount;\n    /* 0x0150 */ ColliderCylinder collider;\n} EnBreakHeart; // size = 0x19C\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnBreakHeart_Init(Actor* thisx, PlayState* play) {\n    EnBreakHeart* this = (EnBreakHeart*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->timer = 0;\n    this->hitCount = 0;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\n}\n\nvoid EnBreakHeart_Update(Actor* thisx, PlayState* play) {\n    EnBreakHeart* this = (EnBreakHeart*)thisx;\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    if (this->collider.base.acFlags & AC_HIT) {\n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\n        \n        // Spawn heart piece at current position\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   this->actor.world.pos.x,\n                   this->actor.world.pos.y,\n                   this->actor.world.pos.z,\n                   0, 0, 0, ITEM00_HEART_PIECE);\n        \n        // Spawn sparkle effects\n        EffectSsKiraKira_SpawnSmall(play, &this->actor.world.pos,\n                                   &sVelocity, &sAccel, &sPrimColor, &sEnvColor);\n        \n        Actor_Kill(&this->actor);\n    }\n}\n\nconst ActorProfile EnBreakHeart_Profile = {\n    /**/ ACTOR_EN_BREAK_HEART,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnBreakHeart),\n    /**/ EnBreakHeart_Init,\n    /**/ EnBreakHeart_Destroy,\n    /**/ EnBreakHeart_Update,\n    /**/ NULL\n};\n```"}
{"instruction": "Implement a special chest actor that spawns a heart piece when opened, plays a custom animation sequence, and handles player interaction with proper collision detection.", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 openAngle;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 animTimer;\n    /* 0x0154 */ ColliderCylinder collider;\n    /* 0x01A0 */ s16 rewardSpawned;\n} EnSpecialChest; // size = 0x1A4\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_WOOD,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 30, 40, 0, { 0, 0, 0 } },\n};\n\nvoid EnSpecialChest_Init(Actor* thisx, PlayState* play) {\n    EnSpecialChest* this = (EnSpecialChest*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->openAngle = 0;\n    this->actionState = 0;\n    this->rewardSpawned = false;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.focus.pos = this->actor.world.pos;\n    this->actor.focus.pos.y += 20.0f;\n}\n\nvoid EnSpecialChest_Update(Actor* thisx, PlayState* play) {\n    EnSpecialChest* this = (EnSpecialChest*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    switch(this->actionState) {\n        case 0: // Waiting for player interaction\n            if (Actor_WorldDistXYZToActor(&player->actor, &this->actor) < 80.0f &&\n                Player_IsFacingActor(&this->actor, player, 0x2000)) {\n                this->actionState = 1;\n                Actor_PlaySfx(&this->actor, NA_SE_EV_TREASURE_BOX_OPEN);\n            }\n            break;\n            \n        case 1: // Opening animation\n            this->openAngle += 0x200;\n            if (this->openAngle >= 0x4000) {\n                this->openAngle = 0x4000;\n                this->actionState = 2;\n                \n                if (!this->rewardSpawned) {\n                    Vec3f spawnPos = this->actor.world.pos;\n                    spawnPos.y += 40.0f;\n                    \n                    // Spawn heart piece using authentic EnItem00\n                    Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                              spawnPos.x, spawnPos.y, spawnPos.z,\n                              0, 0, 0, ITEM00_HEART_PIECE);\n                              \n                    this->rewardSpawned = true;\n                }\n            }\n            break;\n            \n        case 2: // Fully opened\n            break;\n    }\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 0.0f, BGCHECKFLAG_GROUND);\n}\n\nconst ActorProfile EnSpecialChest_Profile = {\n    /**/ ACTOR_EN_SPECIAL_CHEST,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnSpecialChest),\n    /**/ EnSpecialChest_Init,\n    /**/ Actor_Destroy,\n    /**/ EnSpecialChest_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Create a debugging helper actor that displays a colored cylinder at its position and spawns a blue rupee when Link gets close. The cylinder color changes based on distance to player.", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 debugState;\n    /* 0x0150 */ f32 detectionRange;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnDbgHelp; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 40, 0, { 0, 0, 0 } },\n};\n\nvoid EnDbgHelp_Init(Actor* thisx, PlayState* play) {\n    EnDbgHelp* this = (EnDbgHelp*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->detectionRange = 150.0f;\n    this->debugState = 0;\n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnDbgHelp_Destroy(Actor* thisx, PlayState* play) {\n    EnDbgHelp* this = (EnDbgHelp*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnDbgHelp_Update(Actor* thisx, PlayState* play) {\n    EnDbgHelp* this = (EnDbgHelp*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    f32 dist = Actor_WorldDistXYZToActor(&this->actor, &player->actor);\n    \n    if (dist < this->detectionRange) {\n        this->debugState = 1;\n        if (dist < 50.0f && this->timer == 0) {\n            // Spawn blue rupee using authentic EnItem00 pattern\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       this->actor.world.pos.x,\n                       this->actor.world.pos.y + 20.0f,\n                       this->actor.world.pos.z,\n                       0, 0, 0, ITEM00_RUPEE_BLUE);\n            this->timer = 30;\n        }\n    } else {\n        this->debugState = 0;\n    }\n    \n    if (this->timer > 0) {\n        this->timer--;\n    }\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnDbgHelp_Draw(Actor* thisx, PlayState* play) {\n    EnDbgHelp* this = (EnDbgHelp*)thisx;\n    \n    Matrix_Push();\n    Matrix_Translate(this->actor.world.pos.x,\n                    this->actor.world.pos.y,\n                    this->actor.world.pos.z,\n                    MTXMODE_NEW);\n    \n    // Change color based on state\n    if (this->debugState == 0) {\n        Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    } else {\n        Gfx_SetupDL_25Xlu(play->state.gfxCtx);\n    }\n    \n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y,\n                this->actor.scale.z, MTXMODE_APPLY);\n    Matrix_Pop();\n}\n\nconst ActorProfile EnDbgHelp_Profile = {\n    /**/ ACTOR_EN_DBG_HELP,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnDbgHelp),\n    /**/ EnDbgHelp_Init,\n    /**/ EnDbgHelp_Destroy, \n    /**/ EnDbgHelp_Update,\n    /**/ EnDbgHelp_Draw\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword and plays a chime sound effect", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 hitboxScale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->actor.world.rot.y = 0;\\n    this->hitboxScale = 1.0f;\\n    Actor_SetScale(&this->actor, 0.01f);\\n    \\n    this->actionState = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    Player* player = GET_PLAYER(play);\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        Actor_PlaySfx(&this->actor, NA_SE_EV_HEART_OF_GROTTO_APPEAR);\\n        \\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    this->actor.world.pos.x,\\n                    this->actor.world.pos.y + 40.0f,\\n                    this->actor.world.pos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n                    \\n        Actor_Kill(&this->actor);\\n    }\\n    \\n    // Face player\\n    Math_SmoothStepToS(&this->actor.world.rot.y,\\n                       Actor_WorldYawTowardPoint(&this->actor, &player->actor.world.pos),\\n                       2, 0x300, 0);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ EnHeartSpawner_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and visual feedback", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 hitTimer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnHeartSpawner; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->hitTimer = 0;\n    this->actionState = 0;\n    this->scale = 1.0f;\n    \n    this->actor.colChkInfo.mass = 0;\n    Actor_SetFocus(&this->actor, 20.0f);\n}\n\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    if (this->hitTimer > 0) {\n        this->hitTimer--;\n        if (this->hitTimer == 0) {\n            // Spawn heart piece using authentic EnItem00 pattern\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       this->actor.world.pos.x,\n                       this->actor.world.pos.y + 20.0f,\n                       this->actor.world.pos.z,\n                       0, 0, 0, ITEM00_HEART_PIECE);\n                       \n            Actor_Kill(&this->actor);\n            return;\n        }\n    }\n\n    if (this->collider.base.acFlags & AC_HIT) {\n        this->hitTimer = 10;\n        Actor_PlaySfx(&this->actor, NA_SE_EN_ITEM_PIECE_OF_HEART);\n        this->collider.base.acFlags &= ~AC_HIT;\n    }\n\n    // Authentic collision update pattern\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile EnHeartSpawner_Profile = {\n    /**/ ACTOR_EN_HEART_SPAWNER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnHeartSpawner),\n    /**/ EnHeartSpawner_Init,\n    /**/ Actor_Destroy,\n    /**/ EnHeartSpawner_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Implement a magical crystal actor that spins in place, detects player proximity, and spawns a heart piece when struck. Must use authentic OoT patterns.", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 spinAngle;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 activeRange;\n    /* 0x0154 */ f32 glowIntensity;\n    /* 0x0158 */ ColliderCylinder collider;\n} EnMagicCrystal; // size = 0x1A4\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 45, 0, { 0, 0, 0 } },\n};\n\nvoid EnMagicCrystal_Init(Actor* thisx, PlayState* play) {\n    EnMagicCrystal* this = (EnMagicCrystal*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.02f);\n    this->spinAngle = 0;\n    this->actionState = 0;\n    this->activeRange = 150.0f;\n    this->glowIntensity = 0.0f;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetFocus(&this->actor, 20.0f);\n    this->actor.flags |= ACTOR_FLAG_0;\n}\n\nvoid EnMagicCrystal_Destroy(Actor* thisx, PlayState* play) {\n    EnMagicCrystal* this = (EnMagicCrystal*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnMagicCrystal_Update(Actor* thisx, PlayState* play) {\n    EnMagicCrystal* this = (EnMagicCrystal*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->spinAngle += 0x0400;\n    \n    // Check player distance\n    f32 playerDist = Actor_WorldDistXYZToActor(&this->actor, &player->actor);\n    \n    if (playerDist < this->activeRange) {\n        this->glowIntensity = (this->activeRange - playerDist) / this->activeRange;\n        \n        if (this->collider.base.acFlags & AC_HIT) {\n            Vec3f spawnPos;\n            spawnPos.x = this->actor.world.pos.x;\n            spawnPos.y = this->actor.world.pos.y + 40.0f;\n            spawnPos.z = this->actor.world.pos.z;\n            \n            // Spawn heart piece using authentic EnItem00\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       spawnPos.x, spawnPos.y, spawnPos.z,\n                       0, 0, 0, ITEM00_HEART_PIECE);\n                       \n            Actor_PlaySfx(&this->actor, NA_SE_EV_CRYSTAL_BREAK);\n            Actor_Kill(&this->actor);\n            return;\n        }\n    }\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile EnMagicCrystal_Profile = {\n    /**/ ACTOR_EN_MAGIC_CRYSTAL,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnMagicCrystal),\n    /**/ EnMagicCrystal_Init,\n    /**/ EnMagicCrystal_Destroy, \n    /**/ EnMagicCrystal_Update,\n    /**/ NULL\n};\n```"}
{"instruction": "Create a debugging helper actor that spawns a blue rupee at its location when the player gets close, then despawns itself. Include collision detection and debug text.", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 detectionRange;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnDbgHelper; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnDbgHelper_Init(Actor* thisx, PlayState* play) {\\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->detectionRange = 100.0f;\\n    this->actionState = 0;\\n    this->timer = 0;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n}\\n\\nvoid EnDbgHelper_Update(Actor* thisx, PlayState* play) {\\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\\n    Player* player = GET_PLAYER(play);\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    f32 dist = Actor_WorldDistXYZToActor(&this->actor, &player->actor);\\n    \\n    if (dist < this->detectionRange && this->actionState == 0) {\\n        // Spawn blue rupee using authentic EnItem00 pattern\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                   this->actor.world.pos.x,\\n                   this->actor.world.pos.y,\\n                   this->actor.world.pos.z,\\n                   0, 0, 0, ITEM00_RUPEE_BLUE);\\n        \\n        this->actionState = 1;\\n        this->timer = 20; // Frames before despawn\\n    }\\n    \\n    if (this->actionState == 1) {\\n        if (--this->timer <= 0) {\\n            Actor_Kill(&this->actor);\\n        }\\n    }\\n}\\n\\nconst ActorProfile EnDbgHelper_Profile = {\\n    /**/ ACTOR_EN_DBG_HELPER,\\n    /**/ ACTORCAT_MISC,\\n    /**/ FLAGS_NONE,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnDbgHelper),\\n    /**/ EnDbgHelper_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnDbgHelper_Update,\\n    /**/ NULL,\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, plays a sound, and disappears in a sparkle effect", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnHeartSpawner; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 15, 25, 0, { 0, 0, 0 } },\n};\n\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.colChkInfo.mass = 0;\n    this->actor.targetMode = 0;\n    \n    this->timer = 0;\n    this->actionState = 0;\n    this->scale = 1.0f;\n}\n\nvoid EnHeartSpawner_Destroy(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        Actor_PlaySfx(&this->actor, NA_SE_EV_HEART_OF_GROTTO_APPEAR);\n        \n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   this->actor.world.pos.x,\n                   this->actor.world.pos.y,\n                   this->actor.world.pos.z,\n                   0, 0, 0, ITEM00_HEART_PIECE);\n                   \n        Actor_Kill(&this->actor);\n    }\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 0.0f, BGCHECKFLAG_GROUND);\n}\n\nvoid EnHeartSpawner_Draw(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Matrix_Push();\n    Matrix_Scale(this->scale, this->scale, this->scale, MTXMODE_APPLY);\n    Matrix_Pop();\n}\n\nconst ActorProfile EnHeartSpawner_Profile = {\n    /**/ ACTOR_EN_HEART_SPAWNER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnHeartSpawner),\n    /**/ EnHeartSpawner_Init,\n    /**/ EnHeartSpawner_Destroy,\n    /**/ EnHeartSpawner_Update,\n    /**/ EnHeartSpawner_Draw\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, plays a sound effect, and disappears with a particle effect", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 hitCount;\n    /* 0x0150 */ ColliderCylinder collider;\n} EnBreakHeart; // size = 0x19C\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnBreakHeart_Init(Actor* thisx, PlayState* play) {\n    EnBreakHeart* this = (EnBreakHeart*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->timer = 0;\n    this->hitCount = 0;\n    \n    Actor_SetFocus(&this->actor, 20.0f);\n}\n\nvoid EnBreakHeart_Update(Actor* thisx, PlayState* play) {\n    EnBreakHeart* this = (EnBreakHeart*)thisx;\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\n        \n        // Spawn heart piece at current position\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   this->actor.world.pos.x,\n                   this->actor.world.pos.y,\n                   this->actor.world.pos.z,\n                   0, 0, 0, ITEM00_HEART_PIECE);\n        \n        // Create particle effect\n        EffectSsDeadDb_Spawn(play, &this->actor.world.pos,\n                            &gZeroVec, &gZeroVec,\n                            100, 0, 255, 255, 255, 255,\n                            0, 0, 0, 1, 9, true);\n        \n        Actor_Kill(&this->actor);\n    }\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n}\n\nconst ActorProfile EnBreakHeart_Profile = {\n    /**/ ACTOR_EN_BREAK_HEART,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnBreakHeart),\n    /**/ EnBreakHeart_Init,\n    /**/ Actor_Destroy,\n    /**/ EnBreakHeart_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Implement a treasure chest actor that spawns a heart piece when opened, with proper collision, animations and sound effects. The chest should only open when approached from the front.", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 openAngle;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 lidRotation;\\n    /* 0x0154 */ ColliderCylinder collider;\\n    /* 0x01A0 */ Vec3f treasurePos;\\n} EnTreasure; // size = 0x1AC\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_WOOD,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_WOOD,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnTreasure_Init(Actor* thisx, PlayState* play) {\\n    EnTreasure* this = (EnTreasure*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    \\n    this->actionState = 0;\\n    this->openAngle = 0;\\n    this->lidRotation = 0.0f;\\n    \\n    // Store treasure spawn position\\n    this->treasurePos = this->actor.world.pos;\\n    this->treasurePos.y += 30.0f;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnTreasure_Update(Actor* thisx, PlayState* play) {\\n    EnTreasure* this = (EnTreasure*)thisx;\\n    Player* player = GET_PLAYER(play);\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    switch(this->actionState) {\\n        case 0: // Waiting for player\\n            if (Actor_WorldDistXYZToActor(&player->actor, &this->actor) < 100.0f &&\\n                Player_IsFacingActor(&this->actor, player, 0x2000)) {\\n                \\n                this->actionState = 1;\\n                Actor_PlaySfx(&this->actor, NA_SE_EV_TREASURE_OPEN);\\n            }\\n            break;\\n            \\n        case 1: // Opening animation\\n            this->lidRotation += 0.1f;\\n            if (this->lidRotation >= M_PI / 2) {\\n                this->lidRotation = M_PI / 2;\\n                this->actionState = 2;\\n                \\n                // Spawn heart piece using authentic EnItem00\\n                Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                           this->treasurePos.x, this->treasurePos.y, this->treasurePos.z,\\n                           0, 0, 0, ITEM00_HEART_PIECE);\\n            }\\n            break;\\n            \\n        case 2: // Opened state\\n            break;\\n    }\\n}\\n\\nconst ActorProfile EnTreasure_Profile = {\\n    /**/ ACTOR_EN_TREASURE,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_NONE,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnTreasure),\\n    /**/ EnTreasure_Init,\\n    /**/ EnTreasure_Destroy,\\n    /**/ EnTreasure_Update,\\n    /**/ EnTreasure_Draw\\n};"}
{"instruction": "Create a debug helper actor that displays collision info and spawns rupees at test points", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 debugState;\n    /* 0x0150 */ f32 testRadius;\n    /* 0x0154 */ Vec3f testPoints[4];\n    /* 0x0184 */ ColliderCylinder collider;\n} EnDbgHelper; // size = 0x1D0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnDbgHelper_Init(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->timer = 0;\n    this->debugState = 0;\n    this->testRadius = 100.0f;\n    \n    // Initialize test points in a square pattern\n    for (s32 i = 0; i < 4; i++) {\n        f32 angle = i * (M_PI / 2);\n        this->testPoints[i].x = Math_CosS(angle) * this->testRadius;\n        this->testPoints[i].y = 0.0f;\n        this->testPoints[i].z = Math_SinS(angle) * this->testRadius;\n    }\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnDbgHelper_Update(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    \n    this->timer++;\n    \n    // Update collision detection\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Spawn test rupees every 60 frames\n    if (this->timer >= 60) {\n        this->timer = 0;\n        \n        for (s32 i = 0; i < 4; i++) {\n            Vec3f spawnPos;\n            spawnPos.x = this->actor.world.pos.x + this->testPoints[i].x;\n            spawnPos.y = this->actor.world.pos.y + this->testPoints[i].y;\n            spawnPos.z = this->actor.world.pos.z + this->testPoints[i].z;\n            \n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       spawnPos.x, spawnPos.y, spawnPos.z,\n                       0, 0, 0, ITEM00_RUPEE_BLUE);\n        }\n    }\n    \n    // Face player if nearby\n    if (Actor_WorldDistXYZToActor(&this->actor, &GET_PLAYER(play)->actor) < 100.0f) {\n        Actor_WorldYawTowardPoint(&this->actor, &GET_PLAYER(play)->actor.world.pos);\n    }\n}\n\nconst ActorProfile EnDbgHelper_Profile = {\n    /**/ ACTOR_EN_DBG_HELPER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnDbgHelper),\n    /**/ EnDbgHelper_Init,\n    /**/ Actor_Destroy,\n    /**/ EnDbgHelper_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, plays a sound, and despawns with a particle effect", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnHeartStatue; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 25, 60, 0, { 0, 0, 0 } },\n};\n\nvoid EnHeartStatue_Init(Actor* thisx, PlayState* play) {\n    EnHeartStatue* this = (EnHeartStatue*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.focus.pos = this->actor.world.pos;\n    this->actor.focus.pos.y += 50.0f;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actionState = 0;\n    this->timer = 0;\n    this->scale = 1.0f;\n}\n\nvoid EnHeartStatue_Destroy(Actor* thisx, PlayState* play) {\n    EnHeartStatue* this = (EnHeartStatue*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnHeartStatue_Update(Actor* thisx, PlayState* play) {\n    EnHeartStatue* this = (EnHeartStatue*)thisx;\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        Vec3f spawnPos;\n        spawnPos.x = this->actor.world.pos.x;\n        spawnPos.y = this->actor.world.pos.y + 40.0f;\n        spawnPos.z = this->actor.world.pos.z;\n        \n        // Spawn heart piece using authentic EnItem00\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   spawnPos.x, spawnPos.y, spawnPos.z,\n                   0, 0, 0, ITEM00_HEART_PIECE);\n                   \n        Actor_PlaySfx(&this->actor, NA_SE_EV_HEART_OF_GROTTO_APPEAR);\n        Actor_Kill(&this->actor);\n        return;\n    }\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnHeartStatue_Draw(Actor* thisx, PlayState* play) {\n    EnHeartStatue* this = (EnHeartStatue*)thisx;\n    \n    Matrix_Push();\n    Matrix_Scale(this->scale, this->scale, this->scale, MTXMODE_APPLY);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, \\"}
{"instruction": "Create a simple actor that spawns a heart piece when hit by the player's sword, plays a sound effect, and disappears", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 hitCount;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ ColliderCylinder collider;\n} EnBreakHeart; // size = 0x19C\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnBreakHeart_Init(Actor* thisx, PlayState* play) {\n    EnBreakHeart* this = (EnBreakHeart*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->hitCount = 0;\n    this->actionState = 0;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.colChkInfo.mass = 0xFF;\n}\n\nvoid EnBreakHeart_Update(Actor* thisx, PlayState* play) {\n    EnBreakHeart* this = (EnBreakHeart*)thisx;\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    if (this->collider.base.acFlags & AC_HIT) {\n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\n        \n        // Spawn heart piece at actor's position\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   this->actor.world.pos.x,\n                   this->actor.world.pos.y,\n                   this->actor.world.pos.z,\n                   0, 0, 0, ITEM00_HEART_PIECE);\n                   \n        Actor_Kill(&this->actor);\n    }\n}\n\nconst ActorProfile EnBreakHeart_Profile = {\n    /**/ ACTOR_EN_BREAK_HEART,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnBreakHeart),\n    /**/ EnBreakHeart_Init,\n    /**/ Actor_Destroy,\n    /**/ EnBreakHeart_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Implement a treasure chest actor that spawns a heart piece when opened, with proper collision detection, player interaction, and sound effects. The chest should only open when approached from the front.", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 openAngle;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 lidRotation;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnTreasure; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_WOOD,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnTreasure_Init(Actor* thisx, PlayState* play) {\\n    EnTreasure* this = (EnTreasure*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actionState = 0;\\n    this->lidRotation = 0.0f;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnTreasure_Update(Actor* thisx, PlayState* play) {\\n    EnTreasure* this = (EnTreasure*)thisx;\\n    Player* player = GET_PLAYER(play);\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    switch(this->actionState) {\\n        case 0: // Waiting for player\\n            if (Actor_WorldDistXYZToActor(&player->actor, &this->actor) < 100.0f &&\\n                Player_IsFacingActor(&this->actor, player, 0x2000)) {\\n                \\n                this->actionState = 1;\\n                Actor_PlaySfx(&this->actor, NA_SE_EV_TREASURE_OPEN);\\n            }\\n            break;\\n            \\n        case 1: // Opening animation\\n            this->lidRotation += 0.1f;\\n            if (this->lidRotation >= M_PI / 2) {\\n                Vec3f spawnPos;\\n                spawnPos.x = this->actor.world.pos.x;\\n                spawnPos.y = this->actor.world.pos.y + 40.0f;\\n                spawnPos.z = this->actor.world.pos.z;\\n                \\n                Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                           spawnPos.x, spawnPos.y, spawnPos.z,\\n                           0, 0, 0, ITEM00_HEART_PIECE);\\n                \\n                this->actionState = 2;\\n            }\\n            break;\\n            \\n        case 2: // Opened state\\n            break;\\n    }\\n}\\n\\nconst ActorProfile EnTreasure_Profile = {\\n    /**/ ACTOR_EN_TREASURE,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_NONE,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnTreasure),\\n    /**/ EnTreasure_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnTreasure_Update,\\n    /**/ NULL,\\n};"}
{"instruction": "Create a debug actor that displays collision radius and plays a sound when player is within range", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 debugTimer;\n    /* 0x014E */ s16 soundTimer;\n    /* 0x0150 */ f32 detectionRange;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnDbgHelp; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnDbgHelp_Init(Actor* thisx, PlayState* play) {\n    EnDbgHelp* this = (EnDbgHelp*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->detectionRange = 100.0f;\n    this->debugTimer = 0;\n    this->soundTimer = 0;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.targetMode = 0;\n}\n\nvoid EnDbgHelp_Update(Actor* thisx, PlayState* play) {\n    EnDbgHelp* this = (EnDbgHelp*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->debugTimer++;\n    \n    if (this->soundTimer > 0) {\n        this->soundTimer--;\n    }\n    \n    f32 playerDist = Actor_WorldDistXYZToActor(&this->actor, &player->actor);\n    \n    if (playerDist < this->detectionRange) {\n        if (this->soundTimer == 0) {\n            Actor_PlaySfx(&this->actor, NA_SE_SY_CORRECT_CHIME);\n            this->soundTimer = 20;\n        }\n    }\n    \n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Update position and ground info\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 0.0f, BGCHECKFLAG_GROUND);\n}\n\nvoid EnDbgHelp_Draw(Actor* thisx, PlayState* play) {\n    EnDbgHelp* this = (EnDbgHelp*)thisx;\n    \n    Matrix_Push();\n    Matrix_Scale(this->detectionRange/100.0f, 1.0f, this->detectionRange/100.0f, MTXMODE_APPLY);\n    Matrix_RotateY(BINANG_TO_RAD(this->actor.world.rot.y), MTXMODE_APPLY);\n    \n    // Draw debug visuals using authentic functions\n    func_80093D84(play->state.gfxCtx);\n    Matrix_Pop();\n}\n\nconst ActorProfile EnDbgHelp_Profile = {\n    /**/ ACTOR_EN_DBG_HELP,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnDbgHelp),\n    /**/ EnDbgHelp_Init,\n    /**/ Actor_Destroy,\n    /**/ EnDbgHelp_Update, \n    /**/ EnDbgHelp_Draw\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, plays a sound effect, and despawns with a particle effect", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnHeartSpawner; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 15, 25, 0, { 0, 0, 0 } },\n};\n\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.colChkInfo.mass = 0xFF;\n    Actor_SetFocus(&this->actor, 20.0f);\n    \n    this->timer = 0;\n    this->actionState = 0;\n    this->scale = 1.0f;\n}\n\nvoid EnHeartSpawner_Destroy(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        Actor_PlaySfx(&this->actor, NA_SE_EV_PIECE_OF_HEART);\n        \n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   this->actor.world.pos.x,\n                   this->actor.world.pos.y,\n                   this->actor.world.pos.z,\n                   0, 0, 0, ITEM00_HEART_PIECE);\n                   \n        Actor_Kill(&this->actor);\n    }\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n}\n\nvoid EnHeartSpawner_Draw(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Matrix_Push();\n    Matrix_Scale(this->scale, this->scale, this->scale, MTXMODE_APPLY);\n    Matrix_Pop();\n}\n\nconst ActorProfile EnHeartSpawner_Profile = {\n    /**/ ACTOR_EN_HEART_SPAWNER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnHeartSpawner),\n    /**/ EnHeartSpawner_Init,\n    /**/ EnHeartSpawner_Destroy,\n    /**/ EnHeartSpawner_Update,\n    /**/ EnHeartSpawner_Draw\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, plays a sound effect, and disappears with a particle effect", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ ColliderCylinder collider;\n} EnBreakable; // size = 0x19C\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_WOOD,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_WOOD,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 40, 0, { 0, 0, 0 } },\n};\n\nvoid EnBreakable_Init(Actor* thisx, PlayState* play) {\n    EnBreakable* this = (EnBreakable*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.colChkInfo.mass = 0xFF;\n    this->actionState = 0;\n}\n\nvoid EnBreakable_Update(Actor* thisx, PlayState* play) {\n    EnBreakable* this = (EnBreakable*)thisx;\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        // Spawn heart piece using authentic EnItem00 pattern\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   this->actor.world.pos.x,\n                   this->actor.world.pos.y,\n                   this->actor.world.pos.z,\n                   0, 0, 0, ITEM00_HEART_PIECE);\n                   \n        // Play break sound using authentic function\n        Actor_PlaySfx(&this->actor, NA_SE_IT_WOOD_BOX_BREAK);\n        \n        // Spawn effect particles\n        EffectSsHahen_SpawnBurst(play, &this->actor.world.pos, \n                                3.0f, 0, 12, 3, 15, HAHEN_OBJECT_DEFAULT, 10, NULL);\n                                \n        Actor_Kill(&this->actor);\n        return;\n    }\n    \n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile EnBreakable_Profile = {\n    /**/ ACTOR_EN_BREAKABLE,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnBreakable),\n    /**/ EnBreakable_Init,\n    /**/ Actor_Destroy,\n    /**/ EnBreakable_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Implement a crystal switch actor that toggles between blue/red states, spawns rupees when hit, and has proper collision detection. Must follow OoT patterns exactly.", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 switchState;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n    /* 0x01A0 */ LightNode* lightNode;\n    /* 0x01A4 */ Color_RGBA8 lightColor;\n} EnCrystalSwitch; // size = 0x1A8\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x08000000, HIT_BACKLASH_NONE, 0x01 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnCrystalSwitch_Init(Actor* thisx, PlayState* play) {\n    EnCrystalSwitch* this = (EnCrystalSwitch*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.1f);\n    this->switchState = 0;\n    this->timer = 0;\n    \n    this->lightNode = LightContext_InsertLight(play, &play->lightCtx, &this->lightColor);\n    this->lightColor.r = 0;\n    this->lightColor.g = 0;\n    this->lightColor.b = 255;\n    this->lightColor.a = 255;\n}\n\nvoid EnCrystalSwitch_Update(Actor* thisx, PlayState* play) {\n    EnCrystalSwitch* this = (EnCrystalSwitch*)thisx;\n    Vec3f spawnPos;\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        this->switchState ^= 1;\n        Actor_PlaySfx(&this->actor, NA_SE_SY_CORRECT_CHIME);\n        \n        // Spawn rupee using authentic EnItem00 pattern\n        spawnPos = this->actor.world.pos;\n        spawnPos.y += 40.0f;\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   spawnPos.x, spawnPos.y, spawnPos.z,\n                   0, 0, 0, ITEM00_RUPEE_BLUE);\n                   \n        this->timer = 20;\n        \n        // Update light color\n        this->lightColor.r = this->switchState ? 255 : 0;\n        this->lightColor.b = this->switchState ? 0 : 255;\n    }\n    \n    if (this->timer > 0) {\n        this->timer--;\n        Actor_SetScale(&this->actor, 0.1f + Math_SinS(this->timer * 0x1000) * 0.02f);\n    }\n}\n\nconst ActorProfile EnCrystalSwitch_Profile = {\n    /**/ ACTOR_EN_CRYSTAL_SWITCH,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnCrystalSwitch),\n    /**/ EnCrystalSwitch_Init,\n    /**/ EnCrystalSwitch_Destroy,\n    /**/ EnCrystalSwitch_Update,\n    /**/ EnCrystalSwitch_Draw,\n};\n```"}
{"instruction": "Create a debugging helper actor that displays collision cylinder visualization and prints actor state info to the screen when activated", "output": "// Authentic pattern following z_actor.c and z_collision_check.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 debugState;\\n    /* 0x014E */ s16 timer;\\n    /* 0x0150 */ f32 debugRadius;\\n    /* 0x154 */ ColliderCylinder collider;\\n} EnDebugHelp; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnDebugHelp_Init(Actor* thisx, PlayState* play) {\\n    EnDebugHelp* this = (EnDebugHelp*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->debugState = 0;\\n    this->timer = 0;\\n    this->debugRadius = 30.0f;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actor.targetMode = 0;\\n}\\n\\nvoid EnDebugHelp_Update(Actor* thisx, PlayState* play) {\\n    EnDebugHelp* this = (EnDebugHelp*)thisx;\\n    \\n    this->timer++;\\n    \\n    if (Actor_WorldDistXYZToActor(&play->actorCtx.targetCtx.actor, &this->actor) < 100.0f) {\\n        if (this->debugState == 0) {\\n            Actor_PlaySfx(&this->actor, NA_SE_SY_CORRECT_CHIME);\\n            this->debugState = 1;\\n        }\\n        \\n        // Update collision visualization\\n        Collider_UpdateCylinder(&this->actor, &this->collider);\\n        CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n        \\n        // Print debug info when active\\n        if (this->debugState == 1) {\\n            Matrix_Push();\\n            Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z, MTXMODE_NEW);\\n            Matrix_Scale(1.0f, 1.0f, 1.0f, MTXMODE_APPLY);\\n            Matrix_Pop();\\n        }\\n    } else {\\n        this->debugState = 0;\\n    }\\n}\\n\\nconst ActorProfile EnDebugHelp_Profile = {\\n    /**/ ACTOR_EN_DEBUGHELP,\\n    /**/ ACTORCAT_MISC,\\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnDebugHelp),\\n    /**/ EnDebugHelp_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnDebugHelp_Update,\\n    /**/ NULL,\\n};"}
{"instruction": "Create an actor that spawns a sequence of collectible rupees in a spiral pattern when triggered, with proper collision detection and player interaction", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 spawnCount;\n    /* 0x0150 */ f32 radius;\n    /* 0x0154 */ f32 angleStep;\n    /* 0x0158 */ ColliderCylinder collider;\n} EnRupeeSpawner; // size = 0x1A4\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnRupeeSpawner_Init(Actor* thisx, PlayState* play) {\n    EnRupeeSpawner* this = (EnRupeeSpawner*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->timer = 0;\n    this->spawnCount = 0;\n    this->radius = 50.0f;\n    this->angleStep = (M_PI * 2) / 8;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    Actor_SetFocus(&this->actor, 20.0f);\n    \n    this->actor.flags |= ACTOR_FLAG_4;\n    this->actor.flags |= ACTOR_FLAG_25;\n}\n\nvoid EnRupeeSpawner_Destroy(Actor* thisx, PlayState* play) {\n    EnRupeeSpawner* this = (EnRupeeSpawner*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnRupeeSpawner_Update(Actor* thisx, PlayState* play) {\n    EnRupeeSpawner* this = (EnRupeeSpawner*)thisx;\n    Vec3f spawnPos;\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (this->timer > 0) {\n        this->timer--;\n        if (this->timer == 0 && this->spawnCount < 8) {\n            f32 angle = this->spawnCount * this->angleStep;\n            spawnPos.x = this->actor.world.pos.x + Math_SinS(angle) * this->radius;\n            spawnPos.y = this->actor.world.pos.y + 50.0f;\n            spawnPos.z = this->actor.world.pos.z + Math_CosS(angle) * this->radius;\n            \n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       spawnPos.x, spawnPos.y, spawnPos.z,\n                       0, 0, 0, ITEM00_RUPEE_BLUE);\n            \n            this->spawnCount++;\n            this->timer = 8;\n        }\n    }\n    \n    if (Actor_HasParent(&this->actor, play)) {\n        if (this->timer == 0 && this->spawnCount == 0) {\n            this->timer = 8;\n            Actor_PlaySfx(&this->actor, NA_SE_EV_ACTIVATE_SWITCH);\n        }\n    } else if (this->actor.xzDistToPlayer < 50.0f) {\n        func_8002F580(&this->actor, play);\n    }\n}\n\nconst ActorProfile EnRupeeSpawner_Profile = {\n    /**/ ACTOR_EN_RUPEE_SPAWNER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnRupeeSpawner),\n    /**/ EnRupeeSpawner_Init,\n    /**/ EnRupeeSpawner_Destroy,\n    /**/ EnRupeeSpawner_Update,\n    /**/ NULL\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword and plays a sound effect", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 hitCount;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 hitTimer;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnHeartSpawner; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->hitCount = 0;\n    this->actionState = 0;\n    this->hitTimer = 0.0f;\n    \n    this->actor.targetMode = 0;\n    this->actor.colChkInfo.mass = 0xFF;\n}\n\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    if (this->hitTimer > 0.0f) {\n        this->hitTimer -= 1.0f;\n    }\n\n    if ((this->collider.base.acFlags & AC_HIT) && this->hitTimer <= 0.0f) {\n        this->hitCount++;\n        this->hitTimer = 10.0f;\n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\n        \n        if (this->hitCount >= 3) {\n            Vec3f spawnPos;\n            spawnPos.x = this->actor.world.pos.x;\n            spawnPos.y = this->actor.world.pos.y + 40.0f;\n            spawnPos.z = this->actor.world.pos.z;\n            \n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       spawnPos.x, spawnPos.y, spawnPos.z,\n                       0, 0, 0, ITEM00_HEART_PIECE);\n                       \n            Actor_Kill(&this->actor);\n            return;\n        }\n    }\n\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile EnHeartSpawner_Profile = {\n    /**/ ACTOR_EN_HEART_SPAWNER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnHeartSpawner),\n    /**/ EnHeartSpawner_Init,\n    /**/ Actor_Destroy,\n    /**/ EnHeartSpawner_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Implement a treasure chest actor that spawns a heart piece when opened, plays a fanfare, and has collision detection. The chest should only open when approached from the front.", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 openAngle;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 lidRotation;\\n    /* 0x0154 */ ColliderCylinder collider;\\n    /* 0x01A0 */ s16 timer;\\n} EnTreasure; // size = 0x1A2\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnTreasure_Init(Actor* thisx, PlayState* play) {\\n    EnTreasure* this = (EnTreasure*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actionState = 0;\\n    this->lidRotation = 0.0f;\\n    this->timer = 0;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnTreasure_Update(Actor* thisx, PlayState* play) {\\n    EnTreasure* this = (EnTreasure*)thisx;\\n    Player* player = GET_PLAYER(play);\\n    Vec3f spawnPos;\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    switch(this->actionState) {\\n        case 0: // Waiting for player\\n            if (Actor_WorldDistXYZToActor(&player->actor, &this->actor) < 100.0f &&\\n                Player_IsFacingActor(&this->actor, player, 0x2000)) {\\n                this->actionState = 1;\\n                Actor_PlaySfx(&this->actor, NA_SE_EV_TREASURE_OPEN);\\n            }\\n            break;\\n            \\n        case 1: // Opening animation\\n            this->lidRotation += 0.1f;\\n            if (this->lidRotation >= M_PI / 2) {\\n                this->lidRotation = M_PI / 2;\\n                this->actionState = 2;\\n                this->timer = 20;\\n                \\n                // Spawn heart piece above chest\\n                spawnPos.x = this->actor.world.pos.x;\\n                spawnPos.y = this->actor.world.pos.y + 40.0f;\\n                spawnPos.z = this->actor.world.pos.z;\\n                \\n                Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                          spawnPos.x, spawnPos.y, spawnPos.z,\\n                          0, 0, 0, ITEM00_HEART_PIECE);\\n                \\n                Actor_PlaySfx(&this->actor, NA_SE_EV_GET_ITEM);\\n            }\\n            break;\\n            \\n        case 2: // Delay before removing\\n            this->timer--;\\n            if (this->timer <= 0) {\\n                Actor_Kill(&this->actor);\\n            }\\n            break;\\n    }\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\\n}\\n\\nconst ActorProfile EnTreasure_Profile = {\\n    /**/ ACTOR_EN_TREASURE,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_NONE,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnTreasure),\\n    /**/ EnTreasure_Init,\\n    /**/ EnTreasure_Destroy,\\n    /**/ EnTreasure_Update,\\n    /**/ EnTreasure_Draw\\n};"}
{"instruction": "Create a debug actor that displays collision info and spawns a heart piece when triggered", "output": "`\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 debugState;\n    /* 0x0150 */ f32 detectionRange;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnDbgHelp; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000010, 0x00, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 45, 0, { 0, 0, 0 } },\n};\n\nvoid EnDbgHelp_Init(Actor* thisx, PlayState* play) {\n    EnDbgHelp* this = (EnDbgHelp*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->detectionRange = 100.0f;\n    this->debugState = 0;\n    this->timer = 0;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.targetMode = 0;\n    this->actor.flags |= ACTOR_FLAG_0;\n}\n\nvoid EnDbgHelp_Update(Actor* thisx, PlayState* play) {\n    EnDbgHelp* this = (EnDbgHelp*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    if (Actor_WorldDistXYZToActor(&player->actor, &this->actor) < this->detectionRange) {\n        if (this->debugState == 0) {\n            // Spawn heart piece using authentic EnItem00 pattern\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       this->actor.world.pos.x,\n                       this->actor.world.pos.y + 40.0f,\n                       this->actor.world.pos.z,\n                       0, 0, 0, ITEM00_HEART_PIECE);\n            this->debugState = 1;\n        }\n    }\n    \n    // Authentic collision update pattern\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    func_8002F974(&this->actor, NA_SE_PL_BOUND_NOWEAPON);\n}\n\nconst ActorProfile En_DbgHelp_InitVars = {\n    /**/ ACTOR_EN_DBGHELP,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnDbgHelp),\n    /**/ EnDbgHelp_Init,\n    /**/ EnDbgHelp_Destroy,\n    /**/ EnDbgHelp_Update,\n    /**/ NULL\n};`\n}"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, plays a sound effect, and despawns with a particle effect", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnHeartSpawner; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 15, 25, 0, { 0, 0, 0 } },\n};\n\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.colChkInfo.mass = 0xFF;\n    Actor_SetFocus(&this->actor, 20.0f);\n    \n    this->timer = 0;\n    this->actionState = 0;\n    this->scale = 1.0f;\n}\n\nvoid EnHeartSpawner_Destroy(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 26.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        Actor_PlaySfx(&this->actor, NA_SE_EN_ITEM_PIECE_OF_HEART);\n        \n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   this->actor.world.pos.x,\n                   this->actor.world.pos.y,\n                   this->actor.world.pos.z,\n                   0, 0, 0, ITEM00_HEART_PIECE);\n                   \n        Actor_Kill(&this->actor);\n    }\n}\n\nvoid EnHeartSpawner_Draw(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Matrix_Push();\n    Matrix_Scale(this->scale, this->scale, this->scale, MTXMODE_APPLY);\n    Matrix_Pop();\n}\n\nconst ActorProfile EnHeartSpawner_Profile = {\n    /**/ ACTOR_EN_HEART_SPAWNER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnHeartSpawner),\n    /**/ EnHeartSpawner_Init,\n    /**/ EnHeartSpawner_Destroy, \n    /**/ EnHeartSpawner_Update,\n    /**/ EnHeartSpawner_Draw\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, plays a sound effect, and then disappears with a sparkle effect", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x19C\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actionState = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        // Spawn heart piece using authentic EnItem00 pattern\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                   this->actor.world.pos.x,\\n                   this->actor.world.pos.y,\\n                   this->actor.world.pos.z,\\n                   0, 0, 0, ITEM00_HEART_PIECE);\\n        \\n        Actor_PlaySfx(&this->actor, NA_SE_IT_HEART_GET);\\n        Actor_Kill(&this->actor);\\n    }\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_MISC,\\n    /**/ FLAGS,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ EnHeartSpawner_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL,\\n};"}
{"instruction": "Implement a magical crystal actor that spins in place, detects player proximity, and spawns a heart piece when hit with an arrow. It should use proper collision detection and particle effects.", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 spinAngle;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 detectionRange;\\n    /* 0x0154 */ f32 glowIntensity;\\n    /* 0x0158 */ ColliderCylinder collider;\\n} EnMagicCrystal; // size = 0x1A4\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000020, HIT_ARROW, 0x01 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 40, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnMagicCrystal_Init(Actor* thisx, PlayState* play) {\\n    EnMagicCrystal* this = (EnMagicCrystal*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.02f);\\n    this->spinAngle = 0;\\n    this->actionState = 0;\\n    this->detectionRange = 200.0f;\\n    this->glowIntensity = 0.0f;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnMagicCrystal_Update(Actor* thisx, PlayState* play) {\\n    EnMagicCrystal* this = (EnMagicCrystal*)thisx;\\n    Player* player = GET_PLAYER(play);\\n    \\n    this->spinAngle += 0x0200;\\n    this->actor.world.rot.y = this->spinAngle;\\n    \\n    if (Actor_WorldDistXYZToActor(&player->actor, &this->actor) < this->detectionRange) {\\n        this->glowIntensity = Math_CosS(this->spinAngle) * 0.5f + 0.5f;\\n        \\n        if (this->collider.base.acFlags & AC_HIT) {\\n            Vec3f spawnPos;\\n            spawnPos.x = this->actor.world.pos.x;\\n            spawnPos.y = this->actor.world.pos.y + 40.0f;\\n            spawnPos.z = this->actor.world.pos.z;\\n            \\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, 0, 0, ITEM00_HEART_PIECE);\\n            \\n            Actor_PlaySfx(&this->actor, NA_SE_EV_CRYSTAL_BROKEN);\\n            Actor_Kill(&this->actor);\\n            return;\\n        }\\n    }\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnMagicCrystal_Profile = {\\n    /**/ ACTOR_MAGIC_CRYSTAL,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnMagicCrystal),\\n    /**/ EnMagicCrystal_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnMagicCrystal_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create a debugging helper actor that spawns a blue rupee when Link gets close and displays debug text showing distance", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 debugState;\\n    /* 0x0150 */ f32 detectionRange;\\n    /* 0x154 */ ColliderCylinder collider;\\n} EnDbgHelper; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 15, 25, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnDbgHelper_Init(Actor* thisx, PlayState* play) {\\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->detectionRange = 150.0f;\\n    this->debugState = 0;\\n    this->timer = 0;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n}\\n\\nvoid EnDbgHelper_Update(Actor* thisx, PlayState* play) {\\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\\n    Player* player = GET_PLAYER(play);\\n    f32 dist;\\n    \\n    dist = Actor_WorldDistXYZToActor(&this->actor, &player->actor);\\n    \\n    // Update collision\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (dist < this->detectionRange && this->debugState == 0) {\\n        Vec3f spawnPos;\\n        spawnPos.x = this->actor.world.pos.x;\\n        spawnPos.y = this->actor.world.pos.y + 40.0f;\\n        spawnPos.z = this->actor.world.pos.z;\\n        \\n        // Spawn blue rupee using authentic EnItem00 pattern\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_RUPEE_BLUE);\\n                    \\n        this->debugState = 1;\\n    }\\n    \\n    // Display debug distance text\\n    Gfx_DrawDebugText(play, \\"}
{"instruction": "Create an actor that spawns a heart piece when hit, plays a sound, and despawns with a particle effect", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 hitCount;\\n    /* 0x0150 */ f32 scale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->timer = 0;\\n    this->hitCount = 0;\\n    this->scale = 1.0f;\\n    \\n    this->actor.flags |= ACTOR_FLAG_4;\\n    this->actor.targetMode = 3;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    this->timer++;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitCount++;\\n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\\n        \\n        if (this->hitCount >= 3) {\\n            Vec3f spawnPos;\\n            spawnPos.x = this->actor.world.pos.x;\\n            spawnPos.y = this->actor.world.pos.y;\\n            spawnPos.z = this->actor.world.pos.z;\\n            \\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                spawnPos.x, spawnPos.y, spawnPos.z,\\n                0, 0, 0, ITEM00_HEART_PIECE);\\n                \\n            Actor_Kill(&this->actor);\\n            return;\\n        }\\n    }\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ EnHeartSpawner_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ EnHeartSpawner_Draw,\\n};"}
{"instruction": "Create a simple enemy actor that patrols in a circle pattern and drops a blue rupee when defeated. The actor should have basic collision detection and play sound effects when hit.", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 radius;\\n    /* 0x0154 */ f32 angleVel;\\n    /* 0x0158 */ f32 baseY;\\n    /* 0x015C */ ColliderCylinder collider;\\n} EnPatrol; // size = 0x1A8\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnPatrol_Init(Actor* thisx, PlayState* play) {\\n    EnPatrol* this = (EnPatrol*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->radius = 100.0f;\\n    this->angleVel = 0.05f;\\n    this->baseY = this->actor.world.pos.y;\\n    this->actionState = 0;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnPatrol_Update(Actor* thisx, PlayState* play) {\\n    EnPatrol* this = (EnPatrol*)thisx;\\n    \\n    this->timer++;\\n    \\n    if (this->actionState == 0) {\\n        // Circular patrol movement\\n        this->actor.world.pos.x = Math_SinS(this->timer * 0x200) * this->radius + this->actor.home.pos.x;\\n        this->actor.world.pos.z = Math_CosS(this->timer * 0x200) * this->radius + this->actor.home.pos.z;\\n        \\n        if (this->collider.base.acFlags & AC_HIT) {\\n            Actor_PlaySfx(&this->actor, NA_SE_EN_DODO_M_GND);\\n            this->actionState = 1;\\n        }\\n    } else {\\n        // Death sequence\\n        if (this->timer > 10) {\\n            Vec3f pos = this->actor.world.pos;\\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       pos.x, pos.y, pos.z, 0, 0, 0, ITEM00_RUPEE_BLUE);\\n            Actor_Kill(&this->actor);\\n        }\\n    }\\n    \\n    // Update collision\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnPatrol_Profile = {\\n    /**/ ACTOR_EN_PATROL,\\n    /**/ ACTORCAT_ENEMY,\\n    /**/ FLAGS,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnPatrol),\\n    /**/ EnPatrol_Init,\\n    /**/ EnPatrol_Destroy,\\n    /**/ EnPatrol_Update,\\n    /**/ EnPatrol_Draw\\n};"}
{"instruction": "Implement a treasure chest actor that spawns a heart piece when opened, plays authentic sound effects, and handles collision detection with the player", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 openAngle;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 lidRotation;\\n    /* 0x0154 */ ColliderCylinder collider;\\n    /* 0x01A0 */ s16 timer;\\n} EnTreasure; // size = 0x1A4\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_WOOD,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_WOOD,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 30, 40, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnTreasure_Init(Actor* thisx, PlayState* play) {\\n    EnTreasure* this = (EnTreasure*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    \\n    this->actionState = 0;\\n    this->openAngle = 0;\\n    this->timer = 0;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnTreasure_Update(Actor* thisx, PlayState* play) {\\n    EnTreasure* this = (EnTreasure*)thisx;\\n    Player* player = GET_PLAYER(play);\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    switch(this->actionState) {\\n        case 0: // Waiting for player interaction\\n            if (Actor_WorldDistXYZToActor(&player->actor, &this->actor) < 50.0f &&\\n                Player_IsFacingActor(&this->actor, player, 0x2000)) {\\n                \\n                Actor_PlaySfx(&this->actor, NA_SE_EV_TREASURE_OPEN);\\n                this->actionState = 1;\\n                this->timer = 30;\\n            }\\n            break;\\n            \\n        case 1: // Opening animation\\n            this->openAngle += 0x200;\\n            if (this->timer == 0) {\\n                Vec3f spawnPos;\\n                spawnPos.x = this->actor.world.pos.x;\\n                spawnPos.y = this->actor.world.pos.y + 40.0f;\\n                spawnPos.z = this->actor.world.pos.z;\\n                \\n                Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                           spawnPos.x, spawnPos.y, spawnPos.z,\\n                           0, 0, 0, ITEM00_HEART_PIECE);\\n                           \\n                this->actionState = 2;\\n            } else {\\n                this->timer--;\\n            }\\n            break;\\n            \\n        case 2: // Opened state\\n            break;\\n    }\\n}\\n\\nconst ActorProfile EnTreasure_Profile = {\\n    /**/ ACTOR_EN_TREASURE,\\n    /**/ ACTORCAT_CHEST,\\n    /**/ FLAGS_NONE,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnTreasure),\\n    /**/ EnTreasure_Init,\\n    /**/ EnTreasure_Destroy,\\n    /**/ EnTreasure_Update,\\n    /**/ EnTreasure_Draw\\n};"}
{"instruction": "Create a debugging helper actor that displays collision boundaries and spawns rupees at test points", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 debugState;\n    /* 0x0150 */ f32 testRadius;\n    /* 0x0154 */ Vec3f testPoints[4];\n    /* 0x0184 */ ColliderCylinder collider;\n} EnDbgHelper; // size = 0x1D0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 45, 0, { 0, 0, 0 } },\n};\n\nvoid EnDbgHelper_Init(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    s32 i;\n\n    Actor_SetScale(&this->actor, 0.01f);\n    this->testRadius = 100.0f;\n    this->debugState = 0;\n    \n    for (i = 0; i < 4; i++) {\n        this->testPoints[i].x = Math_SinS(i * 0x4000) * this->testRadius;\n        this->testPoints[i].y = 80.0f;\n        this->testPoints[i].z = Math_CosS(i * 0x4000) * this->testRadius;\n    }\n\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n}\n\nvoid EnDbgHelper_Destroy(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnDbgHelper_Update(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    s32 i;\n    Vec3f spawnPos;\n\n    this->timer++;\n    \n    if (this->timer > 60) {\n        this->timer = 0;\n        \n        // Spawn test rupees at points\n        for (i = 0; i < 4; i++) {\n            spawnPos.x = this->actor.world.pos.x + this->testPoints[i].x;\n            spawnPos.y = this->actor.world.pos.y + this->testPoints[i].y;\n            spawnPos.z = this->actor.world.pos.z + this->testPoints[i].z;\n            \n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       spawnPos.x, spawnPos.y, spawnPos.z,\n                       0, 0, 0, ITEM00_RUPEE_BLUE);\n        }\n    }\n\n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnDbgHelper_Draw(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    \n    Matrix_Push();\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, this->actor.scale.z, MTXMODE_APPLY);\n    Matrix_Pop();\n}\n\nconst ActorProfile En_DbgHelper_InitVars = {\n    /**/ ACTOR_EN_DBG_HELPER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnDbgHelper),\n    /**/ EnDbgHelper_Init,\n    /**/ EnDbgHelper_Destroy,\n    /**/ EnDbgHelper_Update,\n    /**/ EnDbgHelper_Draw\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, plays a sound, and disappears in a flash of light", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnHeartStatue; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_WOOD,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 40, 0, { 0, 0, 0 } },\n};\n\nvoid EnHeartStatue_Init(Actor* thisx, PlayState* play) {\n    EnHeartStatue* this = (EnHeartStatue*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\n    Actor_SetFocus(&this->actor, 20.0f);\n    \n    this->timer = 0;\n    this->actionState = 0;\n    this->scale = 1.0f;\n}\n\nvoid EnHeartStatue_Destroy(Actor* thisx, PlayState* play) {\n    EnHeartStatue* this = (EnHeartStatue*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnHeartStatue_Update(Actor* thisx, PlayState* play) {\n    EnHeartStatue* this = (EnHeartStatue*)thisx;\n    \n    if (this->actionState == 1) {\n        this->timer++;\n        if (this->timer > 10) {\n            Actor_Kill(&this->actor);\n            return;\n        }\n    }\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        Vec3f spawnPos;\n        spawnPos.x = this->actor.world.pos.x;\n        spawnPos.y = this->actor.world.pos.y + 40.0f;\n        spawnPos.z = this->actor.world.pos.z;\n        \n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   spawnPos.x, spawnPos.y, spawnPos.z,\n                   0, 0, 0, ITEM00_HEART_PIECE);\n                   \n        Actor_PlaySfx(&this->actor, NA_SE_EV_HEART_PIECE_APPEAR);\n        this->actionState = 1;\n        this->timer = 0;\n    }\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnHeartStatue_Draw(Actor* thisx, PlayState* play) {\n    EnHeartStatue* this = (EnHeartStatue*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx, \\"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, plays a sound effect, and disappears in a sparkle effect", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 hitCount;\n    /* 0x0150 */ ColliderCylinder collider;\n} EnBreakable; // size = 0x19C\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_WOOD,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_WOOD,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 40, 0, { 0, 0, 0 } },\n};\n\nvoid EnBreakable_Init(Actor* thisx, PlayState* play) {\n    EnBreakable* this = (EnBreakable*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->timer = 0;\n    this->hitCount = 0;\n    \n    Actor_SetFocus(&this->actor, 20.0f);\n}\n\nvoid EnBreakable_Update(Actor* thisx, PlayState* play) {\n    EnBreakable* this = (EnBreakable*)thisx;\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    if (this->collider.base.acFlags & AC_HIT) {\n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\n        this->hitCount++;\n        \n        if (this->hitCount >= 3) {\n            Vec3f pos;\n            pos.x = this->actor.world.pos.x;\n            pos.y = this->actor.world.pos.y;\n            pos.z = this->actor.world.pos.z;\n            \n            // Spawn heart piece using authentic EnItem00\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       pos.x, pos.y, pos.z, 0, 0, 0, ITEM00_HEART_PIECE);\n            \n            Actor_PlaySfx(&this->actor, NA_SE_EV_ITEM_GET_2);\n            Actor_Kill(&this->actor);\n        }\n    }\n}\n\nconst ActorProfile EnBreakable_Profile = {\n    /**/ ACTOR_EN_BREAKABLE,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnBreakable),\n    /**/ EnBreakable_Init,\n    /**/ Actor_Destroy,\n    /**/ EnBreakable_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Implement a crystal switch actor that toggles between red/blue states, spawns a blue rupee when hit in red state, and damages Link if touched while spinning. Must use authentic OoT patterns.", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 spinState;\n    /* 0x0150 */ f32 spinAngle;\n    /* 0x0154 */ f32 spinSpeed;\n    /* 0x0158 */ s16 switchFlag;\n    /* 0x015A */ s16 isRed;\n    /* 0x015C */ ColliderCylinder collider;\n} EnCrystalSwitch; // size = 0x1A8\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_ON | AT_TYPE_ENEMY,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x20000000, HIT_SPECIAL_EFFECT_NONE, 0x01 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_ON | ATELEM_ROLLBACK,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 40, 0, { 0, 0, 0 } },\n};\n\nvoid EnCrystalSwitch_Init(Actor* thisx, PlayState* play) {\n    EnCrystalSwitch* this = (EnCrystalSwitch*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.025f);\n    this->spinState = 0;\n    this->spinAngle = 0.0f;\n    this->spinSpeed = 0.0f;\n    this->isRed = true;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->switchFlag = (this->actor.params >> 8) & 0xFF;\n    Actor_SetFocus(&this->actor, 20.0f);\n}\n\nvoid EnCrystalSwitch_Update(Actor* thisx, PlayState* play) {\n    EnCrystalSwitch* this = (EnCrystalSwitch*)thisx;\n    Player* player = GET_PLAYER(play);\n    Vec3f spawnPos;\n    \n    if (this->spinState > 0) {\n        this->spinAngle += this->spinSpeed;\n        this->spinSpeed = Math_ApproachZeroF(this->spinSpeed, 0.2f, 1.0f);\n        this->spinState--;\n    }\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        this->collider.base.acFlags &= ~AC_HIT;\n        \n        if (this->isRed) {\n            this->isRed = false;\n            this->spinState = 20;\n            this->spinSpeed = 20.0f;\n            \n            spawnPos.x = this->actor.world.pos.x;\n            spawnPos.y = this->actor.world.pos.y + 40.0f;\n            spawnPos.z = this->actor.world.pos.z;\n            \n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       spawnPos.x, spawnPos.y, spawnPos.z,\n                       0, 0, 0, ITEM00_RUPEE_BLUE);\n                       \n            Actor_PlaySfx(&this->actor, NA_SE_EV_CRYSTAL_SWITCH);\n        }\n    }\n    \n    if (this->spinState > 0 && Actor_WorldDistXYZToActor(&this->actor, &player->actor) < 30.0f) {\n        func_8002F71C(play, &this->actor, 5.0f, this->actor.world.rot.y, 5.0f);\n    }\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile EnCrystalSwitch_Profile = {\n    /**/ ACTOR_EN_CRYSTAL_SWITCH,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnCrystalSwitch),\n    /**/ EnCrystalSwitch_Init,\n    /**/ EnCrystalSwitch_Destroy,\n    /**/ EnCrystalSwitch_Update,\n    /**/ EnCrystalSwitch_Draw\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when hit and plays a chime sound effect, using authentic OoT patterns", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 hitCount;\\n    /* 0x0150 */ f32 hitboxScale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->hitCount = 0;\\n    this->hitboxScale = 1.0f;\\n    this->timer = 0;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    this->timer++;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitCount++;\\n        Actor_PlaySfx(&this->actor, NA_SE_EV_HEART_OF_GROTTO_APPEAR);\\n        \\n        Vec3f spawnPos;\\n        spawnPos.x = this->actor.world.pos.x;\\n        spawnPos.y = this->actor.world.pos.y + 40.0f;\\n        spawnPos.z = this->actor.world.pos.z;\\n        \\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n                    \\n        Actor_Kill(&this->actor);\\n        return;\\n    }\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_NONE,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ EnHeartSpawner_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, plays a sound effect, and disappears with a particle effect", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ ColliderCylinder collider;\n} EnBreakable; // size = 0x19C\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_WOOD,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_WOOD,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 40, 0, { 0, 0, 0 } },\n};\n\nvoid EnBreakable_Init(Actor* thisx, PlayState* play) {\n    EnBreakable* this = (EnBreakable*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.colChkInfo.mass = 0xFF;\n    this->actionState = 0;\n}\n\nvoid EnBreakable_Update(Actor* thisx, PlayState* play) {\n    EnBreakable* this = (EnBreakable*)thisx;\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        // Spawn heart piece using authentic EnItem00 pattern\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   this->actor.world.pos.x,\n                   this->actor.world.pos.y,\n                   this->actor.world.pos.z,\n                   0, 0, 0, ITEM00_HEART_PIECE);\n                   \n        // Play break sound effect\n        Actor_PlaySfx(&this->actor, NA_SE_IT_WOOD_STICK_BREAK);\n        \n        // Spawn particles\n        EffectSsHahen_SpawnBurst(play, &this->actor.world.pos, \n                                3.0f, 0, 12, 3, 15, OBJECT_GAMEPLAY_KEEP, 10,\n                                gEffHahenWoodFragments);\n                                \n        Actor_Kill(&this->actor);\n        return;\n    }\n    \n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile EnBreakable_Profile = {\n    /**/ ACTOR_EN_BREAKABLE,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnBreakable),\n    /**/ EnBreakable_Init,\n    /**/ EnBreakable_Destroy,\n    /**/ EnBreakable_Update,\n    /**/ NULL\n};\n```"}
{"instruction": "Implement a crystal switch actor that toggles between blue/red states, spawns rupees when hit, and has proper collision detection with player attacks", "output": "// Crystal switch with collision, state toggle and rewards\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 switchState;\\n    /* 0x014E */ s16 timer;\\n    /* 0x0150 */ f32 scale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n    /* 0x01A0 */ LightNode* lightNode;\\n    /* 0x01A4 */ LightInfo lightInfo;\\n} EnCrystalSwitch; // size = 0x1B4\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_2,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 35, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnCrystalSwitch_Init(Actor* thisx, PlayState* play) {\\n    EnCrystalSwitch* this = (EnCrystalSwitch*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.1f);\\n    this->switchState = 0;\\n    this->timer = 0;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->lightNode = LightContext_InsertLight(play, &play->lightCtx, &this->lightInfo);\\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnCrystalSwitch_Update(Actor* thisx, PlayState* play) {\\n    EnCrystalSwitch* this = (EnCrystalSwitch*)thisx;\\n    Vec3f rewardPos;\\n    \\n    if (this->timer > 0) {\\n        this->timer--;\\n    }\\n\\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->collider.base.acFlags &= ~AC_HIT;\\n        \\n        if (this->timer <= 0) {\\n            this->switchState ^= 1;\\n            this->timer = 30;\\n            \\n            Actor_PlaySfx(&this->actor, NA_SE_SY_CORRECT_CHIME);\\n            \\n            // Spawn reward rupee using authentic EnItem00\\n            rewardPos.x = this->actor.world.pos.x;\\n            rewardPos.y = this->actor.world.pos.y + 40.0f;\\n            rewardPos.z = this->actor.world.pos.z;\\n            \\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       rewardPos.x, rewardPos.y, rewardPos.z,\\n                       0, 0, 0, ITEM00_RUPEE_BLUE);\\n        }\\n    }\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnCrystalSwitch_Profile = {\\n    /**/ ACTOR_EN_CRYSTAL_SWITCH,\\n    /**/ ACTORCAT_SWITCH,\\n    /**/ FLAGS,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnCrystalSwitch),\\n    /**/ EnCrystalSwitch_Init,\\n    /**/ EnCrystalSwitch_Destroy,\\n    /**/ EnCrystalSwitch_Update,\\n    /**/ EnCrystalSwitch_Draw\\n};"}
{"instruction": "Create a debugging helper actor that displays collision info and spawns a heart piece when triggered", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 debugState;\n    /* 0x0150 */ f32 detectionRange;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnDbgHelper; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnDbgHelper_Init(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->detectionRange = 100.0f;\n    Actor_SetScale(&this->actor, 0.01f);\n    this->debugState = 0;\n    this->timer = 0;\n}\n\nvoid EnDbgHelper_Update(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    f32 dist = Actor_WorldDistXYZToActor(&this->actor, &player->actor);\n    \n    if (dist < this->detectionRange) {\n        if (Player_IsFacingActor(&this->actor, player, 0x2000)) {\n            this->timer++;\n            if (this->timer > 30) {\n                Vec3f spawnPos;\n                spawnPos.x = this->actor.world.pos.x;\n                spawnPos.y = this->actor.world.pos.y + 40.0f;\n                spawnPos.z = this->actor.world.pos.z;\n                \n                Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                           spawnPos.x, spawnPos.y, spawnPos.z,\n                           0, 0, 0, ITEM00_HEART_PIECE);\n                           \n                Actor_Kill(&this->actor);\n            }\n        }\n    }\n}\n\nconst ActorProfile EnDbgHelper_Profile = {\n    /**/ ACTOR_EN_DBG_HELPER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnDbgHelper),\n    /**/ EnDbgHelper_Init,\n    /**/ Actor_Destroy,\n    /**/ EnDbgHelper_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and visual effects", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 hitboxScale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->hitboxScale = 1.0f;\\n    this->actionState = 0;\\n    this->timer = 0;\\n    \\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    Player* player = GET_PLAYER(play);\\n    \\n    this->timer++;\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\\n        \\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    this->actor.world.pos.x,\\n                    this->actor.world.pos.y + 20.0f,\\n                    this->actor.world.pos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n                    \\n        Actor_Kill(&this->actor);\\n    }\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, then explodes and disappears", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 hitCount;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnBreakPot; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnBreakPot_Init(Actor* thisx, PlayState* play) {\n    EnBreakPot* this = (EnBreakPot*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->timer = 0;\n    this->hitCount = 0;\n    this->scale = 1.0f;\n    \n    this->actor.colChkInfo.mass = 100;\n    Actor_SetFocus(&this->actor, 20.0f);\n}\n\nvoid EnBreakPot_Update(Actor* thisx, PlayState* play) {\n    EnBreakPot* this = (EnBreakPot*)thisx;\n    Vec3f spawnPos;\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    if (this->actor.colChkInfo.acHitInfo != NULL) {\n        spawnPos = this->actor.world.pos;\n        spawnPos.y += 40.0f;\n        \n        // Spawn heart piece using authentic EnItem00 pattern\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   spawnPos.x, spawnPos.y, spawnPos.z,\n                   0, 0, 0, ITEM00_HEART_PIECE);\n                   \n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\n        Actor_Kill(&this->actor);\n    }\n}\n\nconst ActorProfile EnBreakPot_Profile = {\n    /**/ ACTOR_EN_BREAK_POT,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnBreakPot),\n    /**/ EnBreakPot_Init,\n    /**/ Actor_Destroy,\n    /**/ EnBreakPot_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Implement a crystal switch actor that toggles between red/blue states, spawns rupees when hit, and has proper collision detection. Must follow OoT patterns exactly.", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 switchState;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n    /* 0x01A0 */ LightNode* lightNode;\n    /* 0x01A4 */ Color_RGBA8 lightColor;\n} EnCrystalSwitch; // size = 0x1A8\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 12, 25, 0, { 0, 0, 0 } },\n};\n\nvoid EnCrystalSwitch_Init(Actor* thisx, PlayState* play) {\n    EnCrystalSwitch* this = (EnCrystalSwitch*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.1f);\n    this->switchState = 0;\n    this->timer = 0;\n    \n    this->lightColor.r = 255;\n    this->lightColor.g = 0;\n    this->lightColor.b = 0;\n    this->lightColor.a = 255;\n    \n    this->lightNode = LightContext_InsertLight(play, &play->lightCtx, &this->lightColor);\n}\n\nvoid EnCrystalSwitch_Update(Actor* thisx, PlayState* play) {\n    EnCrystalSwitch* this = (EnCrystalSwitch*)thisx;\n    Vec3f spawnPos;\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        this->switchState ^= 1;\n        this->timer = 20;\n        \n        // Spawn rupee reward using authentic EnItem00\n        spawnPos.x = this->actor.world.pos.x;\n        spawnPos.y = this->actor.world.pos.y + 40.0f;\n        spawnPos.z = this->actor.world.pos.z;\n        \n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   spawnPos.x, spawnPos.y, spawnPos.z,\n                   0, 0, 0, ITEM00_RUPEE_BLUE);\n                   \n        Actor_PlaySfx(&this->actor, NA_SE_SY_CORRECT_CHIME);\n    }\n    \n    if (this->timer > 0) {\n        this->timer--;\n    }\n    \n    this->lightColor.r = this->switchState ? 0 : 255;\n    this->lightColor.b = this->switchState ? 255 : 0;\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile EnCrystalSwitch_InitVars = {\n    /**/ ACTOR_EN_CRYSTAL_SWITCH,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnCrystalSwitch),\n    /**/ EnCrystalSwitch_Init,\n    /**/ EnCrystalSwitch_Destroy,\n    /**/ EnCrystalSwitch_Update,\n    /**/ EnCrystalSwitch_Draw\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and visual effects", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 hitCount;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 alphaLevel;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnHeartStatue; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_WOOD,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 45, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartStatue_Init(Actor* thisx, PlayState* play) {\\n    EnHeartStatue* this = (EnHeartStatue*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    Actor_SetFocus(&this->actor, 45.0f);\\n    \\n    this->hitCount = 0;\\n    this->actionState = 0;\\n    this->alphaLevel = 1.0f;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n}\\n\\nvoid EnHeartStatue_Update(Actor* thisx, PlayState* play) {\\n    EnHeartStatue* this = (EnHeartStatue*)thisx;\\n    Player* player = GET_PLAYER(play);\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitCount++;\\n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\\n        \\n        if (this->hitCount >= 3) {\\n            Vec3f spawnPos;\\n            spawnPos.x = this->actor.world.pos.x;\\n            spawnPos.y = this->actor.world.pos.y + 40.0f;\\n            spawnPos.z = this->actor.world.pos.z;\\n            \\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, 0, 0, ITEM00_HEART_PIECE);\\n            \\n            Actor_Kill(&this->actor);\\n        }\\n    }\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 0.0f, BGCHECKFLAG_GROUND);\\n}\\n\\nconst ActorProfile EnHeartStatue_Profile = {\\n    /**/ ACTOR_EN_HEART_STATUE,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_NONE,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartStatue),\\n    /**/ EnHeartStatue_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartStatue_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, plays a sound effect, and then despawns. Include collision handling and proper state management.", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ ColliderCylinder collider;\n} EnHeartSpawner; // size = 0x19C\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actionState = 0;\n    this->timer = 0;\n}\n\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    if (this->collider.base.acFlags & AC_HIT) {\n        Actor_PlaySfx(&this->actor, NA_SE_EV_HEART_OF_GROTTO_APPEAR);\n        \n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   this->actor.world.pos.x,\n                   this->actor.world.pos.y,\n                   this->actor.world.pos.z,\n                   0, 0, 0, ITEM00_HEART_PIECE);\n                   \n        Actor_Kill(&this->actor);\n    }\n}\n\nconst ActorProfile EnHeartSpawner_Profile = {\n    /**/ ACTOR_EN_HEART_SPAWNER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnHeartSpawner),\n    /**/ EnHeartSpawner_Init,\n    /**/ Actor_Destroy,\n    /**/ EnHeartSpawner_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Implement a magical crystal actor that spins in place, detects player proximity, and spawns a heart piece when struck. It should use proper collision detection and particle effects.", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 spinAngle;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 detectionRange;\\n    /* 0x0154 */ f32 glowIntensity;\\n    /* 0x0158 */ ColliderCylinder collider;\\n} EnMagicCrystal; // size = 0x1A4\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 45, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnMagicCrystal_Init(Actor* thisx, PlayState* play) {\\n    EnMagicCrystal* this = (EnMagicCrystal*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.02f);\\n    \\n    this->spinAngle = 0;\\n    this->actionState = 0;\\n    this->detectionRange = 150.0f;\\n    this->glowIntensity = 0.0f;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnMagicCrystal_Update(Actor* thisx, PlayState* play) {\\n    EnMagicCrystal* this = (EnMagicCrystal*)thisx;\\n    Player* player = GET_PLAYER(play);\\n    \\n    this->spinAngle += 0x0200;\\n    \\n    // Update collision\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    // Check player distance\\n    f32 playerDist = Actor_WorldDistXYZToActor(&this->actor, &player->actor);\\n    \\n    if (playerDist < this->detectionRange) {\\n        this->glowIntensity += 0.05f;\\n        if (this->glowIntensity > 1.0f) {\\n            this->glowIntensity = 1.0f;\\n        }\\n        \\n        // Check if hit\\n        if (this->collider.base.acFlags & AC_HIT) {\\n            Vec3f spawnPos;\\n            spawnPos.x = this->actor.world.pos.x;\\n            spawnPos.y = this->actor.world.pos.y + 40.0f;\\n            spawnPos.z = this->actor.world.pos.z;\\n            \\n            // Spawn heart piece using authentic EnItem00\\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, 0, 0, ITEM00_HEART_PIECE);\\n            \\n            Actor_PlaySfx(&this->actor, NA_SE_EV_ITEM_GET);\\n            Actor_Kill(&this->actor);\\n        }\\n    } else {\\n        this->glowIntensity -= 0.05f;\\n        if (this->glowIntensity < 0.0f) {\\n            this->glowIntensity = 0.0f;\\n        }\\n    }\\n}\\n\\nconst ActorProfile EnMagicCrystal_Profile = {\\n    /**/ ACTOR_EN_MAGIC_CRYSTAL,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnMagicCrystal),\\n    /**/ EnMagicCrystal_Init,\\n    /**/ EnMagicCrystal_Destroy,\\n    /**/ EnMagicCrystal_Update,\\n    /**/ EnMagicCrystal_Draw\\n};"}
{"instruction": "Create a debugging helper actor that spawns a blue rupee when Link gets close and displays debug text showing distance to player", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 debugState;\n    /* 0x0150 */ f32 detectionRange;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnDebugHelp; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 15, 25, 0, { 0, 0, 0 } },\n};\n\nvoid EnDebugHelp_Init(Actor* thisx, PlayState* play) {\n    EnDebugHelp* this = (EnDebugHelp*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->detectionRange = 100.0f;\n    this->debugState = 0;\n    this->timer = 0;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnDebugHelp_Destroy(Actor* thisx, PlayState* play) {\n    EnDebugHelp* this = (EnDebugHelp*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnDebugHelp_Update(Actor* thisx, PlayState* play) {\n    EnDebugHelp* this = (EnDebugHelp*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    f32 dist = Actor_WorldDistXYZToActor(&this->actor, &player->actor);\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (dist < this->detectionRange && this->timer == 0) {\n        Vec3f spawnPos;\n        spawnPos.x = this->actor.world.pos.x;\n        spawnPos.y = this->actor.world.pos.y + 40.0f;\n        spawnPos.z = this->actor.world.pos.z;\n        \n        // Spawn blue rupee using authentic EnItem00 pattern\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   spawnPos.x, spawnPos.y, spawnPos.z,\n                   0, 0, 0, ITEM00_RUPEE_BLUE);\n                   \n        this->timer = 100;\n    }\n    \n    if (this->timer > 0) {\n        this->timer--;\n    }\n    \n    // Show debug distance text\n    Gfx_DrawDebugText(play, \\"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and visual effects", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 hitCount;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnHeartSpawner; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.flags |= ACTOR_FLAG_4;\n    Actor_SetScale(&this->actor, 0.01f);\n    Actor_SetFocus(&this->actor, 20.0f);\n    \n    this->timer = 0;\n    this->hitCount = 0;\n    this->scale = 1.0f;\n}\n\nvoid EnHeartSpawner_Destroy(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    this->timer++;\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        this->hitCount++;\n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\n        \n        if (this->hitCount >= 3) {\n            Vec3f spawnPos;\n            spawnPos.x = this->actor.world.pos.x;\n            spawnPos.y = this->actor.world.pos.y + 40.0f;\n            spawnPos.z = this->actor.world.pos.z;\n            \n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       spawnPos.x, spawnPos.y, spawnPos.z,\n                       0, 0, 0, ITEM00_HEART_PIECE);\n                       \n            Actor_Kill(&this->actor);\n            return;\n        }\n    }\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnHeartSpawner_Draw(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Matrix_Push();\n    Matrix_Scale(this->scale, this->scale, this->scale, MTXMODE_APPLY);\n    Matrix_RotateZ(this->timer * 0.1f, MTXMODE_APPLY);\n    Matrix_NewMtx(play->gfxCtx, \\"}
{"instruction": "Create a simple actor that spawns a heart piece when hit by the player's sword and plays a sound effect", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ ColliderCylinder collider;\n} EnHeartSpawner; // size = 0x19C\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actionState = 0;\n    this->timer = 0;\n}\n\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\n        \n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   this->actor.world.pos.x,\n                   this->actor.world.pos.y,\n                   this->actor.world.pos.z,\n                   0, 0, 0, ITEM00_HEART_PIECE);\n                   \n        Actor_Kill(&this->actor);\n        return;\n    }\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile EnHeartSpawner_Profile = {\n    /**/ ACTOR_EN_HEART_SPAWNER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnHeartSpawner),\n    /**/ EnHeartSpawner_Init,\n    /**/ EnHeartSpawner_Destroy,\n    /**/ EnHeartSpawner_Update,\n    /**/ NULL\n};\n```"}
{"instruction": "Implement a crystal switch actor that toggles between blue/red states, spawns rupees when hit, and has proper collision detection. Must follow OoT patterns exactly.", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 switchState;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n    /* 0x01A0 */ LightNode* lightNode;\n    /* 0x01A4 */ Color_RGBA8 lightColor;\n} EnCrystalSwitch; // size = 0x1A8\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x08000000, HIT_BACKLASH_NONE, 0x01 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnCrystalSwitch_Init(Actor* thisx, PlayState* play) {\n    EnCrystalSwitch* this = (EnCrystalSwitch*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.1f);\n    this->switchState = 0;\n    this->timer = 0;\n    \n    // Initialize light\n    this->lightNode = LightContext_InsertLight(play, &play->lightCtx, &this->lightColor);\n    this->lightColor.r = 0;\n    this->lightColor.g = 0;\n    this->lightColor.b = 255;\n    this->lightColor.a = 255;\n}\n\nvoid EnCrystalSwitch_Update(Actor* thisx, PlayState* play) {\n    EnCrystalSwitch* this = (EnCrystalSwitch*)thisx;\n    Vec3f spawnPos;\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        this->switchState ^= 1;\n        Actor_PlaySfx(&this->actor, NA_SE_SY_CORRECT_CHIME);\n        \n        // Spawn rupee using authentic EnItem00 pattern\n        spawnPos = this->actor.world.pos;\n        spawnPos.y += 40.0f;\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   spawnPos.x, spawnPos.y, spawnPos.z,\n                   0, 0, 0, ITEM00_RUPEE_BLUE);\n                   \n        this->timer = 20;\n    }\n    \n    // Update light color based on state\n    this->lightColor.r = this->switchState ? 255 : 0;\n    this->lightColor.b = this->switchState ? 0 : 255;\n    \n    if (this->timer > 0) {\n        this->timer--;\n    }\n}\n\nconst ActorProfile EnCrystalSwitch_Profile = {\n    /**/ ACTOR_EN_CRYSTAL_SWITCH,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnCrystalSwitch),\n    /**/ EnCrystalSwitch_Init,\n    /**/ Actor_Destroy,\n    /**/ EnCrystalSwitch_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Create a debugging helper actor that displays collision info and spawns rupees for testing", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 debugState;\n    /* 0x0150 */ f32 displayRadius;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnDbgHelper; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000004, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnDbgHelper_Init(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->timer = 0;\n    this->debugState = 0;\n    this->displayRadius = 50.0f;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.world.pos.y += 20.0f;\n    this->actor.flags |= ACTOR_FLAG_0;\n}\n\nvoid EnDbgHelper_Update(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    if (this->timer > 30) {\n        this->timer = 0;\n        \n        // Spawn test rupee if player is nearby\n        if (Actor_WorldDistXYZToActor(&player->actor, &this->actor) < 100.0f) {\n            Vec3f spawnPos;\n            spawnPos.x = this->actor.world.pos.x;\n            spawnPos.y = this->actor.world.pos.y;\n            spawnPos.z = this->actor.world.pos.z;\n            \n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       spawnPos.x, spawnPos.y, spawnPos.z,\n                       0, 0, 0, ITEM00_RUPEE_BLUE);\n        }\n    }\n\n    // Update collision detection\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnDbgHelper_Draw(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    \n    Matrix_Push();\n    Matrix_Scale(0.01f, 0.01f, 0.01f, MTXMODE_APPLY);\n    Matrix_RotateZ(this->timer * 0.1f, MTXMODE_APPLY);\n    Matrix_NewMtx(play->state.gfxCtx, \\"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, plays a sound effect, and despawns after a timer", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnHeartSpawner; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 15, 25, 0, { 0, 0, 0 } },\n};\n\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    Actor_SetFocus(&this->actor, 20.0f);\n    \n    this->timer = 100;\n    this->actionState = 0;\n    this->scale = 1.0f;\n}\n\nvoid EnHeartSpawner_Destroy(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    this->timer--;\n    \n    if (this->timer <= 0) {\n        Actor_Kill(&this->actor);\n        return;\n    }\n\n    if (this->collider.base.acFlags & AC_HIT) {\n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\n        \n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   this->actor.world.pos.x,\n                   this->actor.world.pos.y,\n                   this->actor.world.pos.z,\n                   0, 0, 0, ITEM00_HEART_PIECE);\n                   \n        Actor_Kill(&this->actor);\n        return;\n    }\n\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnHeartSpawner_Draw(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Matrix_Push();\n    Matrix_Scale(this->scale, this->scale, this->scale, MTXMODE_APPLY);\n    Matrix_Pop();\n}\n\nconst ActorProfile EnHeartSpawner_Profile = {\n    /**/ ACTOR_EN_HEART_SPAWNER,\n    /**/ ACTORCAT_MISC,\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnHeartSpawner),\n    /**/ EnHeartSpawner_Init,\n    /**/ EnHeartSpawner_Destroy,\n    /**/ EnHeartSpawner_Update,\n    /**/ EnHeartSpawner_Draw\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and visual feedback", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 hitTimer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 scale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->hitTimer = 0;\\n    this->actionState = 0;\\n    \\n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    if (this->hitTimer > 0) {\\n        this->hitTimer--;\\n    }\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitTimer = 10;\\n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\\n        \\n        // Spawn heart piece using authentic EnItem00 pattern\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    this->actor.world.pos.x,\\n                    this->actor.world.pos.y + 40.0f,\\n                    this->actor.world.pos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n                    \\n        Actor_Kill(&this->actor);\\n    }\\n    \\n    // Authentic collision update pattern\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ EnHeartSpawner_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Implement a magical crystal actor that spawns rupees when hit, changes color over time, and has proper collision detection. The crystal should rotate continuously and play sound effects when interacted with.", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 colorState;\\n    /* 0x0150 */ f32 rotationSpeed;\\n    /* 0x0154 */ f32 pulseScale;\\n    /* 0x0158 */ s16 hitCount;\\n    /* 0x015A */ s16 spawnDelay;\\n    /* 0x015C */ ColliderCylinder collider;\\n} EnCrystal; // size = 0x1A8\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 45, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnCrystal_Init(Actor* thisx, PlayState* play) {\\n    EnCrystal* this = (EnCrystal*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.02f);\\n    this->actor.colChkInfo.mass = 255;\\n    this->actor.gravity = -1.0f;\\n    \\n    this->rotationSpeed = 0.05f;\\n    this->pulseScale = 1.0f;\\n    this->colorState = 0;\\n    this->hitCount = 0;\\n    this->spawnDelay = 0;\\n    \\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnCrystal_Update(Actor* thisx, PlayState* play) {\\n    EnCrystal* this = (EnCrystal*)thisx;\\n    \\n    this->timer++;\\n    this->actor.world.rot.y += (s16)(this->rotationSpeed * 1000.0f);\\n    \\n    if (this->spawnDelay > 0) {\\n        this->spawnDelay--;\\n    }\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->collider.base.acFlags &= ~AC_HIT;\\n        this->hitCount++;\\n        \\n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\\n        \\n        if (this->spawnDelay == 0) {\\n            Vec3f spawnPos = this->actor.world.pos;\\n            spawnPos.y += 20.0f;\\n            \\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, 0, 0, ITEM00_RUPEE_BLUE);\\n                       \\n            this->spawnDelay = 20;\\n        }\\n    }\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnCrystal_Profile = {\\n    /**/ ACTOR_EN_CRYSTAL,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnCrystal),\\n    /**/ EnCrystal_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnCrystal_Update,\\n    /**/ NULL,\\n};"}
{"instruction": "Create a debugging helper actor that spawns a blue rupee when Link gets close and displays debug text showing distance to player", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 debugState;\\n    /* 0x0150 */ f32 detectionRange;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnDebugHelp; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 15, 25, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnDebugHelp_Init(Actor* thisx, PlayState* play) {\\n    EnDebugHelp* this = (EnDebugHelp*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->detectionRange = 100.0f;\\n    this->debugState = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnDebugHelp_Update(Actor* thisx, PlayState* play) {\\n    EnDebugHelp* this = (EnDebugHelp*)thisx;\\n    Player* player = GET_PLAYER(play);\\n    f32 distToPlayer;\\n    \\n    distToPlayer = Actor_WorldDistXYZToActor(&this->actor, &player->actor);\\n    \\n    // Update collision detection\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (distToPlayer < this->detectionRange && this->timer == 0) {\\n        Vec3f spawnPos;\\n        spawnPos.x = this->actor.world.pos.x;\\n        spawnPos.y = this->actor.world.pos.y + 20.0f;\\n        spawnPos.z = this->actor.world.pos.z;\\n        \\n        // Spawn blue rupee using authentic EnItem00 pattern\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_RUPEE_BLUE);\\n        \\n        this->timer = 30;\\n    }\\n    \\n    if (this->timer > 0) {\\n        this->timer--;\\n    }\\n}\\n\\nconst ActorProfile EnDebugHelp_Profile = {\\n    /**/ ACTOR_EN_DEBUG_HELP,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnDebugHelp),\\n    /**/ EnDebugHelp_Init,\\n    /**/ EnDebugHelp_Destroy,\\n    /**/ EnDebugHelp_Update,\\n    /**/ NULL,\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and visual effects", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 hitCount;\\n    /* 0x0150 */ f32 scale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actor.colChkInfo.mass = 0xFF;\\n    this->actor.targetMode = 0;\\n    \\n    this->timer = 0;\\n    this->hitCount = 0;\\n    this->scale = 1.0f;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    this->timer++;\\n    \\n    if (this->actor.colChkInfo.acHitInfo != NULL) {\\n        this->hitCount++;\\n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\\n        \\n        if (this->hitCount >= 3) {\\n            Vec3f spawnPos;\\n            spawnPos.x = this->actor.world.pos.x;\\n            spawnPos.y = this->actor.world.pos.y + 40.0f;\\n            spawnPos.z = this->actor.world.pos.z;\\n            \\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, 0, 0, ITEM00_HEART_PIECE);\\n            \\n            Actor_Kill(&this->actor);\\n            return;\\n        }\\n    }\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, plays a sound effect, and despawns after a short timer", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ ColliderCylinder collider;\n} EnHeartSpawner; // size = 0x19C\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->timer = 100;\n    this->actionState = 0;\n}\n\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\n        \n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   this->actor.world.pos.x,\n                   this->actor.world.pos.y,\n                   this->actor.world.pos.z,\n                   0, 0, 0, ITEM00_HEART_PIECE);\n                   \n        this->actionState = 1;\n    }\n    \n    if (this->actionState == 1) {\n        this->timer--;\n        if (this->timer <= 0) {\n            Actor_Kill(&this->actor);\n        }\n    }\n}\n\nconst ActorProfile EnHeartSpawner_Profile = {\n    /**/ ACTOR_EN_HEART_SPAWNER,\n    /**/ ACTORCAT_MISC,\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnHeartSpawner),\n    /**/ EnHeartSpawner_Init,\n    /**/ Actor_Destroy,\n    /**/ EnHeartSpawner_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Implement a floating crystal actor that rotates, pulses with light, and spawns a heart piece when hit with an arrow. It should use proper collision detection and visual effects.", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 rotationAngle;\\n    /* 0x014E */ s16 pulseTimer;\\n    /* 0x0150 */ f32 pulseScale;\\n    /* 0x0154 */ f32 alphaLevel;\\n    /* 0x158 */ ColliderCylinder collider;\\n} EnCrystal; // size = 0x1A4\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000020, HIT_ARROW, 0x01 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 40, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnCrystal_Init(Actor* thisx, PlayState* play) {\\n    EnCrystal* this = (EnCrystal*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.02f);\\n    this->rotationAngle = 0;\\n    this->pulseTimer = 0;\\n    this->pulseScale = 1.0f;\\n    this->alphaLevel = 255.0f;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetFocus(&this->actor, 20.0f);\\n    this->actor.flags |= ACTOR_FLAG_0;\\n}\\n\\nvoid EnCrystal_Destroy(Actor* thisx, PlayState* play) {\\n    EnCrystal* this = (EnCrystal*)thisx;\\n    Collider_DestroyCylinder(play, &this->collider);\\n}\\n\\nvoid EnCrystal_Update(Actor* thisx, PlayState* play) {\\n    EnCrystal* this = (EnCrystal*)thisx;\\n    \\n    this->rotationAngle += 0x0200;\\n    this->pulseTimer += 0x0111;\\n    this->pulseScale = 1.0f + (Math_SinS(this->pulseTimer) * 0.1f);\\n    \\n    // Update collision\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    // Check if hit by arrow\\n    if (this->collider.base.acFlags & AC_HIT) {\\n        Vec3f spawnPos;\\n        spawnPos.x = this->actor.world.pos.x;\\n        spawnPos.y = this->actor.world.pos.y;\\n        spawnPos.z = this->actor.world.pos.z;\\n        \\n        // Spawn heart piece using authentic EnItem00\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n        \\n        Actor_PlaySfx(&this->actor, NA_SE_EV_CRYSTAL_BROKEN);\\n        Actor_Kill(&this->actor);\\n    }\\n}\\n\\nvoid EnCrystal_Draw(Actor* thisx, PlayState* play) {\\n    EnCrystal* this = (EnCrystal*)thisx;\\n    \\n    OPEN_DISPS(play->state.gfxCtx);\\n    \\n    Gfx_SetupDL_25Xlu(play->state.gfxCtx);\\n    \\n    Matrix_Push();\\n    Matrix_RotateY(this->rotationAngle * (M_PI / 32768.0f), MTXMODE_APPLY);\\n    Matrix_Scale(this->pulseScale, this->pulseScale, this->pulseScale, MTXMODE_APPLY);\\n    \\n    gDPSetPrimColor(POLY_XLU_DISP++, 0, 0, 170, 255, 255, (u8)this->alphaLevel);\\n    gSPMatrix(POLY_XLU_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\\n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\\n    gSPDisplayList(POLY_XLU_DISP++, gCrystalDL);\\n    \\n    Matrix_Pop();\\n    \\n    CLOSE_DISPS(play->state.gfxCtx);\\n}\\n\\nconst ActorProfile EnCrystal_Profile = {\\n    /**/ ACTOR_EN_CRYSTAL,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS,\\n    /**/ OBJECT_CRYSTAL,\\n    /**/ sizeof(EnCrystal),\\n    /**/ EnCrystal_Init,\\n    /**/ EnCrystal_Destroy,\\n    /**/ EnCrystal_Update,\\n    /**/ EnCrystal_Draw,\\n};"}
{"instruction": "Create a debugging helper actor that displays a visual indicator and plays a sound when Link is within range. Spawns a blue rupee when triggered.", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 debugState;\\n    /* 0x0150 */ f32 detectionRange;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnDbgHelp; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnDbgHelp_Init(Actor* thisx, PlayState* play) {\\n    EnDbgHelp* this = (EnDbgHelp*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->detectionRange = 100.0f;\\n    this->debugState = 0;\\n    Actor_SetScale(&this->actor, 0.01f);\\n}\\n\\nvoid EnDbgHelp_Update(Actor* thisx, PlayState* play) {\\n    EnDbgHelp* this = (EnDbgHelp*)thisx;\\n    Player* player = GET_PLAYER(play);\\n    \\n    f32 dist = Actor_WorldDistXYZToActor(&this->actor, &player->actor);\\n    \\n    if (dist < this->detectionRange) {\\n        if (this->debugState == 0) {\\n            Actor_PlaySfx(&this->actor, NA_SE_SY_CORRECT_CHIME);\\n            \\n            // Spawn blue rupee using authentic EnItem00 pattern\\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       this->actor.world.pos.x,\\n                       this->actor.world.pos.y + 40.0f,\\n                       this->actor.world.pos.z,\\n                       0, 0, 0, ITEM00_RUPEE_BLUE);\\n                       \\n            this->debugState = 1;\\n        }\\n    } else {\\n        this->debugState = 0;\\n    }\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnDbgHelp_Profile = {\\n    /**/ ACTOR_EN_DBG_HELP,\\n    /**/ ACTORCAT_MISC,\\n    /**/ FLAGS,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnDbgHelp),\\n    /**/ EnDbgHelp_Init,\\n    /**/ EnDbgHelp_Destroy,\\n    /**/ EnDbgHelp_Update,\\n    /**/ EnDbgHelp_Draw,\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, plays a sound, and then despawns with a particle effect", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 hitCount;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnBreakHeart; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 40, 0, { 0, 0, 0 } },\n};\n\nvoid EnBreakHeart_Init(Actor* thisx, PlayState* play) {\n    EnBreakHeart* this = (EnBreakHeart*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\n    Actor_SetScale(&this->actor, 0.01f);\n    \n    this->timer = 0;\n    this->hitCount = 0;\n    this->scale = 1.0f;\n}\n\nvoid EnBreakHeart_Destroy(Actor* thisx, PlayState* play) {\n    EnBreakHeart* this = (EnBreakHeart*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnBreakHeart_Update(Actor* thisx, PlayState* play) {\n    EnBreakHeart* this = (EnBreakHeart*)thisx;\n    \n    this->timer++;\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        this->hitCount++;\n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\n        \n        if (this->hitCount >= 3) {\n            Vec3f spawnPos;\n            spawnPos.x = this->actor.world.pos.x;\n            spawnPos.y = this->actor.world.pos.y;\n            spawnPos.z = this->actor.world.pos.z;\n            \n            // Spawn heart piece using authentic EnItem00\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       spawnPos.x, spawnPos.y, spawnPos.z,\n                       0, 0, 0, ITEM00_HEART_PIECE);\n                       \n            Actor_PlaySfx(&this->actor, NA_SE_EV_MEDAL_GET);\n            Actor_Kill(&this->actor);\n            return;\n        }\n    }\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnBreakHeart_Draw(Actor* thisx, PlayState* play) {\n    EnBreakHeart* this = (EnBreakHeart*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx, \\"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, plays a sound effect, and disappears with a particle effect", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ ColliderCylinder collider;\n} EnBreakHeart; // size = 0x19C\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_WOOD,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnBreakHeart_Init(Actor* thisx, PlayState* play) {\n    EnBreakHeart* this = (EnBreakHeart*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actionState = 0;\n    this->timer = 0;\n}\n\nvoid EnBreakHeart_Update(Actor* thisx, PlayState* play) {\n    EnBreakHeart* this = (EnBreakHeart*)thisx;\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    if (this->collider.base.acFlags & AC_HIT) {\n        Vec3f pos;\n        pos.x = this->actor.world.pos.x;\n        pos.y = this->actor.world.pos.y;\n        pos.z = this->actor.world.pos.z;\n\n        // Spawn heart piece using authentic EnItem00 pattern\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   pos.x, pos.y, pos.z, 0, 0, 0, ITEM00_HEART_PIECE);\n        \n        // Play break sound\n        Actor_PlaySfx(&this->actor, NA_SE_IT_WOOD_STICK_BREAK);\n        \n        // Spawn particles\n        EffectSsKiraKira_SpawnSmall(play, &pos, &velocity_zero, &accel_zero, 600);\n        \n        Actor_Kill(&this->actor);\n    }\n}\n\nconst ActorProfile EnBreakHeart_Profile = {\n    /**/ ACTOR_EN_BREAK_HEART,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnBreakHeart),\n    /**/ EnBreakHeart_Init,\n    /**/ Actor_Destroy,\n    /**/ EnBreakHeart_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Implement a crystal switch actor that toggles between blue/red states, spawns rupees when hit, and damages the player on contact while spinning", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 switchState;\\n    /* 0x0150 */ f32 spinRate;\\n    /* 0x0154 */ f32 heightOffset;\\n    /* 0x0158 */ ColliderCylinder collider;\\n} EnCrystalSwitch; // size = 0x1A4\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_ON | AT_TYPE_ENEMY,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_2,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x20000000, HIT_SPECIAL_EFFECT_NONE, 0x01 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_ON | ATELEM_NONWIND,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 45, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnCrystalSwitch_Init(Actor* thisx, PlayState* play) {\\n    EnCrystalSwitch* this = (EnCrystalSwitch*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.025f);\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->timer = 0;\\n    this->switchState = 0;\\n    this->spinRate = 0.0f;\\n    this->heightOffset = 0.0f;\\n    \\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnCrystalSwitch_Update(Actor* thisx, PlayState* play) {\\n    EnCrystalSwitch* this = (EnCrystalSwitch*)thisx;\\n    Vec3f spawnPos;\\n    \\n    this->timer++;\\n    this->actor.world.rot.y += (s16)(this->spinRate * 182.04f);\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->collider.base.acFlags &= ~AC_HIT;\\n        this->switchState ^= 1;\\n        \\n        // Spawn rupee reward\\n        spawnPos = this->actor.world.pos;\\n        spawnPos.y += 40.0f;\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                   spawnPos.x, spawnPos.y, spawnPos.z,\\n                   0, 0, 0, ITEM00_RUPEE_BLUE);\\n        \\n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\\n        this->spinRate = 12.0f;\\n    }\\n    \\n    if (this->spinRate > 0.0f) {\\n        this->spinRate -= 0.5f;\\n    }\\n    \\n    // Update collision\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    if (this->spinRate > 0.0f) {\\n        CollisionCheck_SetAT(play, &play->colChkCtx, &this->collider.base);\\n    }\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    // Hover effect\\n    this->heightOffset = Math_SinS(this->timer * 0x800) * 5.0f;\\n    this->actor.world.pos.y = this->actor.home.pos.y + this->heightOffset;\\n}\\n\\nconst ActorProfile EnCrystalSwitch_Profile = {\\n    /**/ ACTOR_EN_CRYSTAL_SWITCH,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnCrystalSwitch),\\n    /**/ EnCrystalSwitch_Init,\\n    /**/ EnCrystalSwitch_Destroy,\\n    /**/ EnCrystalSwitch_Update,\\n    /**/ EnCrystalSwitch_Draw\\n};"}
{"instruction": "Create a debugging helper actor that spawns a blue rupee when Link is within range and displays debug text showing distance to player", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 debugState;\n    /* 0x0150 */ f32 detectionRange;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnDbgHelper; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 15, 25, 0, { 0, 0, 0 } },\n};\n\nvoid EnDbgHelper_Init(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->detectionRange = 150.0f;\n    Actor_SetScale(&this->actor, 0.01f);\n    this->debugState = 0;\n}\n\nvoid EnDbgHelper_Destroy(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnDbgHelper_Update(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    f32 dist = Actor_WorldDistXYZToActor(&this->actor, &player->actor);\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (dist < this->detectionRange && this->debugState == 0) {\n        // Spawn blue rupee using authentic EnItem00 pattern\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   this->actor.world.pos.x, this->actor.world.pos.y + 40.0f,\n                   this->actor.world.pos.z, 0, 0, 0, ITEM00_RUPEE_BLUE);\n        this->debugState = 1;\n    }\n    \n    // Display debug distance text\n    Gfx_DrawDebugText(play, \\"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, plays a sound, and then despawns with a particle effect", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnBreakableHeart; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_WOOD,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnBreakableHeart_Init(Actor* thisx, PlayState* play) {\n    EnBreakableHeart* this = (EnBreakableHeart*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.colChkInfo.mass = 0xFF;\n    Actor_SetFocus(&this->actor, 20.0f);\n    \n    this->timer = 0;\n    this->actionState = 0;\n    this->scale = 1.0f;\n}\n\nvoid EnBreakableHeart_Destroy(Actor* thisx, PlayState* play) {\n    EnBreakableHeart* this = (EnBreakableHeart*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnBreakableHeart_Update(Actor* thisx, PlayState* play) {\n    EnBreakableHeart* this = (EnBreakableHeart*)thisx;\n    \n    this->timer++;\n    \n    if (this->actionState == 0) {\n        if (this->collider.base.acFlags & AC_HIT) {\n            Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\n            \n            // Spawn heart piece using authentic EnItem00 pattern\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       this->actor.world.pos.x,\n                       this->actor.world.pos.y,\n                       this->actor.world.pos.z,\n                       0, 0, 0, ITEM00_HEART_PIECE);\n                       \n            this->actionState = 1;\n            this->timer = 0;\n        }\n    } else {\n        // Death sequence\n        this->scale -= 0.1f;\n        Actor_SetScale(&this->actor, this->scale * 0.01f);\n        \n        if (this->scale <= 0.0f) {\n            Actor_Kill(&this->actor);\n            return;\n        }\n    }\n    \n    // Authentic collision update pattern\n    Actor_UpdateBgCheckInfo(play, &this->actor, 26.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnBreakableHeart_Draw(Actor* thisx, PlayState* play) {\n    EnBreakableHeart* this = (EnBreakableHeart*)thisx;\n    \n    Matrix_Push();\n    Matrix_Scale(this->scale, this->scale, this->scale, MTXMODE_APPLY);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, \\"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword and plays a sound effect", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 hitTimer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ ColliderCylinder collider;\n} EnHeartSpawner; // size = 0x19C\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->hitTimer = 0;\n    this->actionState = 0;\n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    if (this->hitTimer > 0) {\n        this->hitTimer--;\n    }\n\n    if (this->collider.base.acFlags & AC_HIT) {\n        if (this->hitTimer == 0) {\n            Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\n            \n            // Spawn heart piece using authentic EnItem00 pattern\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       this->actor.world.pos.x,\n                       this->actor.world.pos.y + 40.0f,\n                       this->actor.world.pos.z,\n                       0, 0, 0, ITEM00_HEART_PIECE);\n                       \n            this->hitTimer = 20;\n        }\n        this->collider.base.acFlags &= ~AC_HIT;\n    }\n\n    // Authentic collision update sequence\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile EnHeartSpawner_Profile = {\n    /**/ ACTOR_EN_HEART_SPAWNER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnHeartSpawner),\n    /**/ EnHeartSpawner_Init,\n    /**/ EnHeartSpawner_Destroy,\n    /**/ EnHeartSpawner_Update,\n    /**/ NULL\n};\n```"}
{"instruction": "Implement a complex chest actor that spawns a heart piece when opened, with proper collision detection, player interaction, and state management following OoT patterns.", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 openAngle;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 lidRotation;\\n    /* 0x0154 */ ColliderCylinder collider;\\n    /* 0x01A0 */ s16 timer;\\n} EnTreasureChest; // size = 0x1A4\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_WOOD,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_WOOD,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 30, 45, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnTreasureChest_Init(Actor* thisx, PlayState* play) {\\n    EnTreasureChest* this = (EnTreasureChest*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actor.world.rot.y = this->actor.shape.rot.y;\\n    this->actionState = 0;\\n    this->timer = 0;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnTreasureChest_Update(Actor* thisx, PlayState* play) {\\n    EnTreasureChest* this = (EnTreasureChest*)thisx;\\n    Player* player = GET_PLAYER(play);\\n    \\n    this->timer++;\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    switch(this->actionState) {\\n        case 0: // Closed\\n            if (Player_IsFacingActor(&this->actor, player, 0x2000) &&\\n                Actor_WorldDistXYZToActor(&this->actor, &player->actor) < 80.0f) {\\n                this->actionState = 1;\\n                Actor_PlaySfx(&this->actor, NA_SE_EV_TREASURE_BOX_OPEN);\\n            }\\n            break;\\n            \\n        case 1: // Opening\\n            this->lidRotation += 0.1f;\\n            if (this->lidRotation >= 1.5f) {\\n                this->actionState = 2;\\n                \\n                Vec3f spawnPos;\\n                spawnPos.x = this->actor.world.pos.x;\\n                spawnPos.y = this->actor.world.pos.y + 40.0f;\\n                spawnPos.z = this->actor.world.pos.z;\\n                \\n                Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                           spawnPos.x, spawnPos.y, spawnPos.z,\\n                           0, 0, 0, ITEM00_HEART_PIECE);\\n            }\\n            break;\\n            \\n        case 2: // Opened\\n            break;\\n    }\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 0.0f, BGCHECKFLAG_GROUND);\\n}\\n\\nconst ActorProfile EnTreasureChest_Profile = {\\n    /**/ ACTOR_EN_TREASURE_CHEST,\\n    /**/ ACTORCAT_CHEST,\\n    /**/ FLAGS,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnTreasureChest),\\n    /**/ EnTreasureChest_Init,\\n    /**/ EnTreasureChest_Destroy,\\n    /**/ EnTreasureChest_Update,\\n    /**/ EnTreasureChest_Draw\\n};"}
{"instruction": "Create a debug actor that spawns a heart piece when the player gets close and plays a sound effect. Include collision detection and basic state management.", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 detectionRange;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnDbgHelp; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnDbgHelp_Init(Actor* thisx, PlayState* play) {\\n    EnDbgHelp* this = (EnDbgHelp*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->detectionRange = 100.0f;\\n    this->actionState = 0;\\n    this->timer = 0;\\n}\\n\\nvoid EnDbgHelp_Update(Actor* thisx, PlayState* play) {\\n    EnDbgHelp* this = (EnDbgHelp*)thisx;\\n    Player* player = GET_PLAYER(play);\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->actionState == 0) {\\n        f32 dist = Actor_WorldDistXYZToActor(&this->actor, &player->actor);\\n        \\n        if (dist < this->detectionRange) {\\n            Vec3f spawnPos;\\n            spawnPos.x = this->actor.world.pos.x;\\n            spawnPos.y = this->actor.world.pos.y + 40.0f;\\n            spawnPos.z = this->actor.world.pos.z;\\n            \\n            Actor_PlaySfx(&this->actor, NA_SE_EV_HEART_OF_GROTTO_APPEAR);\\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, 0, 0, ITEM00_HEART_PIECE);\\n                       \\n            this->actionState = 1;\\n            this->timer = 30;\\n        }\\n    } else {\\n        this->timer--;\\n        if (this->timer <= 0) {\\n            Actor_Kill(&this->actor);\\n        }\\n    }\\n}\\n\\nconst ActorProfile EnDbgHelp_Profile = {\\n    /**/ ACTOR_EN_DBG_HELP,\\n    /**/ ACTORCAT_MISC,\\n    /**/ FLAGS_NONE,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnDbgHelp),\\n    /**/ EnDbgHelp_Init,\\n    /**/ EnDbgHelp_Destroy,\\n    /**/ EnDbgHelp_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and visual effects", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 hitTimer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnHeartStatue; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_WOOD,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 45, 0, { 0, 0, 0 } },\n};\n\nvoid EnHeartStatue_Init(Actor* thisx, PlayState* play) {\n    EnHeartStatue* this = (EnHeartStatue*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\n    Actor_SetFocus(&this->actor, 45.0f);\n    \n    this->hitTimer = 0;\n    this->actionState = 0;\n    this->scale = 1.0f;\n}\n\nvoid EnHeartStatue_Destroy(Actor* thisx, PlayState* play) {\n    EnHeartStatue* this = (EnHeartStatue*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnHeartStatue_Update(Actor* thisx, PlayState* play) {\n    EnHeartStatue* this = (EnHeartStatue*)thisx;\n    \n    if (this->hitTimer > 0) {\n        this->hitTimer--;\n    }\n\n    if (this->collider.base.acFlags & AC_HIT) {\n        this->collider.base.acFlags &= ~AC_HIT;\n        \n        if (this->hitTimer <= 0) {\n            this->hitTimer = 20;\n            Actor_PlaySfx(&this->actor, NA_SE_EV_PIECE_OF_HEART);\n            \n            // Spawn heart piece using authentic EnItem00 pattern\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       this->actor.world.pos.x,\n                       this->actor.world.pos.y + 40.0f,\n                       this->actor.world.pos.z,\n                       0, 0, 0, ITEM00_HEART_PIECE);\n                       \n            Actor_Kill(&this->actor);\n        }\n    }\n\n    // Authentic collision update pattern\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnHeartStatue_Draw(Actor* thisx, PlayState* play) {\n    EnHeartStatue* this = (EnHeartStatue*)thisx;\n    \n    Matrix_Push();\n    Matrix_Scale(this->scale, this->scale, this->scale, MTXMODE_APPLY);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n    Matrix_Pop();\n}\n\nconst ActorProfile EnHeartStatue_Profile = {\n    /**/ ACTOR_EN_HEART_STATUE,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnHeartStatue),\n    /**/ EnHeartStatue_Init,\n    /**/ EnHeartStatue_Destroy,\n    /**/ EnHeartStatue_Update,\n    /**/ EnHeartStatue_Draw\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, then disappears with a particle effect", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 hitCount;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ ColliderCylinder collider;\n} EnBreakHeart; // size = 0x19C\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_WOOD,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_WOOD,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000008, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 40, 0, { 0, 0, 0 } },\n};\n\nvoid EnBreakHeart_Init(Actor* thisx, PlayState* play) {\n    EnBreakHeart* this = (EnBreakHeart*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->hitCount = 0;\n    this->actionState = 0;\n    \n    Actor_SetFocus(&this->actor, 20.0f);\n}\n\nvoid EnBreakHeart_Update(Actor* thisx, PlayState* play) {\n    EnBreakHeart* this = (EnBreakHeart*)thisx;\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    if (this->collider.base.acFlags & AC_HIT) {\n        this->hitCount++;\n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\n        \n        if (this->hitCount >= 3) {\n            Vec3f spawnPos;\n            spawnPos.x = this->actor.world.pos.x;\n            spawnPos.y = this->actor.world.pos.y;\n            spawnPos.z = this->actor.world.pos.z;\n            \n            // Spawn heart piece using authentic EnItem00 pattern\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       spawnPos.x, spawnPos.y, spawnPos.z,\n                       0, 0, 0, ITEM00_HEART_PIECE);\n                       \n            // Spawn break effect\n            EffectSsKiraKira_SpawnSmall(play, &this->actor.world.pos,\n                                       &sVelocity, &sAccel, &sPrimColor, &sEnvColor);\n            \n            Actor_Kill(&this->actor);\n        }\n    }\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 0.0f, BGCHECKFLAG_GROUND);\n}\n\nconst ActorProfile EnBreakHeart_Profile = {\n    /**/ ACTOR_EN_BREAK_HEART,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnBreakHeart),\n    /**/ EnBreakHeart_Init,\n    /**/ EnBreakHeart_Destroy,\n    /**/ EnBreakHeart_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Implement a treasure chest actor that spawns a heart piece when opened, plays sound effects, and has collision detection. The chest should only open when approached from the front.", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 openAngle;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 lidRotation;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnTreasure; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_WOOD,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_WOOD,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnTreasure_Init(Actor* thisx, PlayState* play) {\\n    EnTreasure* this = (EnTreasure*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->actionState = 0;\\n    this->lidRotation = 0.0f;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnTreasure_Update(Actor* thisx, PlayState* play) {\\n    EnTreasure* this = (EnTreasure*)thisx;\\n    Player* player = GET_PLAYER(play);\\n    Vec3f spawnPos;\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    switch(this->actionState) {\\n        case 0:\\n            if (Actor_WorldDistXYZToActor(&player->actor, &this->actor) < 100.0f &&\\n                Player_IsFacingActor(&this->actor, player, 0x2000)) {\\n                \\n                this->actionState = 1;\\n                Actor_PlaySfx(&this->actor, NA_SE_EV_TREASURE_OPEN);\\n            }\\n            break;\\n            \\n        case 1:\\n            this->lidRotation += 0.1f;\\n            if (this->lidRotation >= M_PI / 2) {\\n                this->lidRotation = M_PI / 2;\\n                this->actionState = 2;\\n                \\n                spawnPos.x = this->actor.world.pos.x;\\n                spawnPos.y = this->actor.world.pos.y + 40.0f;\\n                spawnPos.z = this->actor.world.pos.z;\\n                \\n                Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                           spawnPos.x, spawnPos.y, spawnPos.z,\\n                           0, 0, 0, ITEM00_HEART_PIECE);\\n                \\n                Actor_PlaySfx(&this->actor, NA_SE_EV_GET_ITEM);\\n            }\\n            break;\\n    }\\n}\\n\\nconst ActorProfile EnTreasure_Profile = {\\n    /**/ ACTOR_EN_TREASURE,\\n    /**/ ACTORCAT_CHEST,\\n    /**/ FLAGS,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnTreasure),\\n    /**/ EnTreasure_Init,\\n    /**/ EnTreasure_Destroy,\\n    /**/ EnTreasure_Update,\\n    /**/ EnTreasure_Draw\\n};"}
{"instruction": "Create a debugging helper actor that displays collision info and spawns a heart piece when triggered", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 debugState;\n    /* 0x0150 */ f32 detectionRange;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnDbgHelper; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnDbgHelper_Init(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->detectionRange = 100.0f;\n    Actor_SetScale(&this->actor, 0.01f);\n    this->debugState = 0;\n    this->timer = 0;\n}\n\nvoid EnDbgHelper_Update(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    f32 dist = Actor_WorldDistXYZToActor(&this->actor, &player->actor);\n    \n    if (dist < this->detectionRange) {\n        if (Player_IsFacingActor(&this->actor, player, 0x2000)) {\n            if (this->debugState == 0) {\n                Vec3f spawnPos;\n                spawnPos.x = this->actor.world.pos.x;\n                spawnPos.y = this->actor.world.pos.y + 40.0f;\n                spawnPos.z = this->actor.world.pos.z;\n                \n                Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                           spawnPos.x, spawnPos.y, spawnPos.z,\n                           0, 0, 0, ITEM00_HEART_PIECE);\n                           \n                this->debugState = 1;\n            }\n        }\n    }\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 0.0f, BGCHECKFLAG_GROUND);\n}\n\nconst ActorProfile EnDbgHelper_Profile = {\n    /**/ ACTOR_EN_DBG_HELPER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnDbgHelper),\n    /**/ EnDbgHelper_Init,\n    /**/ Actor_Destroy,\n    /**/ EnDbgHelper_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Create a complex actor that spawns rupees in a spiral pattern when hit, with proper collision detection and state management", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 spinAngle;\\n    /* 0x0154 */ s16 hitCount;\\n    /* 0x0156 */ s16 spawnDelay;\\n    /* 0x0158 */ ColliderCylinder collider;\\n} EnRupeeSpawner; // size = 0x1A4\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnRupeeSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnRupeeSpawner* this = (EnRupeeSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.02f);\\n    this->actor.targetMode = 3;\\n    Actor_SetFocus(&this->actor, 20.0f);\\n    \\n    this->timer = 0;\\n    this->actionState = 0;\\n    this->spinAngle = 0.0f;\\n    this->hitCount = 0;\\n    this->spawnDelay = 0;\\n}\\n\\nvoid EnRupeeSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnRupeeSpawner* this = (EnRupeeSpawner*)thisx;\\n    Vec3f spawnPos;\\n    \\n    this->timer++;\\n    \\n    if (this->actionState == 1) {\\n        if (this->spawnDelay-- <= 0) {\\n            this->spawnDelay = 3;\\n            this->spinAngle += 0.5f;\\n            \\n            spawnPos.x = this->actor.world.pos.x + (Math_SinS(this->spinAngle * 0x4000) * 30.0f);\\n            spawnPos.y = this->actor.world.pos.y + 40.0f;\\n            spawnPos.z = this->actor.world.pos.z + (Math_CosS(this->spinAngle * 0x4000) * 30.0f);\\n            \\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, 0, 0, ITEM00_RUPEE_BLUE);\\n            \\n            if (this->timer > 60) {\\n                this->actionState = 0;\\n                this->timer = 0;\\n            }\\n        }\\n    }\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->collider.base.acFlags &= ~AC_HIT;\\n        this->actionState = 1;\\n        this->timer = 0;\\n        this->hitCount++;\\n        \\n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\\n    }\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnRupeeSpawner_Profile = {\\n    /**/ ACTOR_EN_RUPEE_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnRupeeSpawner),\\n    /**/ EnRupeeSpawner_Init,\\n    /**/ EnRupeeSpawner_Destroy,\\n    /**/ EnRupeeSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, plays a sound effect, and disappears in a sparkle effect", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ ColliderCylinder collider;\n} EnBreakHeart; // size = 0x19C\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnBreakHeart_Init(Actor* thisx, PlayState* play) {\n    EnBreakHeart* this = (EnBreakHeart*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actionState = 0;\n    this->timer = 0;\n}\n\nvoid EnBreakHeart_Update(Actor* thisx, PlayState* play) {\n    EnBreakHeart* this = (EnBreakHeart*)thisx;\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    if (this->collider.base.acFlags & AC_HIT) {\n        // Spawn heart piece using authentic EnItem00 pattern\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   this->actor.world.pos.x,\n                   this->actor.world.pos.y,\n                   this->actor.world.pos.z,\n                   0, 0, 0, ITEM00_HEART_PIECE);\n                   \n        Actor_PlaySfx(&this->actor, NA_SE_IT_HEART_GET);\n        \n        // Spawn sparkle effect\n        EffectSsKiraKira_SpawnSmall(play, &this->actor.world.pos,\n                                   &sVelocity, &sAccel, &sPrimColor, &sEnvColor);\n                                   \n        Actor_Kill(&this->actor);\n    }\n}\n\nconst ActorProfile EnBreakHeart_Profile = {\n    /**/ ACTOR_EN_BREAK_HEART,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnBreakHeart),\n    /**/ EnBreakHeart_Init,\n    /**/ Actor_Destroy,\n    /**/ EnBreakHeart_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Implement a magical crystal actor that spins in place, periodically releases blue rupees, and can be destroyed by sword hits. It should use proper collision, track hit counts, and spawn collectibles using authentic patterns.", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 spinTimer;\\n    /* 0x014E */ s16 spawnTimer;\\n    /* 0x0150 */ s16 hitCount;\\n    /* 0x0152 */ s16 actionState;\\n    /* 0x0154 */ f32 spinAngle;\\n    /* 0x0158 */ ColliderCylinder collider;\\n} EnMagicCrystal; // size = 0x1A4\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 40, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnMagicCrystal_Init(Actor* thisx, PlayState* play) {\\n    EnMagicCrystal* this = (EnMagicCrystal*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.02f);\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->spinTimer = 0;\\n    this->spawnTimer = 0;\\n    this->hitCount = 0;\\n    this->actionState = 0;\\n    this->spinAngle = 0.0f;\\n    \\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnMagicCrystal_Update(Actor* thisx, PlayState* play) {\\n    EnMagicCrystal* this = (EnMagicCrystal*)thisx;\\n    Player* player = GET_PLAYER(play);\\n    \\n    this->spinTimer++;\\n    this->spawnTimer++;\\n    this->spinAngle += 0.1f;\\n    \\n    // Update collision\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitCount++;\\n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\\n        \\n        if (this->hitCount >= 3) {\\n            Actor_Kill(&this->actor);\\n            return;\\n        }\\n    }\\n    \\n    // Spawn rupee every 60 frames\\n    if (this->spawnTimer >= 60) {\\n        Vec3f spawnPos;\\n        spawnPos.x = this->actor.world.pos.x;\\n        spawnPos.y = this->actor.world.pos.y + 40.0f;\\n        spawnPos.z = this->actor.world.pos.z;\\n        \\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_RUPEE_BLUE);\\n                    \\n        this->spawnTimer = 0;\\n    }\\n    \\n    // Update rotation\\n    this->actor.world.rot.y += 0x0400;\\n    \\n    // Update background collision\\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\\n}\\n\\nconst ActorProfile EnMagicCrystal_Profile = {\\n    /**/ ACTOR_MAGIC_CRYSTAL,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnMagicCrystal),\\n    /**/ EnMagicCrystal_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnMagicCrystal_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create a debugging helper actor that displays collision info and spawns rupees for testing. Must follow OoT patterns exactly.", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 debugState;\n    /* 0x0150 */ f32 displayRange;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnDbgHelper; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnDbgHelper_Init(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->displayRange = 200.0f;\n    this->debugState = 0;\n    this->timer = 0;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.targetMode = 0;\n}\n\nvoid EnDbgHelper_Update(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    if (this->timer > 20) {\n        this->timer = 0;\n        \n        // Spawn test rupee if player is nearby\n        if (Actor_WorldDistXYZToActor(&player->actor, &this->actor) < this->displayRange) {\n            Vec3f spawnPos;\n            spawnPos.x = this->actor.world.pos.x;\n            spawnPos.y = this->actor.world.pos.y + 50.0f;\n            spawnPos.z = this->actor.world.pos.z;\n            \n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       spawnPos.x, spawnPos.y, spawnPos.z,\n                       0, 0, 0, ITEM00_RUPEE_BLUE);\n        }\n    }\n\n    // Update collision\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnDbgHelper_Draw(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    \n    Matrix_Push();\n    Matrix_Scale(0.01f, 0.01f, 0.01f, MTXMODE_APPLY);\n    Matrix_RotateZ(this->timer * 0.1f, MTXMODE_APPLY);\n    Matrix_NewMtx(play->state.gfxCtx, \\"}
{"instruction": "Create an actor that spawns a heart piece when hit, plays a sound, and despawns with a particle effect", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 hitCount;\\n    /* 0x0150 */ f32 scale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.02f);\\n    this->timer = 0;\\n    this->hitCount = 0;\\n    \\n    this->actor.flags |= ACTOR_FLAG_4;\\n    this->actor.targetMode = 3;\\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    this->timer++;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitCount++;\\n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\\n        \\n        if (this->hitCount >= 3) {\\n            Vec3f spawnPos;\\n            spawnPos.x = this->actor.world.pos.x;\\n            spawnPos.y = this->actor.world.pos.y;\\n            spawnPos.z = this->actor.world.pos.z;\\n            \\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                spawnPos.x, spawnPos.y, spawnPos.z,\\n                0, 0, 0, ITEM00_HEART_PIECE);\\n                \\n            Actor_Kill(&this->actor);\\n            return;\\n        }\\n    }\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ EnHeartSpawner_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ EnHeartSpawner_Draw\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and visual feedback", "output": "// Spawns heart piece when hit, with collision and effects\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 hitTimer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 scale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->hitTimer = 0;\\n    this->actionState = 0;\\n    \\n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    if (this->hitTimer > 0) {\\n        this->hitTimer--;\\n    }\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitTimer = 20;\\n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\\n        \\n        // Spawn heart piece using authentic EnItem00 pattern\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    this->actor.world.pos.x,\\n                    this->actor.world.pos.y + 40.0f,\\n                    this->actor.world.pos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n                    \\n        Actor_Kill(&this->actor);\\n    }\\n    \\n    // Authentic collision update sequence\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_NONE,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ EnHeartSpawner_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Implement a crystal switch actor that toggles between red/blue states, spawns a blue rupee when hit, and has proper collision detection. Must follow OoT patterns exactly.", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 switchState;\\n    /* 0x0150 */ f32 scale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n    /* 0x01A0 */ LightNode* lightNode;\\n    /* 0x01A4 */ LightInfo lightInfo;\\n} EnCrystalSwitch; // size = 0x1B4\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 15, 25, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnCrystalSwitch_Init(Actor* thisx, PlayState* play) {\\n    EnCrystalSwitch* this = (EnCrystalSwitch*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.1f);\\n    this->actor.focus.pos = this->actor.world.pos;\\n    this->actor.focus.pos.y += 20.0f;\\n    \\n    this->timer = 0;\\n    this->switchState = 0;\\n    \\n    // Initialize light\\n    Lights_PointNoGlowSetInfo(&this->lightInfo, this->actor.world.pos.x,\\n        this->actor.world.pos.y, this->actor.world.pos.z, 255, 0, 0, 100);\\n    this->lightNode = LightContext_InsertLight(play, &play->lightCtx, &this->lightInfo);\\n}\\n\\nvoid EnCrystalSwitch_Update(Actor* thisx, PlayState* play) {\\n    EnCrystalSwitch* this = (EnCrystalSwitch*)thisx;\\n    \\n    // Update collision\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->timer > 0) {\\n        this->timer--;\\n    }\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->collider.base.acFlags &= ~AC_HIT;\\n        \\n        if (this->timer == 0) {\\n            this->switchState ^= 1;\\n            this->timer = 30;\\n            \\n            // Spawn rupee on hit\\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                this->actor.world.pos.x,\\n                this->actor.world.pos.y + 40.0f,\\n                this->actor.world.pos.z,\\n                0, 0, 0, ITEM00_RUPEE_BLUE);\\n                \\n            Actor_PlaySfx(&this->actor, NA_SE_SY_CORRECT_CHIME);\\n        }\\n    }\\n    \\n    // Update light color based on state\\n    if (this->switchState) {\\n        this->lightInfo.params.point.color[0] = 0;\\n        this->lightInfo.params.point.color[2] = 255;\\n    } else {\\n        this->lightInfo.params.point.color[0] = 255;\\n        this->lightInfo.params.point.color[2] = 0;\\n    }\\n}\\n\\nconst ActorProfile EnCrystalSwitch_Profile = {\\n    /**/ ACTOR_EN_CRYSTAL_SWITCH,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnCrystalSwitch),\\n    /**/ EnCrystalSwitch_Init,\\n    /**/ EnCrystalSwitch_Destroy,\\n    /**/ EnCrystalSwitch_Update,\\n    /**/ EnCrystalSwitch_Draw,\\n};"}
{"instruction": "Create a debugging helper actor that displays collision info and spawns rupees for testing. Must follow OoT patterns exactly.", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 debugState;\n    /* 0x0150 */ f32 displayRange;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnDbgHelper; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnDbgHelper_Init(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->displayRange = 200.0f;\n    this->debugState = 0;\n    this->timer = 0;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.targetMode = 0;\n    this->actor.flags |= ACTOR_FLAG_0;\n}\n\nvoid EnDbgHelper_Update(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    if (this->timer > 20) {\n        this->timer = 0;\n        \n        // Spawn test rupee if player is nearby\n        if (Actor_WorldDistXYZToActor(&player->actor, &this->actor) < this->displayRange) {\n            Vec3f spawnPos;\n            spawnPos.x = this->actor.world.pos.x;\n            spawnPos.y = this->actor.world.pos.y + 40.0f;\n            spawnPos.z = this->actor.world.pos.z;\n            \n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       spawnPos.x, spawnPos.y, spawnPos.z,\n                       0, 0, 0, ITEM00_RUPEE_BLUE);\n        }\n    }\n\n    // Update collision detection\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile EnDbgHelper_Profile = {\n    /**/ ACTOR_EN_DBG_HELPER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnDbgHelper),\n    /**/ EnDbgHelper_Init,\n    /**/ EnDbgHelper_Destroy,\n    /**/ EnDbgHelper_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when hit and plays a sound effect, using authentic OoT patterns", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 hitboxScale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnHeartSpawner; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->timer = 0;\n    this->actionState = 0;\n    this->hitboxScale = 1.0f;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    Actor_SetFocus(&this->actor, 20.0f);\n}\n\nvoid EnHeartSpawner_Destroy(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\n        \n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   this->actor.world.pos.x,\n                   this->actor.world.pos.y + 40.0f,\n                   this->actor.world.pos.z,\n                   0, 0, 0, ITEM00_HEART_PIECE);\n                   \n        Actor_Kill(&this->actor);\n        return;\n    }\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnHeartSpawner_Draw(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Matrix_Push();\n    Matrix_Scale(this->hitboxScale, this->hitboxScale, this->hitboxScale, MTXMODE_APPLY);\n    Matrix_Pop();\n}\n\nconst ActorProfile EnHeartSpawner_Profile = {\n    /**/ ACTOR_EN_HEART_SPAWNER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnHeartSpawner),\n    /**/ EnHeartSpawner_Init,\n    /**/ EnHeartSpawner_Destroy, \n    /**/ EnHeartSpawner_Update,\n    /**/ EnHeartSpawner_Draw\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when Link plays Zelda's Lullaby near it, with proper collision detection and visual feedback", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 alpha;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnMusicSpot; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 30, 40, 0, { 0, 0, 0 } },\n};\n\nvoid EnMusicSpot_Init(Actor* thisx, PlayState* play) {\n    EnMusicSpot* this = (EnMusicSpot*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.targetMode = 4;\n    Actor_SetScale(&this->actor, 0.01f);\n    this->alpha = 64.0f;\n    this->actionState = 0;\n    this->timer = 0;\n}\n\nvoid EnMusicSpot_Update(Actor* thisx, PlayState* play) {\n    EnMusicSpot* this = (EnMusicSpot*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (this->actionState == 0) {\n        if (Actor_WorldDistXYZToActor(&player->actor, &this->actor) < 100.0f) {\n            if (play->msgCtx.ocarinaMode == OCARINA_MODE_04) {\n                if (play->msgCtx.lastPlayedSong == OCARINA_SONG_LULLABY) {\n                    this->actionState = 1;\n                    this->timer = 30;\n                    Actor_PlaySfx(&this->actor, NA_SE_EV_LIGHT_ARROW_HIT);\n                }\n            }\n        }\n    } else if (this->actionState == 1) {\n        this->timer--;\n        if (this->timer <= 0) {\n            Vec3f spawnPos;\n            spawnPos.x = this->actor.world.pos.x;\n            spawnPos.y = this->actor.world.pos.y + 40.0f;\n            spawnPos.z = this->actor.world.pos.z;\n            \n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       spawnPos.x, spawnPos.y, spawnPos.z,\n                       0, 0, 0, ITEM00_HEART_PIECE);\n                       \n            Actor_Kill(&this->actor);\n        }\n    }\n}\n\nconst ActorProfile EnMusicSpot_Profile = {\n    /**/ ACTOR_EN_MUSIC_SPOT,\n    /**/ ACTORCAT_MISC,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnMusicSpot),\n    /**/ EnMusicSpot_Init,\n    /**/ Actor_Destroy,\n    /**/ EnMusicSpot_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Implement a crystal switch actor that toggles between blue/red states, spawns rupees when hit, and has proper collision detection. Must follow OoT patterns exactly.", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 switchState;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n    /* 0x01A0 */ LightNode* lightNode;\n    /* 0x01A4 */ LightInfo lightInfo;\n} EnCrystalSwitch; // size = 0x1B4\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 35, 0, { 0, 0, 0 } },\n};\n\nvoid EnCrystalSwitch_Init(Actor* thisx, PlayState* play) {\n    EnCrystalSwitch* this = (EnCrystalSwitch*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.1f);\n    this->actor.world.rot.y = 0;\n    this->actor.colChkInfo.mass = 0xFF;\n    \n    this->lightNode = LightContext_InsertLight(play, &play->lightCtx, &this->lightInfo);\n    this->switchState = 0;\n    this->timer = 0;\n}\n\nvoid EnCrystalSwitch_Update(Actor* thisx, PlayState* play) {\n    EnCrystalSwitch* this = (EnCrystalSwitch*)thisx;\n    Vec3f spawnPos;\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        this->switchState ^= 1;\n        Actor_PlaySfx(&this->actor, NA_SE_SY_CORRECT_CHIME);\n        \n        // Spawn rupee reward using authentic EnItem00 pattern\n        spawnPos = this->actor.world.pos;\n        spawnPos.y += 50.0f;\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   spawnPos.x, spawnPos.y, spawnPos.z,\n                   0, 0, 0, ITEM00_RUPEE_BLUE);\n                   \n        this->timer = 30;\n    }\n    \n    if (this->timer > 0) {\n        this->timer--;\n        Actor_SetScale(&this->actor, 0.1f + Math_SinS(this->timer * 0x800) * 0.02f);\n    }\n    \n    // Update light color based on state\n    if (this->switchState) {\n        this->lightInfo.params.point.color[0] = 255;\n        this->lightInfo.params.point.color[1] = 50;\n        this->lightInfo.params.point.color[2] = 50;\n    } else {\n        this->lightInfo.params.point.color[0] = 50;\n        this->lightInfo.params.point.color[1] = 50;\n        this->lightInfo.params.point.color[2] = 255;\n    }\n}\n\nconst ActorProfile EnCrystalSwitch_Profile = {\n    /**/ ACTOR_EN_CRYSTAL_SWITCH,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnCrystalSwitch),\n    /**/ EnCrystalSwitch_Init,\n    /**/ EnCrystalSwitch_Destroy,\n    /**/ EnCrystalSwitch_Update,\n    /**/ EnCrystalSwitch_Draw\n};\n```"}
{"instruction": "Create a debugging helper actor that displays collision cylinder visualization and prints actor state info to the screen when near the player", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 debugFlags;\n    /* 0x014E */ s16 displayTimer;\n    /* 0x0150 */ f32 displayRange;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnDbgHelper; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 40, 0, { 0, 0, 0 } },\n};\n\nvoid EnDbgHelper_Init(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->displayRange = 150.0f;\n    this->debugFlags = 0;\n    this->displayTimer = 0;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.targetMode = 0;\n    this->actor.flags &= ~ACTOR_FLAG_0;\n}\n\nvoid EnDbgHelper_Destroy(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnDbgHelper_Update(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    if (Actor_WorldDistXYZToActor(&player->actor, &this->actor) < this->displayRange) {\n        this->displayTimer = 30;\n        \n        // Update collision checking\n        Collider_UpdateCylinder(&this->actor, &this->collider);\n        CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n        \n        // Update debug visualization\n        Matrix_Push();\n        Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z, MTXMODE_NEW);\n        Matrix_Scale(0.1f, 0.1f, 0.1f, MTXMODE_APPLY);\n        Matrix_NewMtx(play->state.gfxCtx, \\"}
{"instruction": "Create an actor that spawns rupees in a spiral pattern when hit, with proper collision detection and state management", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 hitCount;\\n    /* 0x0150 */ f32 rotationAngle;\\n    /* 0x0154 */ f32 spiralRadius;\\n    /* 0x0158 */ ColliderCylinder collider;\\n} EnRupeeSpawner; // size = 0x1A4\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnRupeeSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnRupeeSpawner* this = (EnRupeeSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.02f);\\n    this->timer = 0;\\n    this->hitCount = 0;\\n    this->rotationAngle = 0.0f;\\n    this->spiralRadius = 30.0f;\\n    \\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnRupeeSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnRupeeSpawner* this = (EnRupeeSpawner*)thisx;\\n    Vec3f spawnPos;\\n    \\n    this->timer++;\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitCount++;\\n        this->collider.base.acFlags &= ~AC_HIT;\\n        \\n        // Spawn rupees in spiral\\n        for (s32 i = 0; i < 5; i++) {\\n            f32 angle = this->rotationAngle + (i * (M_PI / 2.5f));\\n            \\n            spawnPos.x = this->actor.world.pos.x + (Math_SinS(angle) * this->spiralRadius);\\n            spawnPos.y = this->actor.world.pos.y + 40.0f;\\n            spawnPos.z = this->actor.world.pos.z + (Math_CosS(angle) * this->spiralRadius);\\n            \\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, 0, 0, ITEM00_RUPEE_BLUE);\\n        }\\n        \\n        this->rotationAngle += M_PI / 4;\\n        Actor_PlaySfx(&this->actor, NA_SE_EV_BOMB_BOUND);\\n        \\n        if (this->hitCount >= 3) {\\n            Actor_Kill(&this->actor);\\n        }\\n    }\\n}\\n\\nconst ActorProfile EnRupeeSpawner_Profile = {\\n    /**/ ACTOR_EN_RUPEE_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnRupeeSpawner),\\n    /**/ EnRupeeSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnRupeeSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, with proper collision detection and visual feedback", "output": "// Authentic pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 hitTimer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 scale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->hitTimer = 0;\\n    this->actionState = 0;\\n    \\n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    if (this->hitTimer > 0) {\\n        this->hitTimer--;\\n    }\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitTimer = 10;\\n        \\n        // Spawn heart piece using authentic EnItem00 pattern\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    this->actor.world.pos.x,\\n                    this->actor.world.pos.y + 40.0f,\\n                    this->actor.world.pos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n                    \\n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\\n    }\\n    \\n    // Authentic collision update sequence\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ EnHeartSpawner_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Implement a rotating platform actor that spawns a heart piece when hit by the player's sword, with proper collision detection and visual feedback.", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 rotationAngle;\n    /* 0x014E */ s16 hitTimer;\n    /* 0x0150 */ f32 rotationSpeed;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnRotPlatform; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_WOOD,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_WOOD,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 50, 20, 0, { 0, 0, 0 } },\n};\n\nvoid EnRotPlatform_Init(Actor* thisx, PlayState* play) {\n    EnRotPlatform* this = (EnRotPlatform*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.1f);\n    \n    this->rotationAngle = 0;\n    this->hitTimer = 0;\n    this->rotationSpeed = 2.0f;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\n    Actor_SetFocus(&this->actor, 20.0f);\n}\n\nvoid EnRotPlatform_Destroy(Actor* thisx, PlayState* play) {\n    EnRotPlatform* this = (EnRotPlatform*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnRotPlatform_Update(Actor* thisx, PlayState* play) {\n    EnRotPlatform* this = (EnRotPlatform*)thisx;\n    \n    this->rotationAngle += (s16)(this->rotationSpeed * 0x100);\n    this->actor.world.rot.y = this->rotationAngle;\n    \n    if (this->hitTimer > 0) {\n        this->hitTimer--;\n        if (this->hitTimer == 0) {\n            Vec3f spawnPos;\n            spawnPos.x = this->actor.world.pos.x;\n            spawnPos.y = this->actor.world.pos.y + 40.0f;\n            spawnPos.z = this->actor.world.pos.z;\n            \n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       spawnPos.x, spawnPos.y, spawnPos.z,\n                       0, 0, 0, ITEM00_HEART_PIECE);\n            \n            Actor_Kill(&this->actor);\n            return;\n        }\n    }\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        this->collider.base.acFlags &= ~AC_HIT;\n        this->hitTimer = 20;\n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\n    }\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnRotPlatform_Draw(Actor* thisx, PlayState* play) {\n    EnRotPlatform* this = (EnRotPlatform*)thisx;\n    \n    Matrix_Push();\n    Matrix_RotateY(BINANG_TO_RAD(this->actor.world.rot.y), MTXMODE_APPLY);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, this->actor.scale.z, MTXMODE_APPLY);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n              \n    Matrix_Pop();\n}\n\nconst ActorProfile EnRotPlatform_Profile = {\n    /**/ ACTOR_EN_ROT_PLATFORM,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnRotPlatform),\n    /**/ EnRotPlatform_Init,\n    /**/ EnRotPlatform_Destroy,\n    /**/ EnRotPlatform_Update,\n    /**/ EnRotPlatform_Draw\n};\n```"}
{"instruction": "Create a debugging helper actor that displays collision cylinder visualization and prints distance to player when within range", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 debugTimer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 detectionRange;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnDbgHelper; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 40, 0, { 0, 0, 0 } },\n};\n\nvoid EnDbgHelper_Init(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->debugTimer = 0;\n    this->actionState = 0;\n    this->detectionRange = 150.0f;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.world.pos.y += 40.0f;\n}\n\nvoid EnDbgHelper_Update(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    Player* player = GET_PLAYER(play);\n    f32 distToPlayer;\n    \n    this->debugTimer++;\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 0.0f, BGCHECKFLAG_GROUND);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    distToPlayer = Actor_WorldDistXYZToActor(&this->actor, &player->actor);\n    \n    if (distToPlayer < this->detectionRange) {\n        // Print debug info when in range\n        osSyncPrintf(\\"}
{"instruction": "Create an actor that spawns a heart piece when hit and plays a chime sound, using authentic OoT patterns", "output": "// Authentic actor pattern following z_actor.c and z_en_item00.c\\n\\ntypedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 hitCount;\\n    /* 0x0150 */ f32 scale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetScale(&this->actor, 0.015f);\\n    Actor_SetFocus(&this->actor, 20.0f);\\n    \\n    this->timer = 0;\\n    this->hitCount = 0;\\n    this->scale = 1.0f;\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    this->timer++;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitCount++;\\n        Actor_PlaySfx(&this->actor, NA_SE_IT_HEART_GET);\\n        \\n        // Spawn heart piece using authentic EnItem00 pattern\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    this->actor.world.pos.x,\\n                    this->actor.world.pos.y + 40.0f,\\n                    this->actor.world.pos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n                    \\n        Actor_Kill(&this->actor);\\n        return;\\n    }\\n    \\n    // Authentic collision update pattern\\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_NONE,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ EnHeartSpawner_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create a simple actor that spawns a heart piece when hit by the player's sword, plays a sound effect, and disappears", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ ColliderCylinder collider;\n} EnBreakHeart; // size = 0x19C\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnBreakHeart_Init(Actor* thisx, PlayState* play) {\n    EnBreakHeart* this = (EnBreakHeart*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actionState = 0;\n    this->timer = 0;\n}\n\nvoid EnBreakHeart_Update(Actor* thisx, PlayState* play) {\n    EnBreakHeart* this = (EnBreakHeart*)thisx;\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    if (this->collider.base.acFlags & AC_HIT) {\n        Vec3f spawnPos;\n        spawnPos.x = this->actor.world.pos.x;\n        spawnPos.y = this->actor.world.pos.y;\n        spawnPos.z = this->actor.world.pos.z;\n        \n        Actor_PlaySfx(&this->actor, NA_SE_EV_ITEM_APPEAR);\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   spawnPos.x, spawnPos.y, spawnPos.z,\n                   0, 0, 0, ITEM00_HEART_PIECE);\n                   \n        Actor_Kill(&this->actor);\n    }\n}\n\nconst ActorProfile EnBreakHeart_Profile = {\n    /**/ ACTOR_EN_BREAK_HEART,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnBreakHeart),\n    /**/ EnBreakHeart_Init,\n    /**/ Actor_Destroy,\n    /**/ EnBreakHeart_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Implement a magical crystal actor that floats, rotates, and spawns a heart piece when hit by the player's sword. It should use proper collision detection and particle effects.", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 rotationAngle;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 floatHeight;\\n    /* 0x0154 */ f32 floatPhase;\\n    /* 0x0158 */ ColliderCylinder collider;\\n} EnMagicCrystal; // size = 0x1A4\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 40, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnMagicCrystal_Init(Actor* thisx, PlayState* play) {\\n    EnMagicCrystal* this = (EnMagicCrystal*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.02f);\\n    \\n    this->actor.flags |= ACTOR_FLAG_0;\\n    this->actor.targetMode = 4;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->rotationAngle = 0;\\n    this->actionState = 0;\\n    this->floatHeight = this->actor.world.pos.y;\\n    this->floatPhase = 0.0f;\\n    \\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnMagicCrystal_Update(Actor* thisx, PlayState* play) {\\n    EnMagicCrystal* this = (EnMagicCrystal*)thisx;\\n    Player* player = GET_PLAYER(play);\\n    Vec3f spawnPos;\\n    \\n    this->rotationAngle += 0x0400;\\n    this->floatPhase += 0.1f;\\n    \\n    this->actor.world.pos.y = this->floatHeight + (Math_SinS(this->floatPhase * 0x800) * 5.0f);\\n    this->actor.shape.rot.y = this->rotationAngle;\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->collider.base.acFlags &= ~AC_HIT;\\n        \\n        if (this->actionState == 0) {\\n            this->actionState = 1;\\n            \\n            Actor_PlaySfx(&this->actor, NA_SE_EV_CRYSTAL_BROKEN);\\n            \\n            spawnPos = this->actor.world.pos;\\n            spawnPos.y += 40.0f;\\n            \\n            // Spawn heart piece using authentic EnItem00 pattern\\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       spawnPos.x, spawnPos.y, spawnPos.z,\\n                       0, 0, 0, ITEM00_HEART_PIECE);\\n                       \\n            Actor_Kill(&this->actor);\\n            return;\\n        }\\n    }\\n    \\n    // Update collision\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnMagicCrystal_Profile = {\\n    /**/ ACTOR_MAGIC_CRYSTAL,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnMagicCrystal),\\n    /**/ EnMagicCrystal_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnMagicCrystal_Update,\\n    /**/ NULL\\n};"}
{"instruction": "Create a debug actor that displays collision info and spawns rupees for testing", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 debugState;\n    /* 0x0150 */ f32 detectionRange;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnDebugHelp; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnDebugHelp_Init(Actor* thisx, PlayState* play) {\n    EnDebugHelp* this = (EnDebugHelp*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->timer = 0;\n    this->debugState = 0;\n    this->detectionRange = 100.0f;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    Actor_SetFocus(&this->actor, 20.0f);\n    \n    this->actor.world.pos.y += 20.0f;\n}\n\nvoid EnDebugHelp_Update(Actor* thisx, PlayState* play) {\n    EnDebugHelp* this = (EnDebugHelp*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    // Update collision detection\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Spawn test rupee when player is nearby and presses B\n    if (Actor_WorldDistXYZToActor(&player->actor, &this->actor) < this->detectionRange) {\n        if (CHECK_BTN_ALL(play->state.input[0].press.button, BTN_B)) {\n            Vec3f spawnPos;\n            spawnPos.x = this->actor.world.pos.x;\n            spawnPos.y = this->actor.world.pos.y + 20.0f;\n            spawnPos.z = this->actor.world.pos.z;\n            \n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       spawnPos.x, spawnPos.y, spawnPos.z,\n                       0, 0, 0, ITEM00_RUPEE_BLUE);\n        }\n    }\n}\n\nconst ActorProfile EnDebugHelp_Profile = {\n    /**/ ACTOR_EN_DEBUG_HELP,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnDebugHelp),\n    /**/ EnDebugHelp_Init,\n    /**/ Actor_Destroy,\n    /**/ EnDebugHelp_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, plays a sound, and then disappears with a particle effect", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnHeartSpawner; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 15, 25, 0, { 0, 0, 0 } },\n};\n\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.colChkInfo.mass = 0;\n    this->actionState = 0;\n    this->timer = 0;\n    \n    Actor_SetFocus(&this->actor, 20.0f);\n}\n\nvoid EnHeartSpawner_Destroy(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        Actor_PlaySfx(&this->actor, NA_SE_EV_HEART_OF_GROTTO_APPEAR);\n        \n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   this->actor.world.pos.x,\n                   this->actor.world.pos.y,\n                   this->actor.world.pos.z,\n                   0, 0, 0, ITEM00_HEART_PIECE);\n                   \n        EffectSsDeadDb_Spawn(play, &this->actor.world.pos,\n                            &gZeroVec, &gZeroVec,\n                            100, 0, 255, 255, 255, 255,\n                            0, 0, 0, 1, 9, true);\n                            \n        Actor_Kill(&this->actor);\n    }\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n}\n\nvoid EnHeartSpawner_Draw(Actor* thisx, PlayState* play) {\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\n    \n    Matrix_Push();\n    Matrix_Scale(0.01f, 0.01f, 0.01f, MTXMODE_APPLY);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, \\"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, plays a sound effect, and disappears in a puff of smoke", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 hitCount;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ ColliderCylinder collider;\n} EnBreakHeart; // size = 0x19C\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnBreakHeart_Init(Actor* thisx, PlayState* play) {\n    EnBreakHeart* this = (EnBreakHeart*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->hitCount = 0;\n    this->actionState = 0;\n    \n    this->actor.world.rot.y = 0;\n    this->actor.shape.rot = this->actor.world.rot;\n}\n\nvoid EnBreakHeart_Update(Actor* thisx, PlayState* play) {\n    EnBreakHeart* this = (EnBreakHeart*)thisx;\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        this->hitCount++;\n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\n        \n        if (this->hitCount >= 3) {\n            Vec3f spawnPos;\n            spawnPos.x = this->actor.world.pos.x;\n            spawnPos.y = this->actor.world.pos.y;\n            spawnPos.z = this->actor.world.pos.z;\n            \n            // Spawn heart piece using authentic EnItem00\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       spawnPos.x, spawnPos.y, spawnPos.z,\n                       0, 0, 0, ITEM00_HEART_PIECE);\n                       \n            Actor_PlaySfx(&this->actor, NA_SE_EV_ITEM_APPEAR);\n            Actor_Kill(&this->actor);\n            return;\n        }\n    }\n    \n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile EnBreakHeart_Profile = {\n    /**/ ACTOR_EN_BREAK_HEART,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnBreakHeart),\n    /**/ EnBreakHeart_Init,\n    /**/ Actor_Destroy,\n    /**/ EnBreakHeart_Update,\n    /**/ NULL\n};\n```"}
{"instruction": "Implement a treasure chest actor that spawns a heart piece when opened, plays the chest opening animation, and handles player interaction with proper collision", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 openingState;\\n    /* 0x014E */ s16 lidAngle;\\n    /* 0x0150 */ f32 animProgress;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnTreasureChest; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_WOOD,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_WOOD,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 30, 40, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnTreasureChest_Init(Actor* thisx, PlayState* play) {\\n    EnTreasureChest* this = (EnTreasureChest*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    this->openingState = 0;\\n    this->lidAngle = 0;\\n    this->animProgress = 0.0f;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnTreasureChest_Update(Actor* thisx, PlayState* play) {\\n    EnTreasureChest* this = (EnTreasureChest*)thisx;\\n    Player* player = GET_PLAYER(play);\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    switch(this->openingState) {\\n        case 0: // Closed\\n            if (Actor_WorldDistXYZToActor(&player->actor, &this->actor) < 80.0f &&\\n                Player_IsFacingActor(&this->actor, player, 0x2000)) {\\n                \\n                this->openingState = 1;\\n                Actor_PlaySfx(&this->actor, NA_SE_EV_TREASURE_BOX_OPEN);\\n            }\\n            break;\\n            \\n        case 1: // Opening\\n            this->lidAngle += 0x200;\\n            if (this->lidAngle >= 0x4000) {\\n                this->lidAngle = 0x4000;\\n                this->openingState = 2;\\n                \\n                Vec3f spawnPos;\\n                spawnPos.x = this->actor.world.pos.x;\\n                spawnPos.y = this->actor.world.pos.y + 40.0f;\\n                spawnPos.z = this->actor.world.pos.z;\\n                \\n                Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n            }\\n            break;\\n            \\n        case 2: // Opened\\n            break;\\n    }\\n}\\n\\nconst ActorProfile EnTreasureChest_Profile = {\\n    /**/ ACTOR_EN_TREASURE_CHEST,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_NONE,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnTreasureChest),\\n    /**/ EnTreasureChest_Init,\\n    /**/ EnTreasureChest_Destroy,\\n    /**/ EnTreasureChest_Update,\\n    /**/ EnTreasureChest_Draw\\n};"}
{"instruction": "Create a debugging helper actor that displays collision info and spawns rupees for testing. Must follow authentic OoT patterns.", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 debugState;\n    /* 0x0150 */ f32 displayRange;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnDbgHelper; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_UNK0,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnDbgHelper_Init(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->displayRange = 200.0f;\n    this->debugState = 0;\n    this->timer = 0;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.world.pos.y += 20.0f;\n}\n\nvoid EnDbgHelper_Update(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    if (this->timer > 30) {\n        this->timer = 0;\n        \n        // Spawn test rupee if player is nearby\n        if (Actor_WorldDistXYZToActor(&player->actor, &this->actor) < this->displayRange) {\n            Vec3f spawnPos;\n            spawnPos.x = this->actor.world.pos.x;\n            spawnPos.y = this->actor.world.pos.y + 50.0f;\n            spawnPos.z = this->actor.world.pos.z;\n            \n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                       spawnPos.x, spawnPos.y, spawnPos.z,\n                       0, 0, 0, ITEM00_RUPEE_BLUE);\n        }\n    }\n\n    // Update collision\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnDbgHelper_Draw(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    \n    Matrix_Push();\n    Matrix_Scale(0.01f, 0.01f, 0.01f, MTXMODE_APPLY);\n    Matrix_RotateZ(this->timer * 0.1f, MTXMODE_APPLY);\n    Matrix_NewMtx(play->state.gfxCtx, \\"}
{"instruction": "Create an actor that spawns a heart piece when hit, plays a sound, and despawns after a timer", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 hitCount;\\n    /* 0x0150 */ f32 hitboxScale;\\n    /* 0x0154 */ ColliderCylinder collider;\\n} EnHeartSpawner; // size = 0x1A0\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_NONE,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\\n        { 0x00000010, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_NONE,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 30, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnHeartSpawner_Init(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    this->timer = 300;\\n    this->hitCount = 0;\\n    this->hitboxScale = 1.0f;\\n    \\n    Actor_SetScale(&this->actor, 0.01f);\\n    Actor_SetFocus(&this->actor, 20.0f);\\n}\\n\\nvoid EnHeartSpawner_Update(Actor* thisx, PlayState* play) {\\n    EnHeartSpawner* this = (EnHeartSpawner*)thisx;\\n    Vec3f spawnPos;\\n    \\n    this->timer--;\\n    if (this->timer <= 0) {\\n        Actor_Kill(&this->actor);\\n        return;\\n    }\\n    \\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n    \\n    if (this->collider.base.acFlags & AC_HIT) {\\n        this->hitCount++;\\n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\\n        \\n        spawnPos = this->actor.world.pos;\\n        spawnPos.y += 40.0f;\\n        \\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                    spawnPos.x, spawnPos.y, spawnPos.z,\\n                    0, 0, 0, ITEM00_HEART_PIECE);\\n                    \\n        Actor_Kill(&this->actor);\\n    }\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\\n}\\n\\nconst ActorProfile EnHeartSpawner_Profile = {\\n    /**/ ACTOR_EN_HEART_SPAWNER,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnHeartSpawner),\\n    /**/ EnHeartSpawner_Init,\\n    /**/ Actor_Destroy,\\n    /**/ EnHeartSpawner_Update,\\n    /**/ NULL,\\n};"}
{"instruction": "Create an actor that spawns a heart piece when hit by the player's sword, plays a sound effect, and disappears with a particle effect", "output": "```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ ColliderCylinder collider;\n} EnBreakHeart; // size = 0x19C\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COL_MATERIAL_WOOD,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEM_MATERIAL_WOOD,\n        { 0x00000000, HIT_SPECIAL_EFFECT_NONE, 0x00 },\n        { 0x00000020, HIT_BACKLASH_NONE, 0x00 },\n        ATELEM_NONE,\n        ACELEM_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnBreakHeart_Init(Actor* thisx, PlayState* play) {\n    EnBreakHeart* this = (EnBreakHeart*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actionState = 0;\n    this->timer = 0;\n}\n\nvoid EnBreakHeart_Update(Actor* thisx, PlayState* play) {\n    EnBreakHeart* this = (EnBreakHeart*)thisx;\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    if (this->collider.base.acFlags & AC_HIT) {\n        // Spawn heart piece using authentic EnItem00 pattern\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                   this->actor.world.pos.x,\n                   this->actor.world.pos.y,\n                   this->actor.world.pos.z,\n                   0, 0, 0, ITEM00_HEART_PIECE);\n                   \n        Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\n        \n        EffectSsDeadDb_Spawn(play, &this->actor.world.pos,\n                            &gZeroVec, &gZeroVec,\n                            100, 0, 255, 255, 255, 255,\n                            0, 0, 0, 1, 9, true);\n                            \n        Actor_Kill(&this->actor);\n    }\n}\n\nconst ActorProfile EnBreakHeart_Profile = {\n    /**/ ACTOR_EN_BREAK_HEART,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnBreakHeart),\n    /**/ EnBreakHeart_Init,\n    /**/ Actor_Destroy,\n    /**/ EnBreakHeart_Update,\n    /**/ NULL,\n};\n```"}
{"instruction": "Implement a magical crystal actor that spins in place, periodically spawns blue rupees, and has cylinder collision that damages enemies. When hit by the player's sword, it shatters and drops a heart piece.", "output": "typedef struct {\\n    /* 0x0000 */ Actor actor;\\n    /* 0x014C */ s16 timer;\\n    /* 0x014E */ s16 actionState;\\n    /* 0x0150 */ f32 rotationSpeed;\\n    /* 0x0154 */ f32 scale;\\n    /* 0x158 */ ColliderCylinder collider;\\n} EnMagicCrystal; // size = 0x1A4\\n\\nstatic ColliderCylinderInit sCylinderInit = {\\n    {\\n        COL_MATERIAL_NONE,\\n        AT_ON | AT_TYPE_ENEMY,\\n        AC_ON | AC_TYPE_PLAYER,\\n        OC1_ON | OC1_TYPE_ALL,\\n        OC2_TYPE_1,\\n        COLSHAPE_CYLINDER,\\n    },\\n    {\\n        ELEM_MATERIAL_UNK0,\\n        { 0x20, HIT_SPECIAL_EFFECT_NONE, 0x01 },\\n        { 0x08, HIT_BACKLASH_NONE, 0x00 },\\n        ATELEM_ON,\\n        ACELEM_ON,\\n        OCELEM_ON,\\n    },\\n    { 20, 40, 0, { 0, 0, 0 } },\\n};\\n\\nvoid EnMagicCrystal_Init(Actor* thisx, PlayState* play) {\\n    EnMagicCrystal* this = (EnMagicCrystal*)thisx;\\n    \\n    Actor_SetScale(&this->actor, 0.02f);\\n    this->rotationSpeed = 0.1f;\\n    this->timer = 0;\\n    this->actionState = 0;\\n    \\n    Collider_InitCylinder(play, &this->collider);\\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\\n    \\n    Actor_SetFocus(&this->actor, 20.0f);\\n    this->actor.colChkInfo.mass = 0xFF;\\n}\\n\\nvoid EnMagicCrystal_Destroy(Actor* thisx, PlayState* play) {\\n    EnMagicCrystal* this = (EnMagicCrystal*)thisx;\\n    Collider_DestroyCylinder(play, &this->collider);\\n}\\n\\nvoid EnMagicCrystal_Update(Actor* thisx, PlayState* play) {\\n    EnMagicCrystal* this = (EnMagicCrystal*)thisx;\\n    \\n    this->actor.world.rot.y += (s16)(this->rotationSpeed * 0x4000);\\n    \\n    if (this->timer++ >= 100) {\\n        Vec3f spawnPos = this->actor.world.pos;\\n        spawnPos.y += 40.0f;\\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                   spawnPos.x, spawnPos.y, spawnPos.z,\\n                   0, 0, 0, ITEM00_RUPEE_BLUE);\\n        this->timer = 0;\\n    }\\n    \\n    if (this->actionState == 0) {\\n        if (this->collider.base.acFlags & AC_HIT) {\\n            Vec3f pos = this->actor.world.pos;\\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\\n                       pos.x, pos.y, pos.z,\\n                       0, 0, 0, ITEM00_HEART_PIECE);\\n            Actor_PlaySfx(&this->actor, NA_SE_IT_SWORD_STRIKE);\\n            Actor_Kill(&this->actor);\\n            return;\\n        }\\n    }\\n    \\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 10.0f, 0.0f, BGCHECKFLAG_GROUND);\\n    Collider_UpdateCylinder(&this->actor, &this->collider);\\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\\n}\\n\\nconst ActorProfile EnMagicCrystal_Profile = {\\n    /**/ ACTOR_EN_MAGIC_CRYSTAL,\\n    /**/ ACTORCAT_PROP,\\n    /**/ FLAGS_0,\\n    /**/ OBJECT_GAMEPLAY_KEEP,\\n    /**/ sizeof(EnMagicCrystal),\\n    /**/ EnMagicCrystal_Init,\\n    /**/ EnMagicCrystal_Destroy,\\n    /**/ EnMagicCrystal_Update,\\n    /**/ NULL\\n};"}
