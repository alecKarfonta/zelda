{"instruction": "Create a actor creation system", "output": "{\n  \"instruction\": \"What's the best way to create a stone gargoyle that mirror the player's equipped weapon and abilities? using conditional logic with basic error checking\",\n  \"input\": null,\n  \"output\": \"```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 actionState;\n    /* 0x014E */ s16 timer;\n    /* 0x0150 */ ColliderCylinder collider;\n    /* 0x019C */ SkelAnime skelAnime;\n    /* 0x01E0 */ Vec3s jointTable[20];\n    /* 0x0248 */ Vec3s morphTable[20];\n} EnGargoyle; // size = 0x2B0\n\nvoid EnGargoyle_Init(Actor* thisx, PlayState* play) {\n    EnGargoyle* this = (EnGargoyle*)thisx;\n    \n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 30.0f);\n    SkelAnime_InitFlex(play, &this->skelAnime, &gGargoyleSkel, &gGargoyleIdleAnim, \n                       this->jointTable, this->morphTable, 20);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnGargoyle_Update(Actor* thisx, PlayState* play) {\n    EnGargoyle* this = (EnGargoyle*)thisx;\n    Player* player = GET_PLAYER(play);\n    s16 mirrorWeapon = SWORD_NONE;\n    s16 mirrorShield = SHIELD_NONE;\n    \n    // Mirror player's equipped sword\n    if (gSaveContext.equips.buttonItems[0] == ITEM_SWORD_KOKIRI) {\n        mirrorWeapon = SWORD_KOKIRI;\n    } else if (gSaveContext.equips.buttonItems[0] == ITEM_SWORD_MASTER) {\n        mirrorWeapon = SWORD_MASTER;\n    } else if (gSaveContext.equips.buttonItems[0] == ITEM_SWORD_BIGGORON) {\n        mirrorWeapon = SWORD_BIGGORON;\n    }\n    \n    // Mirror player's equipped shield\n    if (gSaveContext.equips.buttonItems[1] == ITEM_SHIELD_DEKU) {\n        mirrorShield = SHIELD_DEKU;\n    } else if (gSaveContext.equips.buttonItems[1] == ITEM_SHIELD_HYLIAN) {\n        mirrorShield = SHIELD_HYLIAN;\n    } else if (gSaveContext.equips.buttonItems[1] == ITEM_SHIELD_MIRROR) {\n        mirrorShield = SHIELD_MIRROR;\n    }\n    \n    // Basic state machine\n    switch(this->actionState) {\n        case 0: // Idle\n            SkelAnime_Update(&this->skelAnime);\n            if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 100.0f) {\n                this->actionState = 1;\n            }\n            break;\n            \n        case 1: // Activated\n            if (mirrorWeapon != SWORD_NONE || mirrorShield != SHIELD_NONE) {\n                Math_SmoothStepToF(&this->actor.scale.x, 0.02f, 0.1f, 0.01f, 0.0f);\n                this->actor.scale.y = this->actor.scale.z = this->actor.scale.x;\n            }\n            break;\n    }\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnGargoyle_Draw(Actor* thisx, PlayState* play) {\n    EnGargoyle* this = (EnGargoyle*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n              \n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                          this->skelAnime.dListCount, NULL, NULL, this);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Gargoyle_InitVars = {\n    /**/ ACTOR_EN_GARGOYLE,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GARGOYLE,\n    /**/ sizeof(EnGargoyle),\n    /**/ EnGargoyle_Init,\n    /**/ EnGargoyle_Destroy,\n    /**/ EnGargoyle_Update,\n    /**/ EnGargoyle_Draw\n};\n```\"\n}"}
{"instruction": "Create an advanced code explanation with multiple features with extensive error handling and edge cases", "output": "/* Advanced example showing proper error handling and edge cases */\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 floatHeight;\n    /* 0x0154 */ f32 bobOffset;\n    /* 0x158 */ s16 oscillationAngle;\n    /* 0x15A */ s16 interactState;\n    /* 0x15C */ ColliderCylinder collider;\n} EnFloatingItem; // size = 0x1A8\n\n#define FLOAT_HEIGHT_DEFAULT 60.0f\n#define BOB_SPEED 1500\n#define BOB_AMPLITUDE 5.0f\n\nenum {\n    /* 0 */ FLOATING_STATE_IDLE,\n    /* 1 */ FLOATING_STATE_INTERACT,\n    /* 2 */ FLOATING_STATE_GIVE\n};\n\nvoid EnFloatingItem_Init(Actor* thisx, PlayState* play) {\n    EnFloatingItem* this = (EnFloatingItem*)thisx;\n    \n    // Safe collision initialization with error check\n    if (Collider_InitCylinder(play, &this->collider) == NULL) {\n        Actor_Kill(&this->actor);\n        return;\n    }\n    \n    if (Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit) == NULL) {\n        // Clean up if cylinder setup fails\n        Actor_Kill(&this->actor);\n        return;\n    }\n\n    this->floatHeight = FLOAT_HEIGHT_DEFAULT;\n    this->oscillationAngle = 0;\n    this->actionState = FLOATING_STATE_IDLE;\n    this->interactState = 0;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnFloatingItem_Update(Actor* thisx, PlayState* play) {\n    EnFloatingItem* this = (EnFloatingItem*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    // Update oscillation for floating effect\n    this->oscillationAngle = (this->oscillationAngle + BOB_SPEED) % 0x10000;\n    this->bobOffset = Math_SinS(this->oscillationAngle) * BOB_AMPLITUDE;\n    \n    // Update position with bob offset\n    this->actor.world.pos.y = this->actor.home.pos.y + this->floatHeight + this->bobOffset;\n    \n    // Player interaction check with distance threshold\n    f32 playerDist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    switch(this->actionState) {\n        case FLOATING_STATE_IDLE:\n            if (playerDist < 100.0f) {\n                this->actionState = FLOATING_STATE_INTERACT;\n            }\n            break;\n            \n        case FLOATING_STATE_INTERACT:\n            if (playerDist >= 100.0f) {\n                this->actionState = FLOATING_STATE_IDLE;\n                break;\n            }\n            \n            // Check if player has required items\n            if (!(gSaveContext.inventory.items[SLOT_OCARINA] == ITEM_OCARINA_TIME)) {\n                break;\n            }\n            \n            this->actionState = FLOATING_STATE_GIVE;\n            break;\n            \n        case FLOATING_STATE_GIVE:\n            Actor_Kill(&this->actor);\n            break;\n    }\n    \n    // Update collision checking\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile EnFloatingItem_Profile = {\n    /**/ ACTOR_EN_FLOATING_ITEM,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnFloatingItem),\n    /**/ EnFloatingItem_Init,\n    /**/ EnFloatingItem_Destroy,\n    /**/ EnFloatingItem_Update,\n    /**/ EnFloatingItem_Draw\n};"}
{"instruction": "Create an advanced memory management with multiple features with minimal features", "output": "// Simple memory manager using OoT's authentic memory patterns\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 memoryTimer;\n    /* 0x014E */ s16 memoryState;\n    /* 0x0150 */ f32 scale;\n    /* 0x154 */ u8* memBlock; // Pre-allocated fixed memory block\n    /* 0x158 */ s32 blockSize;\n    /* 0x15C */ ColliderCylinder collider;\n} EnMemMgr; // size = 0x1A8\n\n// Fixed memory block size - using specific number as per requirements\n#define MEMORY_BLOCK_SIZE 0x400\n\nvoid EnMemMgr_Init(Actor* thisx, PlayState* play) {\n    EnMemMgr* this = (EnMemMgr*)thisx;\n    \n    // Authentic collision setup\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    // Standard actor initialization\n    Actor_SetScale(&this->actor, 0.01f);\n    \n    // Pre-allocate fixed memory block using authentic ZeldaArena\n    this->memBlock = ZeldaArena_Malloc(MEMORY_BLOCK_SIZE);\n    this->blockSize = MEMORY_BLOCK_SIZE;\n    this->memoryState = 0;\n    this->memoryTimer = 0;\n}\n\nvoid EnMemMgr_Destroy(Actor* thisx, PlayState* play) {\n    EnMemMgr* this = (EnMemMgr*)thisx;\n    \n    // Free pre-allocated memory\n    if (this->memBlock != NULL) {\n        ZeldaArena_Free(this->memBlock);\n        this->memBlock = NULL;\n    }\n    \n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnMemMgr_Update(Actor* thisx, PlayState* play) {\n    EnMemMgr* this = (EnMemMgr*)thisx;\n    \n    // Basic state machine\n    switch (this->memoryState) {\n        case 0:\n            if (this->memoryTimer++ > 20) {\n                this->memoryTimer = 0;\n                this->memoryState++;\n            }\n            break;\n            \n        case 1:\n            // Simple memory validation\n            if (this->memBlock != NULL) {\n                this->memoryState = 0;\n            }\n            break;\n    }\n    \n    // Standard collision updates\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnMemMgr_Draw(Actor* thisx, PlayState* play) {\n    EnMemMgr* this = (EnMemMgr*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__), \n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_MemMgr_InitVars = {\n    /**/ ACTOR_EN_MEMMGR,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnMemMgr),\n    /**/ EnMemMgr_Init,\n    /**/ EnMemMgr_Destroy,\n    /**/ EnMemMgr_Update,\n    /**/ EnMemMgr_Draw\n};"}
{"instruction": "Create a feature implementation system", "output": "{\n  \"instruction\": \"Make a feature implementation that follows OoT decompilation standards using advanced memory management\",\n  \"input\": null,\n  \"output\": \"// Advanced memory management example following OoT patterns\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 state;\n    /* 0x0150 */ SkelAnime skelAnime;\n    /* 0x0194 */ Vec3s jointTable[20];\n    /* 0x01DC */ Vec3s morphTable[20];\n    /* 0x0224 */ ColliderCylinder collider;\n} EnMemoryDemo; // size = 0x0270\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000080, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 40, 0, { 0, 0, 0 } },\n};\n\nvoid EnMemoryDemo_Init(Actor* thisx, PlayState* play) {\n    EnMemoryDemo* this = (EnMemoryDemo*)thisx;\n    \n    // Initialize collision using authentic pattern\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    // Initialize skeleton animation with pre-allocated tables\n    SkelAnime_InitFlex(play, &this->skelAnime, &gSomeSkeleton, &gSomeAnim, \n                       this->jointTable, this->morphTable, 20);\n    \n    // Set initial actor properties\n    Actor_SetScale(&this->actor, 0.01f);\n    this->timer = 0;\n    this->state = 0;\n}\n\nvoid EnMemoryDemo_Destroy(Actor* thisx, PlayState* play) {\n    EnMemoryDemo* this = (EnMemoryDemo*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnMemoryDemo_Update(Actor* thisx, PlayState* play) {\n    EnMemoryDemo* this = (EnMemoryDemo*)thisx;\n    \n    // Update skeleton animation\n    SkelAnime_Update(&this->skelAnime);\n    \n    // Update collision checking\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Update background collision info\n    Actor_UpdateBgCheckInfo(play, &this->actor, 35.0f, 30.0f, 30.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n}\n\nvoid EnMemoryDemo_Draw(Actor* thisx, PlayState* play) {\n    EnMemoryDemo* this = (EnMemoryDemo*)thisx;\n    \n    // Set up display list\n    OPEN_DISPS(play->state.gfxCtx);\n    \n    // Setup graphics state\n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    // Draw skeleton\n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                          this->skelAnime.dListCount, NULL, NULL, this);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_MemoryDemo_InitVars = {\n    /**/ ACTOR_EN_MEMORY_DEMO,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnMemoryDemo),\n    /**/ EnMemoryDemo_Init,\n    /**/ EnMemoryDemo_Destroy,\n    /**/ EnMemoryDemo_Update,\n    /**/ EnMemoryDemo_Draw\n};\"\n}"}
{"instruction": "Implement feature implementation functionality using authentic code with good code organization", "output": "// Implements a spinning collectible item actor with authentic patterns\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 rotationAngle;\n    /* 0x0150 */ f32 hoverOffset;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnSpinItem; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000010, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 12, 25, 0, { 0, 0, 0 } }\n};\n\nvoid EnSpinItem_Init(Actor* thisx, PlayState* play) {\n    EnSpinItem* this = (EnSpinItem*)thisx;\n\n    Actor_SetScale(&this->actor, 0.01f);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.gravity = -1.0f;\n    this->actor.minVelocityY = -10.0f;\n    \n    this->timer = 0;\n    this->rotationAngle = 0;\n    this->hoverOffset = 0.0f;\n    \n    Actor_SetFocus(&this->actor, 10.0f);\n}\n\nvoid EnSpinItem_Destroy(Actor* thisx, PlayState* play) {\n    EnSpinItem* this = (EnSpinItem*)thisx;\n    \n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnSpinItem_Update(Actor* thisx, PlayState* play) {\n    EnSpinItem* this = (EnSpinItem*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    this->rotationAngle += 0x0400;\n    this->hoverOffset = Math_SinS(this->timer * 0x0800) * 3.0f;\n    \n    this->actor.world.pos.y += this->hoverOffset - this->actor.velocity.y;\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 50.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (Actor_HasParent(&this->actor, play)) {\n        Actor_Kill(&this->actor);\n        return;\n    }\n    \n    if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 50.0f) {\n        // Set up collection when player is near\n        Actor_OfferGetItem(&this->actor, play, GI_RUPEE_BLUE, 50.0f, 50.0f);\n    }\n}\n\nvoid EnSpinItem_Draw(Actor* thisx, PlayState* play) {\n    EnSpinItem* this = (EnSpinItem*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_RotateY(this->rotationAngle * (M_PI / 0x8000), MTXMODE_APPLY);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, this->actor.scale.z, MTXMODE_APPLY);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__), \n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n    \n    gSPDisplayList(POLY_OPA_DISP++, gRupeeBlueDisplayList);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_SpinItem_InitVars = {\n    /**/ ACTOR_EN_SPIN_ITEM,\n    /**/ ACTORCAT_MISC,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnSpinItem),\n    /**/ EnSpinItem_Init,\n    /**/ EnSpinItem_Destroy,\n    /**/ EnSpinItem_Update, \n    /**/ EnSpinItem_Draw\n};"}
{"instruction": "Create a animation system system", "output": "{\n  \"instruction\": \"Implement a physics-based animation system for cloth and hair using advanced optimization techniques\",\n  \"input\": null,\n  \"output\": \"// Authentic pattern following z_actor.h and z_en_item00.c style\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ Vec3f points[16];      // Physics simulation points\n    /* 0x020C */ Vec3f prevPoints[16];  // Previous frame positions\n    /* 0x02CC */ Vec3f forces[16];      // Accumulated forces\n    /* 0x038C */ f32 segmentLengths[15]; // Rest lengths between points\n    /* 0x03C8 */ SkelAnime skelAnime;\n    /* 0x040C */ Vec3s jointTable[20];\n    /* 0x0484 */ Vec3s morphTable[20];\n    /* 0x04FC */ ColliderCylinder collider;\n} EnCloth; // size = 0x0548\n\nvoid EnCloth_Init(Actor* thisx, PlayState* play) {\n    EnCloth* this = (EnCloth*)thisx;\n    s32 i;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    \n    // Initialize physics points in a chain\n    for (i = 0; i < 16; i++) {\n        this->points[i].x = this->actor.world.pos.x;\n        this->points[i].y = this->actor.world.pos.y - (i * 10.0f);\n        this->points[i].z = this->actor.world.pos.z;\n        \n        this->prevPoints[i] = this->points[i];\n        this->forces[i].x = this->forces[i].y = this->forces[i].z = 0.0f;\n    }\n    \n    // Calculate rest lengths\n    for (i = 0; i < 15; i++) {\n        Vec3f diff;\n        diff.x = this->points[i+1].x - this->points[i].x;\n        diff.y = this->points[i+1].y - this->points[i].y;\n        diff.z = this->points[i+1].z - this->points[i].z;\n        this->segmentLengths[i] = sqrtf(SQ(diff.x) + SQ(diff.y) + SQ(diff.z));\n    }\n\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    SkelAnime_InitFlex(play, &this->skelAnime, &gClothSkel, &gClothIdleAnim, \n                       this->jointTable, this->morphTable, 20);\n}\n\nvoid EnCloth_Update(Actor* thisx, PlayState* play) {\n    EnCloth* this = (EnCloth*)thisx;\n    Player* player = GET_PLAYER(play);\n    s32 i;\n    f32 dt = 0.016667f; // 60 FPS timestep\n    \n    // Apply gravity and wind forces\n    for (i = 0; i < 16; i++) {\n        this->forces[i].y -= 9.8f * dt;\n        this->forces[i].x += Math_SinS(play->gameplayFrames * 0x200) * 2.0f;\n    }\n    \n    // Verlet integration\n    for (i = 0; i < 16; i++) {\n        Vec3f temp = this->points[i];\n        \n        this->points[i].x += (this->points[i].x - this->prevPoints[i].x) + \n                            (this->forces[i].x * dt * dt);\n        this->points[i].y += (this->points[i].y - this->prevPoints[i].y) + \n                            (this->forces[i].y * dt * dt);\n        this->points[i].z += (this->points[i].z - this->prevPoints[i].z) + \n                            (this->forces[i].z * dt * dt);\n                            \n        this->prevPoints[i] = temp;\n        this->forces[i].x = this->forces[i].y = this->forces[i].z = 0.0f;\n    }\n    \n    // Distance constraints\n    for (i = 0; i < 15; i++) {\n        Vec3f diff;\n        f32 dist, factor;\n        \n        diff.x = this->points[i+1].x - this->points[i].x;\n        diff.y = this->points[i+1].y - this->points[i].y;\n        diff.z = this->points[i+1].z - this->points[i].z;\n        \n        dist = sqrtf(SQ(diff.x) + SQ(diff.y) + SQ(diff.z));\n        factor = (this->segmentLengths[i] - dist) / dist;\n        \n        if (i > 0) {\n            this->points[i].x -= diff.x * factor * 0.5f;\n            this->points[i].y -= diff.y * factor * 0.5f;\n            this->points[i].z -= diff.z * factor * 0.5f;\n            \n            this->points[i+1].x += diff.x * factor * 0.5f;\n            this->points[i+1].y += diff.y * factor * 0.5f;\n            this->points[i+1].z += diff.z * factor * 0.5f;\n        } else {\n            // Pin first point to actor position\n            this->points[0] = this->actor.world.pos;\n        }\n    }\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 20.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile EnCloth_Profile = {\n    /**/ ACTOR_EN_CLOTH,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnCloth),\n    /**/ EnCloth_Init,\n    /**/ Actor_Destroy,\n    /**/ EnCloth_Update,\n    /**/ EnCloth_Draw\n};\"\n}"}
{"instruction": "Create a actor creation system", "output": "{\n  \"instruction\": \"How would you implement a scholar that fast travel between locations? for a temporary event with reasonable performance\",\n  \"input\": null,\n  \"output\": \"```c\n// Scholar NPC that teleports between locations\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ Vec3s jointTable[20];\n    /* 0x01F0 */ Vec3s morphTable[20];\n    /* 0x0250 */ s16 timer;\n    /* 0x0252 */ s16 locationIndex;\n    /* 0x0254 */ s16 actionState;\n    /* 0x0256 */ s16 talkState;\n    /* 0x0258 */ ColliderCylinder collider;\n    /* 0x02A4 */ Vec3f destPos[4]; // Pre-defined positions\n} EnScholar;\n\nstatic InitChainEntry sInitChain[] = {\n    ICHAIN_F32(uncullZoneScale, 1200, ICHAIN_STOP),\n};\n\nvoid EnScholar_Init(Actor* thisx, PlayState* play) {\n    EnScholar* this = (EnScholar*)thisx;\n    \n    Actor_ProcessInitChain(&this->actor, sInitChain);\n    SkelAnime_InitFlex(play, &this->skelAnime, &gNPCSkel, &gNPCIdleAnim, \n                       this->jointTable, this->morphTable, 20);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    // Set predefined locations\n    this->destPos[0] = (Vec3f){820.0f, 60.0f, -1340.0f}; // Kakariko\n    this->destPos[1] = (Vec3f){-28.0f, 100.0f, -1600.0f}; // Market\n    this->destPos[2] = (Vec3f){1600.0f, 60.0f, 1600.0f}; // Lake\n    this->destPos[3] = (Vec3f){-460.0f, 60.0f, -700.0f}; // Temple\n    \n    this->locationIndex = 0;\n    this->timer = (s16)(Rand_ZeroOne() * 400.0f) + 200;\n    this->actionState = 0;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnScholar_Destroy(Actor* thisx, PlayState* play) {\n    EnScholar* this = (EnScholar*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnScholar_Update(Actor* thisx, PlayState* play) {\n    EnScholar* this = (EnScholar*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    Actor_SetFocus(&this->actor, 50.0f);\n    SkelAnime_Update(&this->skelAnime);\n    \n    if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 100.0f) {\n        if (this->talkState == 0 && Actor_ProcessTalkRequest(&this->actor, play)) {\n            this->talkState = 1;\n        }\n    }\n    \n    if (this->timer <= 0) {\n        // Time to teleport\n        this->locationIndex = (this->locationIndex + 1) & 3;\n        this->actor.world.pos = this->destPos[this->locationIndex];\n        this->timer = (s16)(Rand_ZeroOne() * 400.0f) + 200;\n        \n        // Spawn effect at old position\n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_M_THUNDER,\n                   this->actor.world.pos.x, this->actor.world.pos.y, \n                   this->actor.world.pos.z, 0, 0, 0, 0);\n    }\n    \n    this->timer--;\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnScholar_Draw(Actor* thisx, PlayState* play) {\n    EnScholar* this = (EnScholar*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                         this->skelAnime.dListCount, NULL, NULL, this);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Scholar_InitVars = {\n    /**/ ACTOR_EN_SCHOLAR,\n    /**/ ACTORCAT_NPC,\n    /**/ FLAGS,\n    /**/ OBJECT_NPC,\n    /**/ sizeof(EnScholar),\n    /**/ EnScholar_Init,\n    /**/ EnScholar_Destroy,\n    /**/ EnScholar_Update,\n    /**/ EnScholar_Draw\n};\n```\"\n}"}
{"instruction": "Implement a complex feature implementation system for enhanced gameplay with basic debugging support", "output": "// Authentic debug system pattern based on OoT actor system\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 debugState;\n    /* 0x014E */ s16 debugTimer;\n    /* 0x0150 */ f32 debugRadius;\n    /* 0x0154 */ Vec3f debugPos;\n    /* 0x0160 */ ColliderCylinder collider;\n} EnDebugInfo; // size = 0x1AC\n\nvoid EnDebugInfo_Init(Actor* thisx, PlayState* play) {\n    EnDebugInfo* this = (EnDebugInfo*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->debugState = 0;\n    this->debugTimer = 0;\n    this->debugRadius = 50.0f;\n    \n    // Authentic collision initialization\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n}\n\nvoid EnDebugInfo_Update(Actor* thisx, PlayState* play) {\n    EnDebugInfo* this = (EnDebugInfo*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->debugTimer++;\n    \n    // Authentic distance check pattern\n    f32 dist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    if (dist < this->debugRadius) {\n        this->debugState |= 1;\n        \n        // Authentic bg check pattern\n        Actor_UpdateBgCheckInfo(play, &this->actor, 35.0f, 60.0f, 0.0f, \n            UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n            \n        // Authentic collision update\n        Collider_UpdateCylinder(&this->actor, &this->collider);\n        CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    }\n    \n    // Authentic position update\n    Math_SmoothStepToF(&this->actor.world.pos.y, this->debugPos.y, 0.3f, 5.0f, 0.0f);\n}\n\nvoid EnDebugInfo_Draw(Actor* thisx, PlayState* play) {\n    EnDebugInfo* this = (EnDebugInfo*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    // Authentic matrix setup\n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, \n        this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, \n        this->actor.scale.z, MTXMODE_APPLY);\n    \n    // Authentic display list setup\n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n        G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile EnDebugInfo_Profile = {\n    /**/ ACTOR_EN_DEBUG_INFO,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnDebugInfo),\n    /**/ EnDebugInfo_Init,\n    /**/ EnDebugInfo_Destroy,\n    /**/ EnDebugInfo_Update, \n    /**/ EnDebugInfo_Draw\n};"}
{"instruction": "Transformation masks are specific to Majora's Mask and cannot be authentically implemented in OoT because:", "output": "```c\n// Use existing OoT systems instead\nif (gSaveContext.inventory.items[SLOT_TUNIC] == ITEM_TUNIC_ZORA) {\n    // Modify swimming behavior using authentic OoT player states\n    // Do NOT try to transform the player model\n}\n```"}
{"instruction": "Implement a sound optimization system for performance with complex interaction patterns", "output": "// Authentic pattern for sound optimization system based on OoT decompilation\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 soundTimer;\n    /* 0x014E */ s16 soundState;\n    /* 0x0150 */ f32 soundRadius;\n    /* 0x0154 */ Vec3f lastSoundPos;\n    /* 0x0160 */ ColliderCylinder collider;\n} EnSoundOpt;\n\nvoid EnSoundOpt_Init(Actor* thisx, PlayState* play) {\n    EnSoundOpt* this = (EnSoundOpt*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->soundTimer = 0;\n    this->soundState = 0;\n    this->soundRadius = 300.0f;\n    this->lastSoundPos = this->actor.world.pos;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnSoundOpt_Update(Actor* thisx, PlayState* play) {\n    EnSoundOpt* this = (EnSoundOpt*)thisx;\n    Player* player = GET_PLAYER(play);\n    f32 distToPlayer;\n    \n    this->soundTimer++;\n    \n    // Authentic distance check pattern\n    distToPlayer = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    // Sound optimization based on distance and state\n    if (distToPlayer < this->soundRadius) {\n        if (this->soundTimer > 8) {\n            // Authentic sound play pattern using actual OoT function\n            Audio_PlayActorSound2(&this->actor, NA_SE_EN_STALTU_LAUGH);\n            this->soundTimer = 0;\n        }\n        \n        // Track position changes for sound updates\n        if (Math_Vec3f_DistXYZ(&this->lastSoundPos, &this->actor.world.pos) > 50.0f) {\n            Audio_PlayActorSound2(&this->actor, NA_SE_EN_STAL_JUMP);\n            this->lastSoundPos = this->actor.world.pos;\n        }\n    }\n    \n    // Authentic collision update pattern\n    Actor_UpdateBgCheckInfo(play, &this->actor, 35.0f, 50.0f, 0.0f, UPDBGCHECKINFO_FLAG_0);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnSoundOpt_Draw(Actor* thisx, PlayState* play) {\n    EnSoundOpt* this = (EnSoundOpt*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_SoundOpt_InitVars = {\n    /**/ ACTOR_EN_SOUND_OPT,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnSoundOpt),\n    /**/ EnSoundOpt_Init,\n    /**/ EnSoundOpt_Destroy,\n    /**/ EnSoundOpt_Update,\n    /**/ EnSoundOpt_Draw\n};"}
{"instruction": "Create a feature implementation system", "output": "{\n\"instruction\": \"Create a feature implementation system with proper OoT patterns with multiple states and transitions\",\n\"input\": null,\n\"output\": \"\n```c\ntypedef enum {\n    /* 0x00 */ ENSTATUE_STATE_IDLE,\n    /* 0x01 */ ENSTATUE_STATE_RISE,\n    /* 0x02 */ ENSTATUE_STATE_ACTIVE,\n    /* 0x03 */ ENSTATUE_STATE_FALL\n} EnStatueState;\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ Vec3s jointTable[20];\n    /* 0x01F4 */ Vec3s morphTable[20];\n    /* 0x0258 */ s16 timer;\n    /* 0x025A */ s16 actionState;\n    /* 0x025C */ f32 heightOffset;\n    /* 0x0260 */ ColliderCylinder collider;\n} EnStatue; // size = 0x02AC\n\nvoid EnStatue_Init(Actor* thisx, PlayState* play) {\n    EnStatue* this = (EnStatue*)thisx;\n    \n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 30.0f);\n    SkelAnime_InitFlex(play, &this->skelAnime, &gStatueSkel, &gStatueIdleAnim, \n                       this->jointTable, this->morphTable, 20);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actionState = ENSTATUE_STATE_IDLE;\n    this->heightOffset = 0.0f;\n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnStatue_Update(Actor* thisx, PlayState* play) {\n    EnStatue* this = (EnStatue*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    SkelAnime_Update(&this->skelAnime);\n    \n    switch (this->actionState) {\n        case ENSTATUE_STATE_IDLE:\n            if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 200.0f) {\n                this->actionState = ENSTATUE_STATE_RISE;\n                this->timer = 40;\n            }\n            break;\n            \n        case ENSTATUE_STATE_RISE:\n            Math_SmoothStepToF(&this->heightOffset, 40.0f, 0.3f, 5.0f, 0.1f);\n            this->actor.world.pos.y = this->actor.home.pos.y + this->heightOffset;\n            \n            if (--this->timer <= 0) {\n                this->actionState = ENSTATUE_STATE_ACTIVE;\n                Animation_Change(&this->skelAnime, &gStatueActiveAnim, 1.0f, 0.0f,\n                               Animation_GetLastFrame(&gStatueActiveAnim), ANIMMODE_LOOP, -8.0f);\n            }\n            break;\n            \n        case ENSTATUE_STATE_ACTIVE:\n            if (Actor_WorldDistXZToActor(&this->actor, &player->actor) > 300.0f) {\n                this->actionState = ENSTATUE_STATE_FALL;\n                this->timer = 20;\n            }\n            break;\n            \n        case ENSTATUE_STATE_FALL:\n            Math_SmoothStepToF(&this->heightOffset, 0.0f, 0.2f, 8.0f, 0.1f);\n            this->actor.world.pos.y = this->actor.home.pos.y + this->heightOffset;\n            \n            if (--this->timer <= 0) {\n                this->actionState = ENSTATUE_STATE_IDLE;\n                Animation_Change(&this->skelAnime, &gStatueIdleAnim, 1.0f, 0.0f,\n                               Animation_GetLastFrame(&gStatueIdleAnim), ANIMMODE_LOOP, -8.0f);\n            }\n            break;\n    }\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 50.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnStatue_Draw(Actor* thisx, PlayState* play) {\n    EnStatue* this = (EnStatue*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Push();\n    Matrix_Translate(0.0f, this->heightOffset, 0.0f, MTXMODE_APPLY);\n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                         this->skelAnime.dListCount, NULL, NULL, this);\n    Matrix_Pop();\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Statue_InitVars = {\n    /**/ ACTOR_EN_STATUE,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_STATUE,\n    /**/ sizeof(EnStatue),\n    /**/ EnStatue_Init,\n    /**/ EnStatue_Destroy,\n    /**/ EnStatue_Update,\n    /**/ EnStatue_Draw\n};\n```\n\"}"}
{"instruction": "Implement optimization functionality using authentic code with multiple states and transitions", "output": "typedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 oscillation;\n    /* 0x0154 */ f32 moveSpeed;\n    /* 0x0158 */ f32 targetY;\n    /* 0x015C */ ColliderCylinder collider;\n} EnOptimizer; // size = 0x1A8\n\nenum OptimizerState {\n    /* 0 */ OPTIMIZER_IDLE,\n    /* 1 */ OPTIMIZER_RISE,\n    /* 2 */ OPTIMIZER_SEEK,\n    /* 3 */ OPTIMIZER_RETURN\n};\n\nvoid EnOptimizer_Init(Actor* thisx, PlayState* play) {\n    EnOptimizer* this = (EnOptimizer*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.015f);\n    this->actor.gravity = -1.0f;\n    this->actor.flags |= ACTOR_FLAG_0;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actionState = OPTIMIZER_IDLE;\n    this->timer = 0;\n    this->moveSpeed = 2.0f;\n    this->targetY = this->actor.world.pos.y;\n}\n\nvoid EnOptimizer_Update(Actor* thisx, PlayState* play) {\n    EnOptimizer* this = (EnOptimizer*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    switch(this->actionState) {\n        case OPTIMIZER_IDLE:\n            if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 200.0f) {\n                this->actionState = OPTIMIZER_RISE;\n                this->timer = 0;\n            }\n            break;\n            \n        case OPTIMIZER_RISE:\n            this->targetY = this->actor.world.pos.y + 100.0f;\n            Math_SmoothStepToF(&this->actor.world.pos.y, this->targetY, 0.3f, this->moveSpeed, 0.0f);\n            \n            if (this->timer > 30) {\n                this->actionState = OPTIMIZER_SEEK;\n                this->timer = 0;\n            }\n            break;\n            \n        case OPTIMIZER_SEEK:\n            this->oscillation = Math_SinS(this->timer * 0x800) * 20.0f;\n            this->actor.world.pos.y = this->targetY + this->oscillation;\n            \n            Math_SmoothStepToF(&this->actor.world.pos.x, player->actor.world.pos.x, 0.1f, 3.0f, 0.0f);\n            Math_SmoothStepToF(&this->actor.world.pos.z, player->actor.world.pos.z, 0.1f, 3.0f, 0.0f);\n            \n            if (Actor_WorldDistXZToActor(&this->actor, &player->actor) > 300.0f) {\n                this->actionState = OPTIMIZER_RETURN;\n                this->timer = 0;\n            }\n            break;\n            \n        case OPTIMIZER_RETURN:\n            Math_SmoothStepToF(&this->actor.world.pos.y, this->actor.home.pos.y, 0.2f, 4.0f, 0.0f);\n            Math_SmoothStepToF(&this->actor.world.pos.x, this->actor.home.pos.x, 0.2f, 4.0f, 0.0f);\n            Math_SmoothStepToF(&this->actor.world.pos.z, this->actor.home.pos.z, 0.2f, 4.0f, 0.0f);\n            \n            if (Actor_WorldDistXYZToPoint(&this->actor, &this->actor.home.pos) < 10.0f) {\n                this->actionState = OPTIMIZER_IDLE;\n                this->timer = 0;\n            }\n            break;\n    }\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 0.0f, UPDBGCHECKINFO_FLAG_0);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile En_Optimizer_InitVars = {\n    /**/ ACTOR_EN_OPTIMIZER,\n    /**/ ACTORCAT_MISC,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnOptimizer),\n    /**/ EnOptimizer_Init,\n    /**/ EnOptimizer_Destroy,\n    /**/ EnOptimizer_Update,\n    /**/ NULL\n};"}
{"instruction": "Create a puzzle system system", "output": "{\n  \"instruction\": \"How would you implement a sliding door that opens passages based on player inventory? with multiple states for secret areas with simple documentation\",\n  \"input\": null,\n  \"output\": \"```c\n// A sliding door that checks inventory items to reveal passages\n// States: Closed, Opening, Open, Closing\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 actionState;\n    /* 0x014E */ s16 timer;\n    /* 0x0150 */ f32 slideOffset;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnDoorSlide; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000010, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 60, 0, { 0, 0, 0 } },\n};\n\nvoid EnDoorSlide_Init(Actor* thisx, PlayState* play) {\n    EnDoorSlide* this = (EnDoorSlide*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actionState = 0;\n    this->timer = 0;\n    this->slideOffset = 0.0f;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnDoorSlide_Destroy(Actor* thisx, PlayState* play) {\n    EnDoorSlide* this = (EnDoorSlide*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnDoorSlide_Update(Actor* thisx, PlayState* play) {\n    EnDoorSlide* this = (EnDoorSlide*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    switch(this->actionState) {\n        case 0: // Closed, check conditions\n            if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 100.0f) {\n                // Example: Check if player has bow and hookshot\n                if ((gSaveContext.inventory.items[SLOT_BOW] != ITEM_NONE) &&\n                    (gSaveContext.inventory.items[SLOT_HOOKSHOT] != ITEM_NONE)) {\n                    this->actionState = 1;\n                }\n            }\n            break;\n            \n        case 1: // Opening\n            Math_SmoothStepToF(&this->slideOffset, 120.0f, 0.3f, 5.0f, 0.1f);\n            if (this->slideOffset >= 119.0f) {\n                this->actionState = 2;\n            }\n            break;\n            \n        case 2: // Open\n            if (Actor_WorldDistXZToActor(&this->actor, &player->actor) > 200.0f) {\n                this->actionState = 3;\n            }\n            break;\n            \n        case 3: // Closing\n            Math_SmoothStepToF(&this->slideOffset, 0.0f, 0.3f, 5.0f, 0.1f);\n            if (this->slideOffset <= 1.0f) {\n                this->actionState = 0;\n                this->slideOffset = 0.0f;\n            }\n            break;\n    }\n    \n    this->actor.world.pos.x = this->actor.home.pos.x + this->slideOffset;\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnDoorSlide_Draw(Actor* thisx, PlayState* play) {\n    EnDoorSlide* this = (EnDoorSlide*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Translate(0.0f, 0.0f, 0.0f, MTXMODE_NEW);\n    Matrix_Scale(1.0f, 1.0f, 1.0f, MTXMODE_APPLY);\n    Matrix_RotateY(this->actor.world.rot.y * (M_PI / 32768.0f), MTXMODE_APPLY);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_MODELVIEW | G_MTX_LOAD);\n    gSPDisplayList(POLY_OPA_DISP++, gDoorDL);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Door_Slide_InitVars = {\n    /**/ ACTOR_EN_DOOR_SLIDE,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnDoorSlide),\n    /**/ EnDoorSlide_Init,\n    /**/ EnDoorSlide_Destroy,\n    /**/ EnDoorSlide_Update,\n    /**/ EnDoorSlide_Draw\n};\n```\"\n}"}
{"instruction": "Create a actor creation system", "output": "{\n  \"instruction\": \"Create a Jabu-Jabu's Belly water and bubble mechanics using established conventions\",\n  \"input\": null,\n  \"output\": \"```c\n// Bubble effect actor for Jabu-Jabu's Belly\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 lifespan;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ f32 yVelocity;\n    /* 0x0158 */ ColliderCylinder collider;\n} EnJjBubble; // size = 0x1A4\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_NONE,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000000, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_NONE,\n        OCELEM_ON,\n    },\n    { 12, 25, 0, { 0, 0, 0 } },\n};\n\nvoid EnJjBubble_Init(Actor* thisx, PlayState* play) {\n    EnJjBubble* this = (EnJjBubble*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.015f);\n    this->scale = 0.015f;\n    this->timer = 0;\n    this->lifespan = 100;\n    this->yVelocity = 1.5f;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.gravity = 0.0f;\n}\n\nvoid EnJjBubble_Destroy(Actor* thisx, PlayState* play) {\n    EnJjBubble* this = (EnJjBubble*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnJjBubble_Update(Actor* thisx, PlayState* play) {\n    EnJjBubble* this = (EnJjBubble*)thisx;\n    \n    this->timer++;\n    \n    // Float upward with slight wobble\n    this->actor.world.pos.y += this->yVelocity;\n    this->actor.world.pos.x += sinf(this->timer * 0.1f) * 0.5f;\n    this->actor.world.pos.z += cosf(this->timer * 0.1f) * 0.5f;\n    \n    // Pulse scale slightly\n    this->scale = 0.015f + sinf(this->timer * 0.2f) * 0.003f;\n    Actor_SetScale(&this->actor, this->scale);\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Delete when lifespan expires\n    if (this->timer >= this->lifespan) {\n        Actor_Kill(&this->actor);\n    }\n}\n\nvoid EnJjBubble_Draw(Actor* thisx, PlayState* play) {\n    EnJjBubble* this = (EnJjBubble*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_Scale(this->scale, this->scale, this->scale, MTXMODE_APPLY);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__), \n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n              \n    gSPDisplayList(POLY_OPA_DISP++, gEffBubbleDL);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_JjBubble_InitVars = {\n    /**/ ACTOR_EN_JJ_BUBBLE,\n    /**/ ACTORCAT_MISC,\n    /**/ FLAGS_0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnJjBubble),\n    /**/ EnJjBubble_Init,\n    /**/ EnJjBubble_Destroy,\n    /**/ EnJjBubble_Update,\n    /**/ EnJjBubble_Draw\n};\n```\"\n}"}
{"instruction": "Create a sound system system", "output": "{\n  \"instruction\": \"Create a voice acting system for NPC dialogue with basic debugging support\",\n  \"input\": null,\n  \"output\": \"```c\n// Voice actor system using authentic OoT patterns\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 voiceTimer;\n    /* 0x014E */ s16 voiceState;\n    /* 0x0150 */ s16 voiceId;\n    /* 0x0152 */ s16 debugMode;\n    /* 0x0154 */ f32 voiceVolume;\n    /* 0x0158 */ f32 voicePitch;\n    /* 0x015C */ ColliderCylinder collider;\n} EnVoiceAct;\n\nvoid EnVoiceAct_Init(Actor* thisx, PlayState* play) {\n    EnVoiceAct* this = (EnVoiceAct*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->voiceTimer = 0;\n    this->voiceState = 0;\n    this->voiceId = 0;\n    this->voiceVolume = 1.0f;\n    this->voicePitch = 1.0f;\n    this->debugMode = 0;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnVoiceAct_Destroy(Actor* thisx, PlayState* play) {\n    EnVoiceAct* this = (EnVoiceAct*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnVoiceAct_Update(Actor* thisx, PlayState* play) {\n    EnVoiceAct* this = (EnVoiceAct*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->voiceTimer++;\n    \n    // Update collision for interaction radius\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 20.0f, UPDBGCHECKINFO_FLAG_0);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    // Check distance to player for voice volume\n    f32 playerDist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    if (playerDist < 100.0f) {\n        this->voiceVolume = (100.0f - playerDist) / 100.0f;\n    } else {\n        this->voiceVolume = 0.0f;\n    }\n\n    // Debug mode toggle with B button\n    if (CHECK_BTN_ALL(input->press.button, BTN_B)) {\n        this->debugMode ^= 1;\n    }\n\n    // Update voice playback state\n    switch(this->voiceState) {\n        case 0: // Idle\n            if (Message_GetState(&play->msgCtx) == TEXT_STATE_EVENT) {\n                this->voiceState = 1;\n                this->voiceTimer = 0;\n            }\n            break;\n            \n        case 1: // Playing voice\n            if (Message_GetState(&play->msgCtx) != TEXT_STATE_EVENT) {\n                this->voiceState = 0;\n                this->voiceTimer = 0;\n            }\n            break;\n    }\n}\n\nvoid EnVoiceAct_Draw(Actor* thisx, PlayState* play) {\n    EnVoiceAct* this = (EnVoiceAct*)thisx;\n\n    OPEN_DISPS(play->state.gfxCtx);\n    \n    // Draw debug info if enabled\n    if (this->debugMode) {\n        Gfx_SetupDL_25Opa(play->state.gfxCtx);\n        Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y + 50.0f, \n                        this->actor.world.pos.z, MTXMODE_NEW);\n        Matrix_Scale(0.02f, 0.02f, 0.02f, MTXMODE_APPLY);\n        Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__);\n        \n        // Debug text using authentic font system\n        gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 255, 255, 255, 255);\n        gSPDisplayList(POLY_OPA_DISP++, gDebugFontDL);\n    }\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Voice_Act_InitVars = {\n    /**/ ACTOR_EN_VOICE_ACT,\n    /**/ ACTORCAT_NPC,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnVoiceAct),\n    /**/ EnVoiceAct_Init,\n    /**/ EnVoiceAct_Destroy,\n    /**/ EnVoiceAct_Update,\n    /**/ EnVoiceAct_Draw\n};\n```\"\n}"}
{"instruction": "Create a animation system system", "output": "{\n  \"instruction\": \"Create an animation state machine for complex character behaviors using advanced optimization techniques\",\n  \"input\": null,\n  \"output\": \"typedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ Vec3s jointTable[20];\n    /* 0x01F0 */ Vec3s morphTable[20];\n    /* 0x0250 */ s16 actionState;\n    /* 0x0252 */ s16 animTimer;\n    /* 0x0254 */ f32 moveSpeed;\n    /* 0x0258 */ ColliderCylinder collider;\n} EnNpc; // size = 0x02A4\n\ntypedef enum {\n    /* 0x00 */ NPC_STATE_IDLE,\n    /* 0x01 */ NPC_STATE_WALK,\n    /* 0x02 */ NPC_STATE_TALK,\n    /* 0x03 */ NPC_STATE_FLEE\n} NpcState;\n\nvoid EnNpc_Init(Actor* thisx, PlayState* play) {\n    EnNpc* this = (EnNpc*)thisx;\n    \n    SkelAnime_InitFlex(play, &this->skelAnime, &gNpcSkel, &gNpcIdleAnim, \n                       this->jointTable, this->morphTable, 20);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actionState = NPC_STATE_IDLE;\n    this->animTimer = 0;\n    this->moveSpeed = 0.0f;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnNpc_UpdateAnimation(EnNpc* this, PlayState* play) {\n    f32 frameCount;\n    \n    switch (this->actionState) {\n        case NPC_STATE_IDLE:\n            frameCount = Animation_GetLastFrame(&gNpcIdleAnim);\n            if (this->skelAnime.curFrame == frameCount) {\n                Animation_Change(&this->skelAnime, &gNpcIdleAnim, 1.0f, 0.0f,\n                               frameCount, ANIMMODE_LOOP, -8.0f);\n            }\n            break;\n            \n        case NPC_STATE_WALK:\n            frameCount = Animation_GetLastFrame(&gNpcWalkAnim);\n            if (this->skelAnime.curFrame == frameCount) {\n                Animation_Change(&this->skelAnime, &gNpcWalkAnim, 1.0f, 0.0f,\n                               frameCount, ANIMMODE_LOOP, -8.0f);\n            }\n            this->moveSpeed = 2.0f;\n            break;\n            \n        case NPC_STATE_TALK:\n            frameCount = Animation_GetLastFrame(&gNpcTalkAnim);\n            if (this->skelAnime.curFrame == frameCount) {\n                this->actionState = NPC_STATE_IDLE;\n            }\n            break;\n            \n        case NPC_STATE_FLEE:\n            frameCount = Animation_GetLastFrame(&gNpcFleeAnim);\n            if (this->skelAnime.curFrame == frameCount) {\n                Animation_Change(&this->skelAnime, &gNpcFleeAnim, 1.5f, 0.0f,\n                               frameCount, ANIMMODE_LOOP, -8.0f);\n            }\n            this->moveSpeed = 6.0f;\n            break;\n    }\n    \n    SkelAnime_Update(&this->skelAnime);\n}\n\nvoid EnNpc_Update(Actor* thisx, PlayState* play) {\n    EnNpc* this = (EnNpc*)thisx;\n    Player* player = GET_PLAYER(play);\n    f32 dist;\n    \n    dist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    if (dist < 100.0f && this->actionState == NPC_STATE_IDLE) {\n        this->actionState = NPC_STATE_TALK;\n        this->animTimer = 60;\n    } else if (dist < 50.0f) {\n        this->actionState = NPC_STATE_FLEE;\n    } else if (dist > 200.0f && this->actionState == NPC_STATE_FLEE) {\n        this->actionState = NPC_STATE_WALK;\n    }\n    \n    if (this->animTimer > 0) {\n        this->animTimer--;\n    }\n    \n    EnNpc_UpdateAnimation(this, play);\n    \n    if (this->moveSpeed > 0.0f) {\n        Actor_MoveXZGravity(&this->actor);\n    }\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 50.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n                           \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnNpc_Draw(Actor* thisx, PlayState* play) {\n    EnNpc* this = (EnNpc*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                          this->skelAnime.dListCount, NULL, NULL, this);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile EnNpc_InitVars = {\n    /**/ ACTOR_EN_NPC,\n    /**/ ACTORCAT_NPC,\n    /**/ FLAGS,\n    /**/ OBJECT_NPC,\n    /**/ sizeof(EnNpc),\n    /**/ EnNpc_Init,\n    /**/ EnNpc_Destroy,\n    /**/ EnNpc_Update,\n    /**/ EnNpc_Draw\n};\"\n}"}
{"instruction": "Create a interaction system system", "output": "{\n  \"instruction\": \"Implement a reputation system that affects NPC interactions implementing sophisticated AI behaviors\",\n  \"input\": null,\n  \"output\": \"// EnNpcAI struct definition\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 actionState;\n    /* 0x014E */ s16 reactionTimer;\n    /* 0x0150 */ s16 reputationValue;\n    /* 0x0152 */ s16 dialogState;\n    /* 0x0154 */ f32 interactRange;\n    /* 0x0158 */ ColliderCylinder collider;\n    /* 0x01A4 */ SkelAnime skelAnime;\n    /* 0x01E8 */ Vec3s jointTable[20];\n    /* 0x0250 */ Vec3s morphTable[20];\n} EnNpcAI; // Size: 0x2B8\n\nvoid EnNpcAI_Init(Actor* thisx, PlayState* play) {\n    EnNpcAI* this = (EnNpcAI*)thisx;\n    \n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 20.0f);\n    SkelAnime_InitFlex(play, &this->skelAnime, &gNpcSkel, &gNpcIdleAnim, \n                       this->jointTable, this->morphTable, 20);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->reputationValue = 50; // Neutral starting reputation\n    this->interactRange = 100.0f;\n    this->actionState = 0;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnNpcAI_UpdateBehavior(EnNpcAI* this, PlayState* play) {\n    Player* player = GET_PLAYER(play);\n    f32 playerDist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    // Basic AI state machine based on reputation and distance\n    switch (this->actionState) {\n        case 0: // Idle\n            if (playerDist < this->interactRange) {\n                if (this->reputationValue > 75) {\n                    this->actionState = 1; // Friendly\n                    this->reactionTimer = 30;\n                } else if (this->reputationValue < 25) {\n                    this->actionState = 2; // Hostile\n                    this->reactionTimer = 40;\n                }\n            }\n            break;\n            \n        case 1: // Friendly behavior\n            if (this->reactionTimer > 0) {\n                this->reactionTimer--;\n                // Move towards player\n                Math_SmoothStepToF(&this->actor.world.pos.x, player->actor.world.pos.x, 0.3f, 3.0f, 0.0f);\n                Math_SmoothStepToF(&this->actor.world.pos.z, player->actor.world.pos.z, 0.3f, 3.0f, 0.0f);\n            } else {\n                this->actionState = 0;\n            }\n            break;\n            \n        case 2: // Hostile behavior  \n            if (this->reactionTimer > 0) {\n                this->reactionTimer--;\n                // Move away from player\n                f32 angle = Math_Atan2F(this->actor.world.pos.z - player->actor.world.pos.z,\n                                      this->actor.world.pos.x - player->actor.world.pos.x);\n                this->actor.world.pos.x += Math_SinF(angle) * 3.0f;\n                this->actor.world.pos.z += Math_CosF(angle) * 3.0f;\n            } else {\n                this->actionState = 0;\n            }\n            break;\n    }\n}\n\nvoid EnNpcAI_Update(Actor* thisx, PlayState* play) {\n    EnNpcAI* this = (EnNpcAI*)thisx;\n    \n    EnNpcAI_UpdateBehavior(this, play);\n    \n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Update skeletal animation\n    SkelAnime_Update(&this->skelAnime);\n    \n    // Update ground physics\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 50.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n}\n\nvoid EnNpcAI_Draw(Actor* thisx, PlayState* play) {\n    EnNpcAI* this = (EnNpcAI*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z, \n                    MTXMODE_NEW);\n    Matrix_RotateY(this->actor.world.rot.y * (M_PI / 32768.0f), MTXMODE_APPLY);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, this->actor.scale.z, \n                MTXMODE_APPLY);\n    \n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                          this->skelAnime.dListCount, NULL, NULL, this);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_NpcAI_InitVars = {\n    /**/ ACTOR_EN_NPC_AI,\n    /**/ ACTORCAT_NPC,\n    /**/ FLAGS,\n    /**/ OBJECT_NPC,\n    /**/ sizeof(EnNpcAI),\n    /**/ EnNpcAI_Init,\n    /**/ EnNpcAI_Destroy,\n    /**/ EnNpcAI_Update,\n    /**/ EnNpcAI_Draw\n};\"\n}"}
{"instruction": "Create a actor creation system", "output": "{\n\"instruction\": \"I need a mechanical lift that can creates temporary bridges across gaps using basic collision with basic functionality\",\n\"input\": null,\n\"output\": \"\n```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 state;\n    /* 0x0150 */ f32 targetY;\n    /* 0x0154 */ ColliderJntSph collider;\n    /* 0x0174 */ ColliderJntSphElement sphereElements[1];\n} EnLift; // size = 0x1B4\n\nstatic ColliderJntSphInit sJntSphInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_JNTSPH,\n    },\n    1,\n    sJntSphElementsInit,\n};\n\nstatic ColliderJntSphElementInit sJntSphElementsInit[1] = {\n    {\n        {\n            ELEMTYPE_UNK0,\n            { 0x00000000, 0x00, 0x00 },\n            { 0x00000008, 0x00, 0x00 },\n            TOUCH_NONE,\n            BUMP_ON,\n            OCELEM_ON,\n        },\n        { 0, { 0, 0, 0 }, 50 },\n    },\n};\n\nvoid EnLift_Init(Actor* thisx, PlayState* play) {\n    EnLift* this = (EnLift*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.1f);\n    this->actor.gravity = 0.0f;\n    this->state = 0;\n    this->targetY = this->actor.world.pos.y;\n    \n    Collider_InitJntSph(play, &this->collider);\n    Collider_SetJntSph(play, &this->collider, &this->actor, &sJntSphInit, this->sphereElements);\n}\n\nvoid EnLift_Destroy(Actor* thisx, PlayState* play) {\n    EnLift* this = (EnLift*)thisx;\n    Collider_DestroyJntSph(play, &this->collider);\n}\n\nvoid EnLift_Update(Actor* thisx, PlayState* play) {\n    EnLift* this = (EnLift*)thisx;\n    Player* player = GET_PLAYER(play);\n\n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    switch(this->state) {\n        case 0: // Waiting\n            if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 100.0f) {\n                this->state = 1;\n                this->targetY = this->actor.world.pos.y + 100.0f;\n            }\n            break;\n            \n        case 1: // Rising\n            Math_SmoothStepToF(&this->actor.world.pos.y, this->targetY, 0.3f, 5.0f, 0.0f);\n            if (fabsf(this->actor.world.pos.y - this->targetY) < 1.0f) {\n                this->timer = 100;\n                this->state = 2;\n            }\n            break;\n            \n        case 2: // Extended\n            if (this->timer > 0) {\n                this->timer--;\n            } else {\n                this->state = 3;\n                this->targetY = this->actor.home.pos.y;\n            }\n            break;\n            \n        case 3: // Lowering\n            Math_SmoothStepToF(&this->actor.world.pos.y, this->targetY, 0.3f, 5.0f, 0.0f);\n            if (fabsf(this->actor.world.pos.y - this->targetY) < 1.0f) {\n                this->state = 0;\n            }\n            break;\n    }\n}\n\nvoid EnLift_Draw(Actor* thisx, PlayState* play) {\n    EnLift* this = (EnLift*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 100, 100, 100, 255);\n    \n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, this->actor.scale.z, MTXMODE_APPLY);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__), \n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n    gSPDisplayList(POLY_OPA_DISP++, gCubeTriDL);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Lift_InitVars = {\n    /**/ ACTOR_EN_LIFT,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnLift),\n    /**/ EnLift_Init,\n    /**/ EnLift_Destroy,\n    /**/ EnLift_Update,\n    /**/ EnLift_Draw\n};\n```\n\"}"}
{"instruction": "Create a combat system system", "output": "{\n  \"instruction\": \"Implement a Equipment and inventory management system with complex interaction patterns\",\n  \"input\": null,\n  \"output\": \"// Authentic pattern from OoT decompilation\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 actionState;\n    /* 0x014E */ s16 timer;\n    /* 0x0150 */ ColliderCylinder collider;\n    /* 0x019C */ s16 itemGive;\n} EnItemManage;\n\nvoid EnItemManage_Init(Actor* thisx, PlayState* play) {\n    EnItemManage* this = (EnItemManage*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actionState = 0;\n    this->timer = 0;\n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnItemManage_CheckTradingSequence(EnItemManage* this, PlayState* play) {\n    Player* player = GET_PLAYER(play);\n\n    // Authentic inventory check pattern\n    if (gSaveContext.inventory.items[SLOT_TRADE_CHILD] == ITEM_WEIRD_EGG) {\n        if (this->itemGive == 0) {\n            this->itemGive = GI_CHICKEN;\n        }\n    }\n\n    // Authentic equipment check pattern\n    if ((gSaveContext.inventory.items[SLOT_SWORD] != ITEM_NONE) &&\n        (gSaveContext.equips.buttonItems[0] == ITEM_SWORD_KOKIRI)) {\n        this->actionState = 1;\n    }\n}\n\nvoid EnItemManage_GiveItem(EnItemManage* this, PlayState* play) {\n    if (Actor_HasParent(&this->actor, play)) {\n        this->actionState = 2;\n        this->timer = 5;\n    } else {\n        // Authentic item giving pattern\n        Actor_OfferGetItem(&this->actor, play, this->itemGive, 100.0f, 50.0f);\n    }\n}\n\nvoid EnItemManage_Update(Actor* thisx, PlayState* play) {\n    EnItemManage* this = (EnItemManage*)thisx;\n\n    this->timer--;\n    \n    if (this->timer < 0) {\n        switch (this->actionState) {\n            case 0:\n                EnItemManage_CheckTradingSequence(this, play);\n                break;\n            case 1:\n                EnItemManage_GiveItem(this, play);\n                break;\n            case 2:\n                if (this->timer < -5) {\n                    Actor_Kill(&this->actor);\n                }\n                break;\n        }\n    }\n\n    // Authentic collision update pattern\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnItemManage_Draw(Actor* thisx, PlayState* play) {\n    EnItemManage* this = (EnItemManage*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    Matrix_Push();\n    Matrix_Scale(0.01f, 0.01f, 0.01f, MTXMODE_APPLY);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n    Matrix_Pop();\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_ItemManage_InitVars = {\n    /**/ ACTOR_EN_ITEM_MANAGE,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnItemManage),\n    /**/ EnItemManage_Init,\n    /**/ EnItemManage_Destroy,\n    /**/ EnItemManage_Update,\n    /**/ EnItemManage_Draw\n};\"\n}"}
{"instruction": "Implement a lava beast enemy with the ability to uses hit-and-run tactics to avoid damage using established conventions", "output": "// Authentic pattern following z_en_firedemon.c style\n\ntypedef enum {\n    /* 0 */ LAVA_BEAST_HIDDEN,\n    /* 1 */ LAVA_BEAST_EMERGE,\n    /* 2 */ LAVA_BEAST_CHASE,\n    /* 3 */ LAVA_BEAST_RETREAT\n} LavaBeastState;\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ Vec3s jointTable[20];\n    /* 0x01F4 */ Vec3s morphTable[20];\n    /* 0x0258 */ s16 actionTimer;\n    /* 0x025A */ s16 actionState;\n    /* 0x025C */ f32 attackRange;\n    /* 0x0260 */ Vec3f homePos;\n    /* 0x026C */ ColliderCylinder collider;\n} EnLavaBeast; // size = 0x02B8\n\nvoid EnLavaBeast_Init(Actor* thisx, PlayState* play) {\n    EnLavaBeast* this = (EnLavaBeast*)thisx;\n\n    Actor_SetScale(&this->actor, 0.015f);\n    \n    SkelAnime_InitFlex(play, &this->skelAnime, &gLavaBeastSkel, &gLavaBeastIdleAnim,\n                       this->jointTable, this->morphTable, 20);\n\n    this->actor.colChkInfo.mass = MASS_HEAVY;\n    this->actionState = LAVA_BEAST_HIDDEN;\n    this->attackRange = 200.0f;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->homePos = this->actor.world.pos;\n    this->actor.flags |= ACTOR_FLAG_0;\n}\n\nvoid EnLavaBeast_Update(Actor* thisx, PlayState* play) {\n    EnLavaBeast* this = (EnLavaBeast*)thisx;\n    Player* player = GET_PLAYER(play);\n    f32 distToPlayer;\n    \n    SkelAnime_Update(&this->skelAnime);\n    \n    distToPlayer = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    switch (this->actionState) {\n        case LAVA_BEAST_HIDDEN:\n            if (distToPlayer < this->attackRange) {\n                this->actionState = LAVA_BEAST_EMERGE;\n                this->actionTimer = 30;\n            }\n            break;\n            \n        case LAVA_BEAST_EMERGE:\n            if (this->actionTimer-- <= 0) {\n                this->actionState = LAVA_BEAST_CHASE;\n                this->actionTimer = 60;\n            }\n            break;\n            \n        case LAVA_BEAST_CHASE:\n            Actor_MoveXZGravity(&this->actor);\n            Math_SmoothStepToF(&this->actor.speedXZ, 8.0f, 0.5f, 1.0f, 0.0f);\n            \n            if (this->actionTimer-- <= 0 || distToPlayer < 80.0f) {\n                this->actionState = LAVA_BEAST_RETREAT;\n                this->actionTimer = 45;\n            }\n            break;\n            \n        case LAVA_BEAST_RETREAT:\n            Actor_MoveXZGravity(&this->actor);\n            \n            f32 angleToHome = Math_Vec3f_Yaw(&this->actor.world.pos, &this->homePos);\n            Math_SmoothStepToS(&this->actor.world.rot.y, angleToHome, 5, 4000, 0);\n            \n            if (this->actionTimer-- <= 0) {\n                this->actionState = LAVA_BEAST_HIDDEN;\n            }\n            break;\n    }\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 30.0f, 30.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    \n    if (this->actionState != LAVA_BEAST_HIDDEN) {\n        Collider_UpdateCylinder(&this->actor, &this->collider);\n        CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    }\n}\n\nconst ActorProfile En_LavaBeast_InitVars = {\n    /**/ ACTOR_EN_LAVA_BEAST,\n    /**/ ACTORCAT_ENEMY,\n    /**/ FLAGS,\n    /**/ OBJECT_LAVA_BEAST,\n    /**/ sizeof(EnLavaBeast),\n    /**/ EnLavaBeast_Init,\n    /**/ EnLavaBeast_Destroy,\n    /**/ EnLavaBeast_Update,\n    /**/ EnLavaBeast_Draw\n};"}
