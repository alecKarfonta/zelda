{"instruction": "Implement a Fire Temple lava flow mechanics with proper error handling", "output": "typedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 flowState;\n    /* 0x0150 */ f32 flowSpeed;\n    /* 0x0154 */ f32 flowHeight;\n    /* 0x0158 */ Vec3f originalPos;\n    /* 0x0164 */ ColliderCylinder collider;\n} EnFireFlow; // size = 0x1B0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_ON | AT_TYPE_ENEMY,\n        AC_NONE,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x20000000, 0x01, 0x04 },\n        { 0x00000000, 0x00, 0x00 },\n        TOUCH_ON | TOUCH_SFX_NONE,\n        BUMP_NONE,\n        OCELEM_ON,\n    },\n    { 30, 50, 0, { 0, 0, 0 } },\n};\n\nvoid EnFireFlow_Init(Actor* thisx, PlayState* play) {\n    EnFireFlow* this = (EnFireFlow*)thisx;\n    \n    // Initialize collision\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    // Store initial position\n    this->originalPos = this->actor.world.pos;\n    \n    // Initialize flow parameters\n    this->flowSpeed = 2.0f;\n    this->flowHeight = 100.0f;\n    this->flowState = 0;\n    this->timer = 0;\n    \n    // Set actor properties\n    this->actor.flags |= ACTOR_FLAG_4;\n    Actor_SetScale(&this->actor, 0.1f);\n}\n\nvoid EnFireFlow_Destroy(Actor* thisx, PlayState* play) {\n    EnFireFlow* this = (EnFireFlow*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnFireFlow_Update(Actor* thisx, PlayState* play) {\n    EnFireFlow* this = (EnFireFlow*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAT(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Flow movement pattern\n    switch(this->flowState) {\n        case 0: // Rising\n            if (this->actor.world.pos.y < (this->originalPos.y + this->flowHeight)) {\n                this->actor.world.pos.y += this->flowSpeed;\n            } else {\n                this->flowState = 1;\n            }\n            break;\n            \n        case 1: // Falling\n            if (this->actor.world.pos.y > this->originalPos.y) {\n                this->actor.world.pos.y -= this->flowSpeed;\n            } else {\n                this->flowState = 0;\n            }\n            break;\n    }\n    \n    // Damage player on contact\n    if (this->collider.base.atFlags & AT_HIT) {\n        this->collider.base.atFlags &= ~AT_HIT;\n        if (this->collider.base.at == &player->actor) {\n            func_8002F71C(play, &this->actor, 8.0f, this->actor.yawTowardsPlayer, 8.0f);\n            gSaveContext.health -= 8;\n        }\n    }\n}\n\nvoid EnFireFlow_Draw(Actor* thisx, PlayState* play) {\n    EnFireFlow* this = (EnFireFlow*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 255, 50, 0, 255);\n    \n    Matrix_Push();\n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, this->actor.scale.z, MTXMODE_APPLY);\n    Matrix_RotateY(this->actor.world.rot.y * (M_PI / 32768.0f), MTXMODE_APPLY);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__), \n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n    \n    Matrix_Pop();\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_FireFlow_InitVars = {\n    /**/ ACTOR_EN_FIREFLOW,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnFireFlow),\n    /**/ EnFireFlow_Init,\n    /**/ EnFireFlow_Destroy,\n    /**/ EnFireFlow_Update, \n    /**/ EnFireFlow_Draw\n};"}
{"instruction": "Create a environmental system", "output": "{\n  \"instruction\": \"Create a Spirit Temple sand flow and time mechanics with multiple states and transitions\",\n  \"input\": null,\n  \"output\": \"```c\n// Spirit Temple sand flow actor\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 sandHeight;\n    /* 0x0154 */ f32 targetHeight;\n    /* 0x0158 */ f32 flowSpeed;\n    /* 0x015C */ Vec3f particlePos[16];\n    /* 0x01FC */ s16 particleTimer[16];\n    /* 0x021C */ ColliderCylinder collider;\n} EnSandFlow; // size = 0x268\n\n// Action states\n#define SANDFLOW_STATE_IDLE 0\n#define SANDFLOW_STATE_RISING 1\n#define SANDFLOW_STATE_FALLING 2\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000008, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 50, 100, 0, { 0, 0, 0 } },\n};\n\nvoid EnSandFlow_Init(Actor* thisx, PlayState* play) {\n    EnSandFlow* this = (EnSandFlow*)thisx;\n    s32 i;\n\n    Actor_SetScale(&this->actor, 0.1f);\n    \n    // Initialize collision\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actionState = SANDFLOW_STATE_IDLE;\n    this->sandHeight = this->actor.world.pos.y;\n    this->targetHeight = this->sandHeight;\n    this->flowSpeed = 0.0f;\n    \n    // Initialize particles\n    for (i = 0; i < 16; i++) {\n        this->particlePos[i] = this->actor.world.pos;\n        this->particleTimer[i] = 0;\n    }\n}\n\nvoid EnSandFlow_UpdateParticles(EnSandFlow* this) {\n    s32 i;\n    \n    for (i = 0; i < 16; i++) {\n        if (this->particleTimer[i] > 0) {\n            this->particleTimer[i]--;\n            this->particlePos[i].y += this->flowSpeed;\n        } else if (Rand_ZeroOne() < 0.1f) {\n            this->particlePos[i] = this->actor.world.pos;\n            this->particlePos[i].x += Rand_CenteredFloat(30.0f);\n            this->particlePos[i].z += Rand_CenteredFloat(30.0f);\n            this->particleTimer[i] = 30;\n        }\n    }\n}\n\nvoid EnSandFlow_Update(Actor* thisx, PlayState* play) {\n    EnSandFlow* this = (EnSandFlow*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    switch (this->actionState) {\n        case SANDFLOW_STATE_IDLE:\n            if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 100.0f) {\n                this->actionState = SANDFLOW_STATE_RISING;\n                this->targetHeight = this->sandHeight + 200.0f;\n                this->flowSpeed = 2.0f;\n            }\n            break;\n            \n        case SANDFLOW_STATE_RISING:\n            Math_SmoothStepToF(&this->actor.world.pos.y, this->targetHeight, 0.3f, 3.0f, 0.1f);\n            \n            if (fabsf(this->actor.world.pos.y - this->targetHeight) < 1.0f) {\n                this->actionState = SANDFLOW_STATE_FALLING;\n                this->targetHeight = this->sandHeight;\n                this->flowSpeed = -2.0f;\n            }\n            break;\n            \n        case SANDFLOW_STATE_FALLING:\n            Math_SmoothStepToF(&this->actor.world.pos.y, this->targetHeight, 0.3f, 3.0f, 0.1f);\n            \n            if (fabsf(this->actor.world.pos.y - this->targetHeight) < 1.0f) {\n                this->actionState = SANDFLOW_STATE_IDLE;\n                this->flowSpeed = 0.0f;\n            }\n            break;\n    }\n    \n    EnSandFlow_UpdateParticles(this);\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnSandFlow_Draw(Actor* thisx, PlayState* play) {\n    EnSandFlow* this = (EnSandFlow*)thisx;\n    s32 i;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 200, 170, 100, 255);\n    \n    Matrix_Push();\n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, \n                    this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, \n                this->actor.scale.z, MTXMODE_APPLY);\n    Matrix_RotateY(this->actor.world.rot.y * (M_PI / 32768.0f), MTXMODE_APPLY);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n              \n    Matrix_Pop();\n    \n    // Draw particles\n    for (i = 0; i < 16; i++) {\n        if (this->particleTimer[i] > 0) {\n            Matrix_Push();\n            Matrix_Translate(this->particlePos[i].x, this->particlePos[i].y,\n                           this->particlePos[i].z, MTXMODE_NEW);\n            Matrix_Scale(0.2f, 0.2f, 0.2f, MTXMODE_APPLY);\n            \n            gSPMatrix(POLY_OPA_DISP++, \n                     Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n                     G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n            Matrix_Pop();\n        }\n    }\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_SandFlow_InitVars = {\n    /**/ ACTOR_EN_SANDFLOW,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnSandFlow),\n    /**/ EnSandFlow_Init,\n    /**/ Actor_Destroy,\n    /**/ EnSandFlow_Update,\n    /**/ EnSandFlow_Draw\n};\n```\"}"}
{"instruction": "Create a actor creation system", "output": "{\n  \"instruction\": \"Design a power gauntlet that can creates protective barriers against attacks for puzzle solving implementing core requirements\",\n  \"input\": null,\n  \"output\": \"```c\n// Barrier Gauntlet actor that creates protective barriers\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ ColliderCylinder collider;\n    /* 0x0198 */ s16 timer;\n    /* 0x019A */ s16 activeTime;\n    /* 0x019C */ f32 barrierScale;\n    /* 0x01A0 */ f32 targetScale;\n} EnBarrier; // size = 0x01A4\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 40, 60, 0, { 0, 0, 0 } },\n};\n\nvoid EnBarrier_Init(Actor* thisx, PlayState* play) {\n    EnBarrier* this = (EnBarrier*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.0f);\n    this->barrierScale = 0.0f;\n    this->targetScale = 0.01f;\n    this->timer = 0;\n    this->activeTime = 100;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.flags |= ACTOR_FLAG_4;\n    this->actor.flags |= ACTOR_FLAG_0;\n}\n\nvoid EnBarrier_Destroy(Actor* thisx, PlayState* play) {\n    EnBarrier* this = (EnBarrier*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnBarrier_Update(Actor* thisx, PlayState* play) {\n    EnBarrier* this = (EnBarrier*)thisx;\n    Player* player = GET_PLAYER(play);\n\n    if (this->timer >= this->activeTime) {\n        Actor_Kill(&this->actor);\n        return;\n    }\n\n    this->timer++;\n    \n    // Smooth scale animation\n    Math_SmoothStepToF(&this->barrierScale, this->targetScale, 0.3f, 0.02f, 0.001f);\n    Actor_SetScale(&this->actor, this->barrierScale);\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnBarrier_Draw(Actor* thisx, PlayState* play) {\n    EnBarrier* this = (EnBarrier*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_Scale(this->barrierScale, this->barrierScale, this->barrierScale, MTXMODE_APPLY);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n              \n    gSPDisplayList(POLY_OPA_DISP++, gEffFlash1DL);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Barrier_InitVars = {\n    /**/ ACTOR_EN_BARRIER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnBarrier),\n    /**/ EnBarrier_Init,\n    /**/ EnBarrier_Destroy,\n    /**/ EnBarrier_Update,\n    /**/ EnBarrier_Draw\n};\n```\"\n}"}
{"instruction": "Create a code explanation system", "output": "{\n  \"instruction\": \"Make a code explanation that follows OoT decompilation standards implementing essential features\",\n  \"input\": null,\n  \"output\": \"Here's an example of an authentic OoT actor implementation following decompilation patterns:\n\n```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState; \n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnCrystal; // size = 0x1A0\n\nvoid EnCrystal_Init(Actor* thisx, PlayState* play) {\n    EnCrystal* this = (EnCrystal*)thisx;\n    \n    // Initialize collision using authentic pattern\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.gravity = -1.0f;\n    this->actor.minVelocityY = -10.0f;\n    Actor_SetScale(&this->actor, 0.01f);\n    \n    this->actionState = 0;\n    this->timer = 0;\n}\n\nvoid EnCrystal_Update(Actor* thisx, PlayState* play) {\n    EnCrystal* this = (EnCrystal*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    // Update collision and physics\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 0.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Basic state machine\n    switch(this->actionState) {\n        case 0:\n            if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 100.0f) {\n                this->actionState = 1;\n                this->timer = 20;\n            }\n            break;\n            \n        case 1:\n            this->timer--;\n            if (this->timer <= 0) {\n                Actor_Kill(&this->actor);\n            }\n            break;\n    }\n    \n    // Apply movement\n    Actor_MoveXZGravity(&this->actor);\n}\n\nvoid EnCrystal_Draw(Actor* thisx, PlayState* play) {\n    EnCrystal* this = (EnCrystal*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__), \n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n    gSPDisplayList(POLY_OPA_DISP++, gCrystalDL);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Crystal_InitVars = {\n    /**/ ACTOR_EN_CRYSTAL,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnCrystal),\n    /**/ EnCrystal_Init,\n    /**/ EnCrystal_Destroy,\n    /**/ EnCrystal_Update,\n    /**/ EnCrystal_Draw\n};\n```\n\nThis demonstrates authentic OoT patterns including:\n- Proper actor struct layout with correct offsets\n- Standard collision initialization and updates\n- Authentic player distance checking\n- Proper graphics setup with OPEN/CLOSE_DISPS\n- Correct matrix and display list handling\n- Standard actor movement and physics\n- Authentic state machine pattern\"\n}"}
{"instruction": "Create a actor creation system", "output": "{\n  \"instruction\": \"What's the best way to create a lightning spirit that steal and use the player's items temporarily? using advanced AI techniques in a forest temple setting using advanced optimization techniques\",\n  \"input\": null,\n  \"output\": \"```c\n// Spirit that steals items and mimics player actions\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ Vec3s jointTable[25];\n    /* 0x01F4 */ Vec3s morphTable[25];\n    /* 0x0258 */ s16 actionState;\n    /* 0x025A */ s16 actionTimer;\n    /* 0x025C */ s16 stolenItem;\n    /* 0x025E */ s16 attackTimer;\n    /* 0x0260 */ f32 targetY;\n    /* 0x0264 */ Vec3f lightningPos[8];\n    /* 0x02C4 */ ColliderCylinder collider;\n} EnSpiritThief;\n\n// Collision initialization values\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_HIT0,\n        AT_ON | AT_TYPE_ENEMY,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0xFFCFFFFF, 0x00, 0x04 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_ON | TOUCH_SFX_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 25, 45, 0, { 0, 0, 0 } },\n};\n\nvoid EnSpiritThief_Init(Actor* thisx, PlayState* play) {\n    EnSpiritThief* this = (EnSpiritThief*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    SkelAnime_InitFlex(play, &this->skelAnime, &gGhostSkel, &gGhostFloatAnim, \n                       this->jointTable, this->morphTable, 25);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actionState = 0;\n    this->stolenItem = -1;\n    this->actor.gravity = -1.0f;\n    this->targetY = this->actor.world.pos.y;\n}\n\nvoid EnSpiritThief_StealItem(EnSpiritThief* this, PlayState* play) {\n    Player* player = GET_PLAYER(play);\n    \n    // Check if close enough to steal\n    if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 100.0f) {\n        // Get currently equipped item\n        s16 item = gSaveContext.equips.buttonItems[1];\n        \n        if (item != ITEM_NONE) {\n            this->stolenItem = item;\n            // Temporarily remove item from inventory\n            gSaveContext.equips.buttonItems[1] = ITEM_NONE;\n            // Play steal effect/sound\n            Audio_PlayActorSound2(&this->actor, NA_SE_EN_STAL_DAMAGE);\n        }\n    }\n}\n\nvoid EnSpiritThief_Update(Actor* thisx, PlayState* play) {\n    EnSpiritThief* this = (EnSpiritThief*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    switch(this->actionState) {\n        case 0: // Chase player\n            Math_SmoothStepToF(&this->actor.world.pos.x, player->actor.world.pos.x, \n                              0.3f, 5.0f, 0.0f);\n            Math_SmoothStepToF(&this->actor.world.pos.z, player->actor.world.pos.z, \n                              0.3f, 5.0f, 0.0f);\n            \n            // Float up/down\n            this->targetY = this->actor.world.pos.y + Math_SinS(this->actionTimer * 0x800) * 10.0f;\n            Math_SmoothStepToF(&this->actor.world.pos.y, this->targetY, 0.3f, 3.0f, 0.0f);\n            \n            if (!this->stolenItem) {\n                EnSpiritThief_StealItem(this, play);\n            }\n            break;\n            \n        case 1: // Use stolen item\n            if (this->stolenItem != -1) {\n                // Use item logic here\n                this->attackTimer--;\n                if (this->attackTimer <= 0) {\n                    // Return item\n                    gSaveContext.equips.buttonItems[1] = this->stolenItem;\n                    this->stolenItem = -1;\n                    this->actionState = 0;\n                }\n            }\n            break;\n    }\n    \n    this->actionTimer++;\n    SkelAnime_Update(&this->skelAnime);\n    \n    // Check if hit\n    if (this->collider.base.acFlags & AC_HIT) {\n        // Return stolen item if hit\n        if (this->stolenItem != -1) {\n            gSaveContext.equips.buttonItems[1] = this->stolenItem;\n        }\n        Actor_Kill(&this->actor);\n    }\n}\n\nvoid EnSpiritThief_Draw(Actor* thisx, PlayState* play) {\n    EnSpiritThief* this = (EnSpiritThief*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    // Draw lightning effects\n    if (this->stolenItem != -1) {\n        Matrix_Push();\n        // Draw lightning particles\n        Matrix_Pop();\n    }\n    \n    // Draw ghost model\n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                          this->skelAnime.dListCount, NULL, NULL, this);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_SpiritThief_InitVars = {\n    /**/ ACTOR_EN_SPIRIT_THIEF,\n    /**/ ACTORCAT_ENEMY,\n    /**/ FLAGS,\n    /**/ OBJECT_GHOST,\n    /**/ sizeof(EnSpiritThief),\n    /**/ EnSpiritThief_Init,\n    /**/ EnSpiritThief_Destroy,\n    /**/ EnSpiritThief_Update,\n    /**/ EnSpiritThief_Draw\n};\n```\"\n}"}
