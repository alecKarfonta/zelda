{"instruction": "Create a actor creation system", "output": "{\n  \"instruction\": \"I need a energy conduit that can controls water levels and flow using timing mechanisms for dungeon progression using advanced optimization techniques\",\n  \"input\": null,\n  \"output\": \"```c\n// Energy conduit actor that controls water flow timing\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 activeState;\n    /* 0x0150 */ f32 spinRate;\n    /* 0x0154 */ s16 waterLevel;\n    /* 0x156 */ s16 targetLevel; \n    /* 0x158 */ ColliderCylinder collider;\n    /* 0x1A4 */ s16 switchFlag;\n} EnWaterConduit; // size = 0x1A8\n\nvoid EnWaterConduit_Init(Actor* thisx, PlayState* play) {\n    EnWaterConduit* this = (EnWaterConduit*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->switchFlag = (this->actor.params >> 8) & 0x3F;\n    this->waterLevel = -500;\n    this->targetLevel = -500;\n    this->spinRate = 0.0f;\n    this->activeState = 0;\n    \n    Actor_SetScale(&this->actor, 0.1f);\n}\n\nvoid EnWaterConduit_Destroy(Actor* thisx, PlayState* play) {\n    EnWaterConduit* this = (EnWaterConduit*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnWaterConduit_Update(Actor* thisx, PlayState* play) {\n    EnWaterConduit* this = (EnWaterConduit*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    // Check switch state\n    if (Flags_GetSwitch(play, this->switchFlag)) {\n        if (this->activeState == 0) {\n            this->activeState = 1;\n            this->targetLevel = 100; // Raise water\n        }\n    } else if (this->activeState == 1) {\n        this->activeState = 0;\n        this->targetLevel = -500; // Lower water\n    }\n\n    // Update water level with smooth interpolation\n    Math_SmoothStepToS(&this->waterLevel, this->targetLevel, 3, 20, 1);\n    \n    // Update visuals\n    this->spinRate += 0.1f;\n    if (this->spinRate >= 360.0f) {\n        this->spinRate -= 360.0f;\n    }\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Ripple effect when active\n    if (this->activeState == 1 && (this->timer & 0xF) == 0) {\n        EffectSsGRipple_Spawn(play, &this->actor.world.pos, 100, 500, 0);\n    }\n}\n\nvoid EnWaterConduit_Draw(Actor* thisx, PlayState* play) {\n    EnWaterConduit* this = (EnWaterConduit*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Push();\n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, \n                    this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_RotateY(BINANG_TO_RAD(this->actor.world.rot.y), MTXMODE_APPLY);\n    Matrix_RotateX(BINANG_TO_RAD(this->actor.world.rot.x), MTXMODE_APPLY);\n    Matrix_RotateZ(this->spinRate * (M_PI / 180.0f), MTXMODE_APPLY);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, \n                this->actor.scale.z, MTXMODE_APPLY);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_MODELVIEW | G_MTX_LOAD);\n    gSPDisplayList(POLY_OPA_DISP++, gWaterConduitDL);\
    \n    Matrix_Pop();\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_WaterConduit_InitVars = {\n    /**/ ACTOR_EN_WATER_CONDUIT,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_WATER_CONDUIT,\n    /**/ sizeof(EnWaterConduit),\n    /**/ EnWaterConduit_Init,\n    /**/ EnWaterConduit_Destroy,\n    /**/ EnWaterConduit_Update,\n    /**/ EnWaterConduit_Draw\n};\n```\"\n}"}
{"instruction": "Create a actor creation system", "output": "{\n  \"instruction\": \"Build a forest guardian that uses environmental hazards as weapons when the player approaches with complex AI decision trees implementing standard patterns\",\n  \"input\": null,\n  \"output\": \"```c\n// Forest Guardian actor that uses environmental hazards\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ Vec3s jointTable[20];\n    /* 0x01F0 */ Vec3s morphTable[20];\n    /* 0x0250 */ ColliderCylinder collider;\n    /* 0x029C */ s16 actionState;\n    /* 0x029E */ s16 timer;\n    /* 0x02A0 */ f32 attackRange;\n    /* 0x02A4 */ Vec3f targetPos;\n    /* 0x02B0 */ s16 attackType;\n} EnForestGuard; // size = 0x02B4\n\ntypedef enum {\n    /* 0x00 */ FORESTGUARD_IDLE,\n    /* 0x01 */ FORESTGUARD_NOTICE,\n    /* 0x02 */ FORESTGUARD_ATTACK,\n    /* 0x03 */ FORESTGUARD_RETREAT\n} ForestGuardState;\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_HIT0,\n        AT_ON | AT_TYPE_ENEMY,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0xFFCFFFFF, 0x00, 0x08 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_ON | TOUCH_SFX_WOOD,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 25, 70, 0, { 0, 0, 0 } },\n};\n\nvoid EnForestGuard_Init(Actor* thisx, PlayState* play) {\n    EnForestGuard* this = (EnForestGuard*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.015f);\n    \n    SkelAnime_InitFlex(play, &this->skelAnime, &gForestGuardSkel, &gForestGuardIdleAnim, \n                       this->jointTable, this->morphTable, 20);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actionState = FORESTGUARD_IDLE;\n    this->timer = 0;\n    this->attackRange = 200.0f;\n    this->attackType = 0;\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 35.0f, 60.0f, 60.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n}\n\nvoid EnForestGuard_Destroy(Actor* thisx, PlayState* play) {\n    EnForestGuard* this = (EnForestGuard*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnForestGuard_SetupIdle(EnForestGuard* this) {\n    Animation_Change(&this->skelAnime, &gForestGuardIdleAnim, 1.0f, 0.0f,\n                    Animation_GetLastFrame(&gForestGuardIdleAnim), ANIMMODE_LOOP, -8.0f);\n    this->actionState = FORESTGUARD_IDLE;\n    this->timer = (s16)(Rand_ZeroFloat(60.0f) + 40.0f);\n}\n\nvoid EnForestGuard_SetupAttack(EnForestGuard* this) {\n    Animation_Change(&this->skelAnime, &gForestGuardAttackAnim, 1.0f, 0.0f,\n                    Animation_GetLastFrame(&gForestGuardAttackAnim), ANIMMODE_ONCE, -8.0f);\n    this->actionState = FORESTGUARD_ATTACK;\n    this->timer = 30;\n}\n\nvoid EnForestGuard_Idle(EnForestGuard* this, PlayState* play) {\n    Player* player = GET_PLAYER(play);\n    f32 dist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    SkelAnime_Update(&this->skelAnime);\n    \n    if (dist < this->attackRange) {\n        this->actionState = FORESTGUARD_NOTICE;\n        this->timer = 20;\n    }\n}\n\nvoid EnForestGuard_Notice(EnForestGuard* this, PlayState* play) {\n    Player* player = GET_PLAYER(play);\n    \n    Math_SmoothStepToS(&this->actor.shape.rot.y, \n                       Actor_WorldYawTowardActor(&this->actor, &player->actor), 5, 2000, 0);\n    \n    if (--this->timer <= 0) {\n        EnForestGuard_SetupAttack(this);\n    }\n}\n\nvoid EnForestGuard_Attack(EnForestGuard* this, PlayState* play) {\n    SkelAnime_Update(&this->skelAnime);\n    \n    if (--this->timer <= 0) {\n        // Spawn hazard actor based on attackType\n        Actor_SpawnAsChild(&play->actorCtx, &this->actor, play, ACTOR_EN_WOOD_EFFECT,\n                          this->targetPos.x, this->targetPos.y, this->targetPos.z,\n                          0, this->actor.shape.rot.y, 0, this->attackType);\n        \n        EnForestGuard_SetupIdle(this);\n    }\n}\n\nvoid EnForestGuard_Update(Actor* thisx, PlayState* play) {\n    EnForestGuard* this = (EnForestGuard*)thisx;\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 35.0f, 60.0f, 60.0f,\n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    \n    switch (this->actionState) {\n        case FORESTGUARD_IDLE:\n            EnForestGuard_Idle(this, play);\n            break;\n        case FORESTGUARD_NOTICE:\n            EnForestGuard_Notice(this, play);\n            break;\n        case FORESTGUARD_ATTACK:\n            EnForestGuard_Attack(this, play);\n            break;\n    }\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnForestGuard_Draw(Actor* thisx, PlayState* play) {\n    EnForestGuard* this = (EnForestGuard*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\
            this->skelAnime.dListCount, NULL, NULL, this);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile EnForestGuard_Profile = {\n    /**/ ACTOR_EN_FOREST_GUARD,\n    /**/ ACTORCAT_ENEMY,\n    /**/ FLAGS,\n    /**/ OBJECT_FOREST_GUARD,\n    /**/ sizeof(EnForestGuard),\n    /**/ EnForestGuard_Init,\n    /**/ EnForestGuard_Destroy,\n    /**/ EnForestGuard_Update,\n    /**/ EnForestGuard_Draw\n};\n```\"\n}"}
{"instruction": "Create a puzzle system system", "output": "{\n  \"instruction\": \"Design a gravity well mechanism that controls water levels and flow with multiple states using advanced memory management\",\n  \"input\": null,\n  \"output\": \"```c\n// Gravity well that affects water room systems\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 activeTimer;\n    /* 0x014E */ s16 state;\n    /* 0x0150 */ f32 spinRate;\n    /* 0x0154 */ f32 effectRadius;\n    /* 0x0158 */ Vec3f effectCenter;\n    /* 0x0164 */ ColliderCylinder collider;\n    /* 0x01B0 */ s16 roomWaterLevel[3]; // Store 3 possible water heights\n    /* 0x01B6 */ s16 targetWaterLevel;\n} EnWaterWell; // size = 0x1B8\n\nvoid EnWaterWell_Init(Actor* thisx, PlayState* play) {\n    EnWaterWell* this = (EnWaterWell*)thisx;\n    \n    this->state = 0;\n    this->activeTimer = 0;\n    this->spinRate = 0.0f;\n    this->effectRadius = 100.0f;\n    this->effectCenter = this->actor.world.pos;\n    \n    // Store initial room water levels\n    this->roomWaterLevel[0] = -200;  // Low water\n    this->roomWaterLevel[1] = 0;     // Mid water  \n    this->roomWaterLevel[2] = 200;   // High water\n    this->targetWaterLevel = this->roomWaterLevel[0];\n\n    // Setup collision\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.1f);\n}\n\nvoid EnWaterWell_Destroy(Actor* thisx, PlayState* play) {\n    EnWaterWell* this = (EnWaterWell*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnWaterWell_UpdateWaterLevel(EnWaterWell* this, PlayState* play) {\n    Player* player = GET_PLAYER(play);\n    f32 distToPlayer = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    // Check if player is in range\n    if (distToPlayer < this->effectRadius) {\n        if (this->state == 0) {\n            this->targetWaterLevel = this->roomWaterLevel[0];\n            this->spinRate = 1.0f;\n        } else if (this->state == 1) {\n            this->targetWaterLevel = this->roomWaterLevel[1]; \n            this->spinRate = 2.0f;\n        } else {\n            this->targetWaterLevel = this->roomWaterLevel[2];\n            this->spinRate = 3.0f;\n        }\n        \n        // Update room water system through room context\n        play->roomCtx.curRoom.waterLevelPres = this->targetWaterLevel;\n    }\n}\n\nvoid EnWaterWell_Update(Actor* thisx, PlayState* play) {\n    EnWaterWell* this = (EnWaterWell*)thisx;\n    \n    this->activeTimer++;\n    \n    if (this->activeTimer > 60) {\n        this->state = (this->state + 1) % 3;\n        this->activeTimer = 0;\n    }\n\n    EnWaterWell_UpdateWaterLevel(this, play);\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Update background collision info\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 20.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n}\n\nvoid EnWaterWell_Draw(Actor* thisx, PlayState* play) {\n    EnWaterWell* this = (EnWaterWell*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Push();\n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, \n                    this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y,\
                this->actor.scale.z, MTXMODE_APPLY);\n    Matrix_RotateY(this->actor.world.rot.y * (M_PI / 32768.0f), MTXMODE_APPLY);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\
                G_MTX_MODELVIEW | G_MTX_LOAD);\n    gSPDisplayList(POLY_OPA_DISP++, gWaterWellDL);\
    \n    Matrix_Pop();\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_WaterWell_InitVars = {\n    /**/ ACTOR_EN_WATER_WELL,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnWaterWell),\n    /**/ EnWaterWell_Init,\n    /**/ EnWaterWell_Destroy,\n    /**/ EnWaterWell_Update,\n    /**/ EnWaterWell_Draw\n};\n```\"\n}"}
{"instruction": "Implement a sound optimization system for performance with multiple states and transitions", "output": "// Authentic sound optimization system based on OoT patterns\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 soundTimer;\n    /* 0x014E */ s16 soundState;\n    /* 0x0150 */ f32 soundRadius;\n    /* 0x0154 */ Vec3f lastSoundPos;\n    /* 0x0160 */ s16 delayTimer;\n    /* 0x0162 */ s16 playbackState;\n    /* 0x0164 */ ColliderCylinder collider;\n} EnSoundOpt; // size = 0x1B0\n\nenum SoundOptState {\n    /* 0 */ SOUNDOPT_IDLE,\n    /* 1 */ SOUNDOPT_ACTIVE,\n    /* 2 */ SOUNDOPT_FADING,\n    /* 3 */ SOUNDOPT_COOLDOWN\n};\n\nvoid EnSoundOpt_Init(Actor* thisx, PlayState* play) {\n    EnSoundOpt* this = (EnSoundOpt*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->soundTimer = 0;\n    this->soundState = SOUNDOPT_IDLE;\n    this->soundRadius = 300.0f;\n    this->delayTimer = 0;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n}\n\nvoid EnSoundOpt_Update(Actor* thisx, PlayState* play) {\n    EnSoundOpt* this = (EnSoundOpt*)thisx;\n    Player* player = GET_PLAYER(play);\n    f32 dist;\n    \n    this->delayTimer--;\n    \n    if (this->delayTimer <= 0) {\n        dist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n        \n        switch (this->soundState) {\n            case SOUNDOPT_IDLE:\n                if (dist < this->soundRadius) {\n                    this->soundState = SOUNDOPT_ACTIVE;\n                    this->soundTimer = 20;\n                    Audio_PlayActorSound2(&this->actor, NA_SE_PL_WALK_GROUND);\n                }\n                break;\n                \n            case SOUNDOPT_ACTIVE:\n                if (dist > this->soundRadius) {\n                    this->soundState = SOUNDOPT_FADING;\n                    this->soundTimer = 10;\n                } else if (--this->soundTimer <= 0) {\n                    Audio_PlayActorSound2(&this->actor, NA_SE_PL_WALK_GROUND);\n                    this->soundTimer = 20;\n                }\n                break;\n                \n            case SOUNDOPT_FADING:\n                if (--this->soundTimer <= 0) {\n                    this->soundState = SOUNDOPT_COOLDOWN;\n                    this->delayTimer = 30;\n                }\n                break;\n                \n            case SOUNDOPT_COOLDOWN:\n                this->soundState = SOUNDOPT_IDLE;\n                break;\n        }\n    }\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 0.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnSoundOpt_Draw(Actor* thisx, PlayState* play) {\n    EnSoundOpt* this = (EnSoundOpt*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\
            G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_SoundOpt_InitVars = {\n    /**/ ACTOR_EN_SOUNDOPT,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnSoundOpt),\n    /**/ EnSoundOpt_Init,\n    /**/ EnSoundOpt_Destroy,\n    /**/ EnSoundOpt_Update, \n    /**/ EnSoundOpt_Draw\n};"}
{"instruction": "Create a feature implementation system", "output": "{\n  \"instruction\": \"Create a feature implementation system with proper OoT patterns using advanced rendering techniques\",\n  \"input\": null,\n  \"output\": \"```c\n// Advanced rendering effect actor\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 effectState;\n    /* 0x0150 */ f32 alpha;\n    /* 0x0154 */ Vec3f effectPos[8];\n    /* 0x01B4 */ f32 effectScale[8];\n    /* 0x01D4 */ SkelAnime skelAnime;\n    /* 0x0218 */ Vec3s jointTable[20];\n    /* 0x0268 */ Vec3s morphTable[20];\n    /* 0x02B8 */ ColliderCylinder collider;\n} EnEffect; // size = 0x0304\n\nvoid EnEffect_Init(Actor* thisx, PlayState* play) {\n    EnEffect* this = (EnEffect*)thisx;\n    s32 i;\n\n    Actor_SetScale(&this->actor, 0.01f);\n    \n    // Initialize effect positions\n    for (i = 0; i < 8; i++) {\n        this->effectPos[i] = this->actor.world.pos;\n        this->effectScale[i] = 1.0f;\n    }\n\n    // Setup collision\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n\n    // Initialize skeleton animation\n    SkelAnime_InitFlex(play, &this->skelAnime, &gEffectSkel, &gEffectAnim,\n        this->jointTable, this->morphTable, 20);\n\n    this->alpha = 255.0f;\n    this->effectState = 0;\n    this->timer = 0;\n}\n\nvoid EnEffect_Destroy(Actor* thisx, PlayState* play) {\n    EnEffect* this = (EnEffect*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnEffect_Update(Actor* thisx, PlayState* play) {\n    EnEffect* this = (EnEffect*)thisx;\n    s32 i;\n    Player* player = GET_PLAYER(play);\n\n    this->timer++;\n\n    // Update effect positions\n    for (i = 0; i < 8; i++) {\n        f32 targetScale = 1.0f;\n        Math_SmoothStepToF(&this->effectScale[i], targetScale, 0.1f, 0.5f, 0.01f);\n    }\n\n    // Update collision\n    Actor_UpdateBgCheckInfo(play, &this->actor, 35.0f, 30.0f, 30.0f, \n        UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    // Animate skeleton\n    SkelAnime_Update(&this->skelAnime);\n}\n\nvoid EnEffect_Draw(Actor* thisx, PlayState* play) {\n    EnEffect* this = (EnEffect*)thisx;\n    s32 i;\n\n    OPEN_DISPS(play->state.gfxCtx);\n\n    // Setup rendering state\n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n\n    // Draw main effect\n    gDPSetPrimColor(POLY_XLU_DISP++, 0, 0, 255, 255, 255, (u8)this->alpha);\n    \n    Matrix_Push();\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, this->actor.scale.z, MTXMODE_APPLY);\n    Matrix_RotateY(this->actor.world.rot.y * (M_PI / 32768.0f), MTXMODE_APPLY);\n    gSPMatrix(POLY_XLU_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\
            G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n    Matrix_Pop();\n\n    // Draw skeleton\n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\
            this->skelAnime.dListCount, NULL, NULL, this);\n\n    // Draw particle effects\n    for (i = 0; i < 8; i++) {\n        Matrix_Push();\n        Matrix_Translate(this->effectPos[i].x, this->effectPos[i].y,\
            this->effectPos[i].z, MTXMODE_NEW);\n        Matrix_Scale(this->effectScale[i], this->effectScale[i],\
            this->effectScale[i], MTXMODE_APPLY);\n        gSPMatrix(POLY_XLU_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\
            G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n        Matrix_Pop();\n    }\n\n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile EnEffect_Profile = {\n    /**/ ACTOR_EN_EFFECT,\n    /**/ ACTORCAT_MISC,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnEffect),\n    /**/ EnEffect_Init,\n    /**/ EnEffect_Destroy, \n    /**/ EnEffect_Update,\n    /**/ EnEffect_Draw\n};\n```\"\n}"}
{"instruction": "Skip the intro video and start directly in the Deku Tree when starting a new game", "output": "{\n  \"instruction\": \"Skip the intro video and start directly in the Deku Tree when starting a new game\",\n  \"input\": null,\n  \"output\": \"To skip the intro video and start directly in the Deku Tree, modify these files:\\n\\n**File: `oot/src/overlays/gamestates/ovl_file_choose/z_file_choose.c`**\\n- Line ~1890: Change `gSaveContext.respawn[RESPAWN_MODE_DOWN].entranceIndex = ENTR_LOAD_OPENING;` to `gSaveContext.respawn[RESPAWN_MODE_DOWN].entranceIndex = ENTR_DEKU_TREE_0;`\\n- Add these lines after the entrance index change:\\n  ```c\\n  gSaveContext.save.entranceIndex = ENTR_DEKU_TREE_0;\\n  gSaveContext.save.cutsceneIndex = CS_INDEX_NONE;\\n  gSaveContext.save.linkAge = LINK_AGE_CHILD;\\n  ```\\n\\n**File: `oot/src/code/z_play.c`**\\n- Line ~295: Replace the opening sequence check with:\\n  ```c\\n  if (gSaveContext.save.entranceIndex == ENTR_LOAD_OPENING) {\\n      // Skip the opening sequence and go directly to the Deku Tree\\n      gSaveContext.save.entranceIndex = ENTR_DEKU_TREE_0;\\n      gSaveContext.save.linkAge = LINK_AGE_CHILD;\\n      gSaveContext.save.cutsceneIndex = CS_INDEX_NONE;\\n      gSaveContext.sceneLayer = SCENE_LAYER_CHILD_DAY;\\n  }\\n  ```\\n\\n**Key Changes:**\\n- `ENTR_LOAD_OPENING` (-1) → `ENTR_DEKU_TREE_0` (0)\\n- Set `cutsceneIndex` to `CS_INDEX_NONE` to skip cutscenes\\n- Set `linkAge` to `LINK_AGE_CHILD` for proper character state\\n- Set `sceneLayer` to `SCENE_LAYER_CHILD_DAY` for correct time of day\\n\\nThis modification bypasses the entire opening sequence and places the player directly in the Deku Tree as child Link, ready to begin gameplay immediately.\"}"}
{"instruction": "Modify the Nintendo logo texture to display custom text instead of 'Nintendo'", "output": "{\n  \"instruction\": \"Modify the Nintendo logo texture to display custom text instead of 'Nintendo'\",\n  \"input\": null,\n  \"output\": \"To modify the Nintendo logo texture in the intro sequence, follow these steps:\\n\\n**File: `oot/extracted/ntsc-1.2/assets/textures/nintendo_rogo_static/nintendo_rogo_static_Tex_000000.i8.png`**\\n- Edit the PNG file using an image editor (GIMP, Photoshop, etc.)\\n- Replace the 'Nintendo' text with your custom text (e.g., 'Test')\\n- Maintain the same image dimensions and format\\n- Save the modified PNG file\\n\\n**Rebuild Process:**\\n1. Run the build tool manually to convert the modified PNG:\\n   ```bash\\n   tools/assets/build_from_png/build_from_png extracted/ntsc-1.2/assets/textures/nintendo_rogo_static/nintendo_rogo_static_Tex_000000.i8.png build/ntsc-1.2/assets/textures/nintendo_rogo_static/ extracted/ntsc-1.2/assets/textures/nintendo_rogo_static/\\n   ```\\n\\n2. Force rebuild by touching the source file:\\n   ```bash\\n   touch extracted/ntsc-1.2/assets/textures/nintendo_rogo_static/nintendo_rogo_static_Tex_000000.i8.png\\n   make build/ntsc-1.2/assets/textures/nintendo_rogo_static/nintendo_rogo_static_Tex_000000.i8.inc.c VERSION=ntsc-1.2\\n   ```\\n\\n3. Build the full ROM:\\n   ```bash\\n   make VERSION=ntsc-1.2 ENG=1 -j4\\n   ```\\n\\n**Key Points:**\\n- The PNG file must have the correct format suffix (`.i8.png`)\\n- The build tool converts PNG to C header files (`.inc.c`)\\n- The modified texture appears in the intro sequence\\n- The ROM will have a different MD5 checksum (expected for modified assets)\\n\\nThis process allows you to customize the Nintendo logo that appears during the game's intro sequence.\"}"}
{"instruction": "Change adult Link's tunic color from green to red", "output": "{\n  \"instruction\": \"Change adult Link's tunic color from green to red\",\n  \"input\": null,\n  \"output\": \"To change adult Link's tunic color from green to red, modify this file:\\n\\n**File: `oot/src/code/z_player_lib.c`**\\n- Line 1070: Change `{ 128, 0, 128 }, // PLAYER_TUNIC_KOKIRI` to `{ 255, 0, 0 }, // PLAYER_TUNIC_KOKIRI`\\n\\n**Complete code change:**\\n```c\\nColor_RGB8 sTunicColors[PLAYER_TUNIC_MAX] = {\\n    { 255, 0, 0 },   // PLAYER_TUNIC_KOKIRI (red)\\n    { 100, 20, 0 },  // PLAYER_TUNIC_GORON\\n    { 0, 60, 100 },  // PLAYER_TUNIC_ZORA\\n};\\n```\\n\\n**Explanation:**\\n- The `sTunicColors` array controls the RGB color values for all of Link's tunics\\n- `PLAYER_TUNIC_KOKIRI` is the default green tunic worn by both child and adult Link\\n- RGB values `255, 0, 0` create a bright red color\\n- This modification affects both child and adult Link forms\\n\\n**Rebuild Process:**\\n```bash\\nmake VERSION=ntsc-1.2 ENG=1 -j4\\n```\\n\\n**Other color examples:**\\n- Blue: `{ 0, 0, 255 }`\\n- Yellow: `{ 255, 255, 0 }`\\n- White: `{ 255, 255, 255 }`\\n- Black: `{ 0, 0, 0 }`\\n\\nThis is the definitive method for changing Link's tunic colors in the decompiled Ocarina of Time source code.\"}"}
{"instruction": "Change Link's gauntlet colors from white to gold", "output": "{\n  \"instruction\": \"Change Link's gauntlet colors from white to gold\",\n  \"input\": null,\n  \"output\": \"To change Link's gauntlet colors from white to gold, modify this file:\\n\\n**File: `oot/src/code/z_player_lib.c`**\\n- Line 1076: Change `{ 255, 255, 255 },` to `{ 255, 215, 0 },`\\n\\n**Complete code change:**\\n```c\\nColor_RGB8 sGauntletColors[] = {\\n    { 255, 215, 0 },  // Default gauntlets (gold)\\n    { 254, 207, 15 }, // Silver Gauntlets (unchanged)\\n};\\n```\\n\\n**Explanation:**\\n- The `sGauntletColors` array controls the RGB color values for Link's gauntlets\\n- Index 0 is the default gauntlet color (normally white)\\n- Index 1 is the Silver Gauntlets color (yellow-gold)\\n- RGB values `255, 215, 0` create a gold color\\n- This affects adult Link's gauntlets when equipped\\n\\n**Rebuild Process:**\\n```bash\\nmake VERSION=ntsc-1.2 ENG=1 -j4\\n```\\n\\n**Other gauntlet color examples:**\\n- Silver: `{ 192, 192, 192 }`\\n- Bronze: `{ 205, 127, 50 }`\\n- Red: `{ 255, 0, 0 }`\\n- Blue: `{ 0, 100, 255 }`\\n\\n**Note:** The Silver Gauntlets have their own dedicated color slot and can be modified independently of the default gauntlets.\"}"}
{"instruction": "Make all of Link's tunics the same bright blue color", "output": "{\n  \"instruction\": \"Make all of Link's tunics the same bright blue color\",\n  \"input\": null,\n  \"output\": \"To make all of Link's tunics bright blue, modify this file:\\n\\n**File: `oot/src/code/z_player_lib.c`**\\n- Lines 1070-1072: Change all tunic color values to blue\\n\\n**Complete code change:**\\n```c\\nColor_RGB8 sTunicColors[PLAYER_TUNIC_MAX] = {\\n    { 0, 150, 255 }, // PLAYER_TUNIC_KOKIRI (bright blue)\\n    { 0, 150, 255 }, // PLAYER_TUNIC_GORON (bright blue)\\n    { 0, 150, 255 }, // PLAYER_TUNIC_ZORA (bright blue)\\n};\\n```\\n\\n**Explanation:**\\n- This modification makes all three tunics the same bright blue color\\n- `PLAYER_TUNIC_KOKIRI` - Default green tunic → bright blue\\n- `PLAYER_TUNIC_GORON` - Fire-resistant red tunic → bright blue\\n- `PLAYER_TUNIC_ZORA` - Water-breathing blue tunic → bright blue\\n- RGB values `0, 150, 255` create a bright sky blue color\\n- All special properties (fire resistance, water breathing) remain intact\\n\\n**Rebuild Process:**\\n```bash\\nmake VERSION=ntsc-1.2 ENG=1 -j4\\n```\\n\\n**Alternative blue shades:**\\n- Navy blue: `{ 0, 0, 128 }`\\n- Royal blue: `{ 65, 105, 225 }`\\n- Light blue: `{ 173, 216, 230 }`\\n- Cyan: `{ 0, 255, 255 }`\\n\\nThis creates a uniform color scheme where all tunics share the same visual appearance while maintaining their unique gameplay functions.\"}"}
{"instruction": "Create rainbow-colored gauntlets that cycle through colors", "output": "{\n  \"instruction\": \"Create rainbow-colored gauntlets that cycle through colors\",\n  \"input\": null,\n  \"output\": \"To create rainbow-colored gauntlets, you need to modify both the color array and add dynamic color cycling. This requires changes to multiple files:\\n\\n**File: `oot/src/code/z_player_lib.c`**\\n\\nFirst, expand the gauntlet colors array:\\n```c\\nColor_RGB8 sGauntletColors[] = {\\n    { 255, 0, 0 },   // Red\\n    { 255, 165, 0 }, // Orange\\n    { 255, 255, 0 }, // Yellow\\n    { 0, 255, 0 },   // Green\\n    { 0, 0, 255 },   // Blue\\n    { 75, 0, 130 },  // Indigo\\n    { 148, 0, 211 }, // Violet\\n    { 254, 207, 15 }, // Silver Gauntlets (unchanged)\\n};\\n```\\n\\nAdd a color cycling function:\\n```c\\nstatic u8 sGauntletColorIndex = 0;\\nstatic s16 sGauntletColorTimer = 0;\\n\\nvoid Player_UpdateGauntletColors(void) {\\n    sGauntletColorTimer++;\\n    if (sGauntletColorTimer >= 10) { // Change color every 10 frames\\n        sGauntletColorIndex = (sGauntletColorIndex + 1) % 7; // Cycle through 7 rainbow colors\\n        sGauntletColorTimer = 0;\\n    }\\n}\\n\\nColor_RGB8* Player_GetCurrentGauntletColor(s32 gauntletType) {\\n    if (gauntletType == PLAYER_GAUNTLETS_SILVER) {\\n        return &sGauntletColors[7]; // Silver gauntlets use fixed color\\n    }\\n    return &sGauntletColors[sGauntletColorIndex]; // Use cycling rainbow color\\n}\\n```\\n\\n**Usage in player update function:**\\nAdd this call in the player's update function:\\n```c\\nPlayer_UpdateGauntletColors();\\n```\\n\\n**Rebuild Process:**\\n```bash\\nmake VERSION=ntsc-1.2 ENG=1 -j4\\n```\\n\\n**Explanation:**\\n- Creates 7 rainbow colors in the gauntlet array\\n- Adds a timer that cycles through colors every 10 frames (6 times per second)\\n- Silver Gauntlets maintain their original color\\n- Default gauntlets cycle through the rainbow spectrum\\n- The effect is visible during gameplay when gauntlets are equipped\\n\\n**Customization options:**\\n- Change timer value to speed up/slow down color cycling\\n- Modify RGB values for different color schemes\\n- Add more colors to the array for smoother transitions\\n\\nThis creates a dynamic visual effect where Link's gauntlets continuously cycle through rainbow colors during gameplay.\"}"}
{"instruction": "Make adult Link move faster by increasing his movement speed", "output": "{\n  \"instruction\": \"Make adult Link move faster by increasing his movement speed\",\n  \"input\": null,\n  \"output\": \"To make adult Link move faster, modify this file:\\n\\n**File: `oot/src/code/z_player_lib.c`**\\n- Line 39: Change `600,` to `800,` in the PLAYER_BOOTS_KOKIRI section\\n\\n**Complete code change:**\\n```c\\n// PLAYER_BOOTS_KOKIRI\\n{\\n    200,                         // REG(19)\\n    FRAMERATE_CONST(1000, 1200), // REG(30)\\n    FRAMERATE_CONST(300, 360),   // REG(32)\\n    700,                         // REG(34)\\n    FRAMERATE_CONST(550, 660),   // REG(35)\\n    FRAMERATE_CONST(270, 324),   // REG(36)\\n    800,                         // REG(37)\\n    FRAMERATE_CONST(350, 420),   // REG(38)\\n    800,                         // R_DECELERATE_RATE\\n    800,                         // R_RUN_SPEED_LIMIT (increased from 600)\\n    -100,                        // REG(68)\\n    600,                         // REG(69)\\n    590,                         // IREG(66)\\n    750,                         // IREG(67)\\n    125,                         // IREG(68)\\n    200,                         // IREG(69)\\n    FRAMERATE_CONST(130, 156),   // MREG(95)\\n},\\n```\\n\\n**Explanation:**\\n- `R_RUN_SPEED_LIMIT` controls adult Link's maximum movement speed\\n- Original value: 600 units/frame\\n- Modified value: 800 units/frame (33% faster)\\n- This only affects adult Link, child Link remains at normal speed (550)\\n- The change is immediately noticeable during gameplay\\n\\n**Rebuild Process:**\\n```bash\\nmake VERSION=ntsc-1.2 ENG=1 -j4\\n```\\n\\n**Speed comparison:**\\n- Child Link: 550 units/frame (unchanged)\\n- Adult Link: 600 → 800 units/frame (33% increase)\\n\\n**Other speed values:**\\n- Very fast: 1000 units/frame\\n- Super fast: 1200 units/frame\\n- Moderate increase: 700 units/frame\\n\\nThis modification makes adult Link noticeably faster while keeping child Link at the original speed.\"}"}
{"instruction": "Make child Link move faster by increasing his movement speed", "output": "{\n  \"instruction\": \"Make child Link move faster by increasing his movement speed\",\n  \"input\": null,\n  \"output\": \"To make child Link move faster, modify this file:\\n\\n**File: `oot/src/code/z_player_lib.c`**\\n- Line 142: Change `550,` to `750,` in the PLAYER_BOOTS_KOKIRI_CHILD section\\n\\n**Complete code change:**\\n```c\\n// PLAYER_BOOTS_KOKIRI_CHILD\\n{\\n    200,                         // REG(19)\\n    FRAMERATE_CONST(1000, 1200), // REG(30)\\n    FRAMERATE_CONST(300, 360),   // REG(32)\\n    800,                         // REG(34)\\n    FRAMERATE_CONST(500, 600),   // REG(35)\\n    FRAMERATE_CONST(400, 480),   // REG(36)\\n    800,                         // REG(37)\\n    FRAMERATE_CONST(400, 480),   // REG(38)\\n    800,                         // R_DECELERATE_RATE\\n    750,                         // R_RUN_SPEED_LIMIT (increased from 550)\\n    -100,                        // REG(68)\\n    600,                         // REG(69)\\n    540,                         // IREG(66)\\n    750,                         // IREG(67)\\n    125,                         // IREG(68)\\n    400,                         // IREG(69)\\n    FRAMERATE_CONST(200, 240),   // MREG(95)\\n},\\n```\\n\\n**Explanation:**\\n- `R_RUN_SPEED_LIMIT` controls child Link's maximum movement speed\\n- Original value: 550 units/frame\\n- Modified value: 750 units/frame (36% faster)\\n- This only affects child Link, adult Link remains at normal speed (600)\\n- The change is immediately noticeable during child Link gameplay\\n\\n**Rebuild Process:**\\n```bash\\nmake VERSION=ntsc-1.2 ENG=1 -j4\\n```\\n\\n**Speed comparison:**\\n- Child Link: 550 → 750 units/frame (36% increase)\\n- Adult Link: 600 units/frame (unchanged)\\n\\n**Other speed values:**\\n- Very fast: 900 units/frame\\n- Super fast: 1100 units/frame\\n- Moderate increase: 650 units/frame\\n\\nThis modification makes child Link noticeably faster while keeping adult Link at the original speed.\"}"}
{"instruction": "Make both child and adult Link move faster by increasing their movement speeds", "output": "{\n  \"instruction\": \"Make both child and adult Link move faster by increasing their movement speeds\",\n  \"input\": null,\n  \"output\": \"To make both child and adult Link move faster, modify this file:\\n\\n**File: `oot/src/code/z_player_lib.c`**\\n- Line 39: Change `600,` to `800,` in the PLAYER_BOOTS_KOKIRI section (adult)\\n- Line 142: Change `550,` to `700,` in the PLAYER_BOOTS_KOKIRI_CHILD section (child)\\n\\n**Complete code change:**\\n```c\\n// PLAYER_BOOTS_KOKIRI (Adult Link)\\n{\\n    200,                         // REG(19)\\n    FRAMERATE_CONST(1000, 1200), // REG(30)\\n    FRAMERATE_CONST(300, 360),   // REG(32)\\n    700,                         // REG(34)\\n    FRAMERATE_CONST(550, 660),   // REG(35)\\n    FRAMERATE_CONST(270, 324),   // REG(36)\\n    800,                         // REG(37)\\n    FRAMERATE_CONST(350, 420),   // REG(38)\\n    800,                         // R_DECELERATE_RATE\\n    800,                         // R_RUN_SPEED_LIMIT (increased from 600)\\n    -100,                        // REG(68)\\n    600,                         // REG(69)\\n    590,                         // IREG(66)\\n    750,                         // IREG(67)\\n    125,                         // IREG(68)\\n    200,                         // IREG(69)\\n    FRAMERATE_CONST(130, 156),   // MREG(95)\\n},\\n// PLAYER_BOOTS_KOKIRI_CHILD (Child Link)\\n{\\n    200,                         // REG(19)\\n    FRAMERATE_CONST(1000, 1200), // REG(30)\\n    FRAMERATE_CONST(300, 360),   // REG(32)\\n    800,                         // REG(34)\\n    FRAMERATE_CONST(500, 600),   // REG(35)\\n    FRAMERATE_CONST(400, 480),   // REG(36)\\n    800,                         // REG(37)\\n    FRAMERATE_CONST(400, 480),   // REG(38)\\n    800,                         // R_DECELERATE_RATE\\n    700,                         // R_RUN_SPEED_LIMIT (increased from 550)\\n    -100,                        // REG(68)\\n    600,                         // REG(69)\\n    540,                         // IREG(66)\\n    750,                         // IREG(67)\\n    125,                         // IREG(68)\\n    400,                         // IREG(69)\\n    FRAMERATE_CONST(200, 240),   // MREG(95)\\n},\\n```\\n\\n**Explanation:**\\n- Adult Link: `R_RUN_SPEED_LIMIT` 600 → 800 (33% faster)\\n- Child Link: `R_RUN_SPEED_LIMIT` 550 → 700 (27% faster)\\n- Both forms of Link are now faster than the original game\\n- The changes are immediately noticeable during gameplay\\n\\n**Rebuild Process:**\\n```bash\\nmake VERSION=ntsc-1.2 ENG=1 -j4\\n```\\n\\n**Speed comparison:**\\n- Child Link: 550 → 700 units/frame (27% increase)\\n- Adult Link: 600 → 800 units/frame (33% increase)\\n\\n**Other speed combinations:**\\n- Both super fast: Adult 1000, Child 900\\n- Moderate increase: Adult 700, Child 650\\n- Equal speeds: Both 750 units/frame\\n\\nThis modification makes both child and adult Link faster, improving overall game pacing.\"}"}
{"instruction": "Make adult Link move slower by decreasing his movement speed", "output": "{\n  \"instruction\": \"Make adult Link move slower by decreasing his movement speed\",\n  \"input\": null,\n  \"output\": \"To make adult Link move slower, modify this file:\\n\\n**File: `oot/src/code/z_player_lib.c`**\\n- Line 39: Change `600,` to `400,` in the PLAYER_BOOTS_KOKIRI section\\n\\n**Complete code change:**\\n```c\\n// PLAYER_BOOTS_KOKIRI\\n{\\n    200,                         // REG(19)\\n    FRAMERATE_CONST(1000, 1200), // REG(30)\\n    FRAMERATE_CONST(300, 360),   // REG(32)\\n    700,                         // REG(34)\\n    FRAMERATE_CONST(550, 660),   // REG(35)\\n    FRAMERATE_CONST(270, 324),   // REG(36)\\n    800,                         // REG(37)\\n    FRAMERATE_CONST(350, 420),   // REG(38)\\n    800,                         // R_DECELERATE_RATE\\n    400,                         // R_RUN_SPEED_LIMIT (decreased from 600)\\n    -100,                        // REG(68)\\n    600,                         // REG(69)\\n    590,                         // IREG(66)\\n    750,                         // IREG(67)\\n    125,                         // IREG(68)\\n    200,                         // IREG(69)\\n    FRAMERATE_CONST(130, 156),   // MREG(95)\\n},\\n```\\n\\n**Explanation:**\\n- `R_RUN_SPEED_LIMIT` controls adult Link's maximum movement speed\\n- Original value: 600 units/frame\\n- Modified value: 400 units/frame (33% slower)\\n- This only affects adult Link, child Link remains at normal speed (550)\\n- The change creates a more deliberate, slower-paced adult Link\\n\\n**Rebuild Process:**\\n```bash\\nmake VERSION=ntsc-1.2 ENG=1 -j4\\n```\\n\\n**Speed comparison:**\\n- Child Link: 550 units/frame (unchanged)\\n- Adult Link: 600 → 400 units/frame (33% decrease)\\n\\n**Other slow speed values:**\\n- Very slow: 300 units/frame\\n- Extremely slow: 200 units/frame\\n- Slightly slower: 500 units/frame\\n\\nThis modification makes adult Link move more slowly, creating a different gameplay experience.\"}"}
