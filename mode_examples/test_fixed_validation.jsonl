{"instruction": "Create a ai behavior system", "output": "{\n  \"instruction\": \"Make a Ocarina playing and song system using advanced memory management\",\n  \"input\": null,\n  \"output\": \"```c\n// Authentic OoT ocarina system pattern\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 ocarinaNotes[8];\n    /* 0x015C */ s16 noteIndex;\n    /* 0x015E */ s16 songTimer;\n    /* 0x0160 */ s16 activeSong;\n    /* 0x0162 */ s16 songState;\n    /* 0x0164 */ f32 noteScale;\n    /* 0x0168 */ ColliderCylinder collider;\n} EnOcarinaMgr;\n\n// Song note patterns (authentic note values from OoT)\n#define NOTE_A (1 << 0)\n#define NOTE_C_DOWN (1 << 1) \n#define NOTE_C_RIGHT (1 << 2)\n#define NOTE_C_LEFT (1 << 3)\n#define NOTE_C_UP (1 << 4)\n\n// Song states\n#define SONG_STATE_IDLE 0\n#define SONG_STATE_PLAYING 1\n#define SONG_STATE_COMPLETE 2\n\nstatic const s16 sSongOfTime[] = {\n    NOTE_C_RIGHT, NOTE_A, NOTE_C_DOWN,\n    NOTE_C_RIGHT, NOTE_A, NOTE_C_DOWN,\n    -1\n};\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_NONE,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000000, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_NONE,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnOcarinaMgr_Init(Actor* thisx, PlayState* play) {\n    EnOcarinaMgr* this = (EnOcarinaMgr*)thisx;\n    \n    // Initialize collision using authentic pattern\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->noteIndex = 0;\n    this->songTimer = 0;\n    this->activeSong = -1;\n    this->songState = SONG_STATE_IDLE;\n    this->noteScale = 0.01f;\n    \n    Actor_SetScale(&this->actor, this->noteScale);\n}\n\nvoid EnOcarinaMgr_Destroy(Actor* thisx, PlayState* play) {\n    EnOcarinaMgr* this = (EnOcarinaMgr*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnOcarinaMgr_CheckSongMatch(EnOcarinaMgr* this) {\n    s16 i;\n    s16 matches = 0;\n    \n    // Check against Song of Time pattern\n    for (i = 0; i < this->noteIndex; i++) {\n        if (this->ocarinaNotes[i] == sSongOfTime[i]) {\n            matches++;\n        }\n    }\n    \n    if (matches == this->noteIndex && sSongOfTime[this->noteIndex] == -1) {\n        this->songState = SONG_STATE_COMPLETE;\n        this->activeSong = 1; // Song of Time ID\n    }\n}\n\nvoid EnOcarinaMgr_Update(Actor* thisx, PlayState* play) {\n    EnOcarinaMgr* this = (EnOcarinaMgr*)thisx;\n    \n    // Update collision using authentic pattern\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    switch(this->songState) {\n        case SONG_STATE_IDLE:\n            if (play->triggerButtons & BTN_A) {\n                this->ocarinaNotes[this->noteIndex++] = NOTE_A;\n                this->songState = SONG_STATE_PLAYING;\n                this->songTimer = 30;\n            }\n            // Add other note checks following same pattern\n            break;\n            \n        case SONG_STATE_PLAYING:\n            if (--this->songTimer <= 0) {\n                EnOcarinaMgr_CheckSongMatch(this);\n                if (this->songState != SONG_STATE_COMPLETE) {\n                    this->songState = SONG_STATE_IDLE;\n                    this->noteIndex = 0;\n                }\n            }\n            break;\n            \n        case SONG_STATE_COMPLETE:\n            this->noteScale += 0.001f;\n            Actor_SetScale(&this->actor, this->noteScale);\n            if (this->noteScale >= 0.02f) {\n                Actor_Kill(&this->actor);\n            }\n            break;\n    }\n}\n\nvoid EnOcarinaMgr_Draw(Actor* thisx, PlayState* play) {\n    EnOcarinaMgr* this = (EnOcarinaMgr*)thisx;\n    // Draw implementation\n}\n\nconst ActorProfile EnOcarinaMgr_Profile = {\n    /**/ ACTOR_EN_OCARINA_MGR,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnOcarinaMgr),\n    /**/ EnOcarinaMgr_Init,\n    /**/ EnOcarinaMgr_Destroy,\n    /**/ EnOcarinaMgr_Update,\n    /**/ EnOcarinaMgr_Draw,\n};\n```\"\n}"}
{"instruction": "Implement a collision caching system for repeated checks using standard approaches", "output": "// Authentic pattern following z_actor.c style\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ Vec3f lastCheckPos;  // Cache last checked position\n    /* 0x015C */ s16 lastGroundY;    // Cache last ground Y\n    /* 0x015E */ u16 checkTimer;     // Time between full checks\n    /* 0x0160 */ ColliderCylinder collider;\n} EnCollCache; // size = 0x1AC\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000008, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnCollCache_Init(Actor* thisx, PlayState* play) {\n    EnCollCache* this = (EnCollCache*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->lastCheckPos = this->actor.world.pos;\n    this->lastGroundY = this->actor.world.pos.y;\n    this->checkTimer = 0;\n    this->actionState = 0;\n}\n\nvoid EnCollCache_Update(Actor* thisx, PlayState* play) {\n    EnCollCache* this = (EnCollCache*)thisx;\n    f32 dx, dz;\n    \n    this->checkTimer++;\n    \n    // Only do full collision check if moved far enough or timer expired\n    dx = this->actor.world.pos.x - this->lastCheckPos.x;\n    dz = this->actor.world.pos.z - this->lastCheckPos.z;\n    \n    if ((SQ(dx) + SQ(dz)) > SQ(30.0f) || this->checkTimer >= 8) {\n        Actor_UpdateBgCheckInfo(play, &this->actor, 35.0f, 60.0f, 60.0f, \n            UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n            \n        this->lastCheckPos = this->actor.world.pos;\n        this->lastGroundY = this->actor.world.pos.y;\n        this->checkTimer = 0;\n    } else {\n        // Use cached ground height\n        this->actor.world.pos.y = this->lastGroundY;\n    }\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile EnCollCache_Profile = {\n    /**/ ACTOR_EN_COLLCACHE,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnCollCache),\n    /**/ EnCollCache_Init,\n    /**/ EnCollCache_Destroy,\n    /**/ EnCollCache_Update,\n    /**/ NULL\n};"}
