{"instruction": "Create a dynamic collision detection system for moving objects with straightforward logic", "output": "typedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 moveSpeed;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnMovingObj; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 25, 40, 0, { 0, 0, 0 } },\n};\n\nvoid EnMovingObj_Init(Actor* thisx, PlayState* play) {\n    EnMovingObj* this = (EnMovingObj*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    \n    // Initialize collision cylinder\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->timer = 0;\n    this->actionState = 0;\n    this->moveSpeed = 2.0f;\n    \n    // Set initial position and rotation\n    this->actor.world.pos.y = this->actor.home.pos.y;\n    this->actor.world.rot.y = 0;\n}\n\nvoid EnMovingObj_Destroy(Actor* thisx, PlayState* play) {\n    EnMovingObj* this = (EnMovingObj*)thisx;\n    \n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnMovingObj_Update(Actor* thisx, PlayState* play) {\n    EnMovingObj* this = (EnMovingObj*)thisx;\n    \n    // Update timer for movement pattern\n    this->timer++;\n    \n    // Simple back and forth movement\n    if (this->timer > 60) {\n        this->timer = 0;\n        this->moveSpeed *= -1.0f;\n    }\n    \n    // Apply movement\n    this->actor.world.pos.x += this->moveSpeed;\n    \n    // Update collision detection\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 20.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    \n    // Update collider position\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    \n    // Check for collisions with other actors\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile EnMovingObj_Profile = {\n    /**/ ACTOR_EN_MOVING_OBJ,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnMovingObj),\n    /**/ EnMovingObj_Init,\n    /**/ EnMovingObj_Destroy,\n    /**/ EnMovingObj_Update,\n    /**/ NULL\n};"}
{"instruction": "Create a puzzle system system", "output": "{\n  \"instruction\": \"I need a magical portal that can activates when multiple conditions are met with appropriate documentation\",\n  \"input\": null,\n  \"output\": \"/**\n * Magical Portal Actor\n * A portal that activates when multiple conditions are met:\n * - Player is within activation range\n * - Required switch flag is set\n * - Required item is obtained\n */\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 activationState;\n    /* 0x0150 */ f32 activeScale;\n    /* 0x0154 */ f32 alphaLevel;\n    /* 0x0158 */ s16 switchFlag;\n    /* 0x15A */ s16 requiredItem;\n    /* 0x15C */ f32 detectionRange;\n    /* 0x160 */ ColliderCylinder collider;\n} EnPortal; // size = 0x1AC\n\n// Portal initialization values\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_NONE,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000000, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_NONE,\n        OCELEM_ON,\n    },\n    { 30, 80, 0, { 0, 0, 0 } },\n};\n\nvoid EnPortal_Init(Actor* thisx, PlayState* play) {\n    EnPortal* this = (EnPortal*)thisx;\n    \n    // Initialize collision\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.flags |= ACTOR_FLAG_4;\n    this->activationState = 0;\n    this->activeScale = 0.0f;\n    this->alphaLevel = 0.0f;\n    this->detectionRange = 100.0f;\n    \n    // Get params from spawn data\n    this->switchFlag = (this->actor.params >> 8) & 0xFF;\n    this->requiredItem = this->actor.params & 0xFF;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnPortal_Destroy(Actor* thisx, PlayState* play) {\n    EnPortal* this = (EnPortal*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnPortal_Update(Actor* thisx, PlayState* play) {\n    EnPortal* this = (EnPortal*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    // Check activation conditions\n    s32 switchSet = Flags_GetSwitch(play, this->switchFlag);\n    s32 hasItem = INV_CONTENT(this->requiredItem) == ITEM_NONE ? 1 : \n                  (gSaveContext.inventory.items[INV_CONTENT(this->requiredItem)] == this->requiredItem);\n    \n    f32 playerDist = Math_Vec3f_DistXYZ(&player->actor.world.pos, &this->actor.world.pos);\n    \n    if (switchSet && hasItem && playerDist < this->detectionRange) {\n        this->activationState = 1;\n        Math_ApproachF(&this->activeScale, 1.0f, 0.1f, 0.05f);\n        Math_ApproachF(&this->alphaLevel, 255.0f, 1.0f, 5.0f);\n    } else {\n        this->activationState = 0;\n        Math_ApproachF(&this->activeScale, 0.0f, 0.1f, 0.05f);\n        Math_ApproachF(&this->alphaLevel, 0.0f, 1.0f, 5.0f);\n    }\n    \n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    this->timer++;\n}\n\nvoid EnPortal_Draw(Actor* thisx, PlayState* play) {\n    EnPortal* this = (EnPortal*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx, \\\"EnPortal_Draw\\\");\n    \n    Gfx_SetupDL_25Xlu(play->state.gfxCtx);\n    \n    gDPSetPrimColor(POLY_XLU_DISP++, 0, 0, 100, 100, 255, (u8)this->alphaLevel);\n    \n    Matrix_Push();\n    Matrix_Scale(this->activeScale, this->activeScale, this->activeScale, MTXMODE_APPLY);\n    // Draw portal effects here\n    Matrix_Pop();\n    \n    CLOSE_DISPS(play->state.gfxCtx, \\\"EnPortal_Draw\\\");\n}\n\nconst ActorProfile En_Portal_InitVars = {\n    /**/ ACTOR_EN_PORTAL,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnPortal),\n    /**/ EnPortal_Init,\n    /**/ EnPortal_Destroy,\n    /**/ EnPortal_Update,\n    /**/ EnPortal_Draw\n};\"\n}"}
{"instruction": "Create a interaction system system", "output": "{\n  \"instruction\": \"Make a crafting system for creating new items using established conventions\",\n  \"input\": null,\n  \"output\": \"// Crafting table actor that combines items to create new ones\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ s16 heldItems[3]; // Slots for up to 3 crafting ingredients\n    /* 0x0156 */ s16 numHeldItems;\n    /* 0x0158 */ f32 activeRadius;\n    /* 0x015C */ ColliderCylinder collider;\n} EnCraftTable; // size = 0x1A8\n\n// Crafting recipes using real item IDs from En_Item00\ntypedef struct {\n    s16 ingredients[3];\n    s16 numRequired;\n    s16 result;\n} CraftingRecipe;\n\nstatic const CraftingRecipe sCraftingRecipes[] = {\n    // Combine blue and red rupees to make purple\n    {{ITEM00_RUPEE_BLUE, ITEM00_RUPEE_RED, 0}, 2, ITEM00_RUPEE_PURPLE},\n    // Combine recovery hearts to make a heart piece\n    {{ITEM00_RECOVERY_HEART, ITEM00_RECOVERY_HEART, ITEM00_RECOVERY_HEART}, 3, ITEM00_HEART_PIECE},\n};\n\nvoid EnCraftTable_Init(Actor* thisx, PlayState* play) {\n    EnCraftTable* this = (EnCraftTable*)thisx;\n    \n    // Initialize collision using authentic pattern\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->activeRadius = 100.0f;\n    this->numHeldItems = 0;\n    this->actionState = 0;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnCraftTable_Update(Actor* thisx, PlayState* play) {\n    EnCraftTable* this = (EnCraftTable*)thisx;\n    \n    // Update collision using authentic pattern\n    Actor_UpdateBgCheckInfo(play, &this->actor, 35.0f, 60.0f, 60.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    // Check for nearby En_Item00 actors to collect\n    Actor* nearbyActor = play->actorCtx.actorLists[ACTORCAT_MISC].head;\n    while (nearbyActor != NULL) {\n        if (nearbyActor->id == ACTOR_EN_ITEM00) {\n            f32 dx = nearbyActor->world.pos.x - this->actor.world.pos.x;\n            f32 dz = nearbyActor->world.pos.z - this->actor.world.pos.z;\n            f32 distSq = SQ(dx) + SQ(dz);\n            \n            if (distSq < SQ(this->activeRadius) && this->numHeldItems < 3) {\n                EnItem00* item = (EnItem00*)nearbyActor;\n                this->heldItems[this->numHeldItems++] = item->collectibleFlag;\n                Actor_Kill(nearbyActor);\n                \n                // Check if we can craft something\n                for (s32 i = 0; i < ARRAY_COUNT(sCraftingRecipes); i++) {\n                    const CraftingRecipe* recipe = &sCraftingRecipes[i];\n                    if (this->numHeldItems == recipe->numRequired) {\n                        s32 matches = 0;\n                        for (s32 j = 0; j < recipe->numRequired; j++) {\n                            for (s32 k = 0; k < this->numHeldItems; k++) {\n                                if (this->heldItems[k] == recipe->ingredients[j]) {\n                                    matches++;\n                                    break;\n                                }\n                            }\n                        }\n                        \n                        if (matches == recipe->numRequired) {\n                            // Spawn crafted item using authentic En_Item00\n                            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                                      this->actor.world.pos.x, this->actor.world.pos.y + 40.0f,\n                                      this->actor.world.pos.z, 0, 0, 0, recipe->result);\n                            \n                            this->numHeldItems = 0;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        nearbyActor = nearbyActor->next;\n    }\n}\n\nconst ActorProfile EnCraftTable_Profile = {\n    /**/ ACTOR_EN_CRAFT_TABLE,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnCraftTable),\n    /**/ EnCraftTable_Init,\n    /**/ Actor_Destroy,\n    /**/ EnCraftTable_Update,\n    /**/ NULL,\n};\"\n}"}
{"instruction": "Create a sound system system", "output": "{\n  \"instruction\": \"Create a voice acting system for NPC dialogue with basic error checking\",\n  \"input\": null,\n  \"output\": \"// Voice acting system for NPC dialogue following OoT patterns\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 voiceTimer;\n    /* 0x014E */ s16 voiceState;\n    /* 0x0150 */ s16 currentVoiceLine;\n    /* 0x0152 */ s16 voiceDelay;\n    /* 0x0154 */ f32 voiceVolume;\n    /* 0x158 */ ColliderCylinder collider;\n} EnVoiceNpc;\n\nvoid EnVoiceNpc_Init(Actor* thisx, PlayState* play) {\n    EnVoiceNpc* this = (EnVoiceNpc*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->voiceTimer = 0;\n    this->voiceState = 0;\n    this->currentVoiceLine = 0;\n    this->voiceDelay = 20;\n    this->voiceVolume = 1.0f;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnVoiceNpc_Update(Actor* thisx, PlayState* play) {\n    EnVoiceNpc* this = (EnVoiceNpc*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Basic ground collision\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 20.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    \n    // Voice line playback state machine\n    switch(this->voiceState) {\n        case 0: // Idle\n            if (Actor_WorldDistXZToPoint(&player->actor, &this->actor.world.pos) < 100.0f) {\n                this->voiceState = 1;\n                this->voiceTimer = this->voiceDelay;\n            }\n            break;\n            \n        case 1: // Playing voice\n            if (this->voiceTimer > 0) {\n                this->voiceTimer--;\n            } else {\n                this->voiceState = 0;\n                this->currentVoiceLine++;\n                if (this->currentVoiceLine >= 3) {\n                    this->currentVoiceLine = 0;\n                }\n            }\n            break;\n    }\n}\n\nvoid EnVoiceNpc_Draw(Actor* thisx, PlayState* play) {\n    EnVoiceNpc* this = (EnVoiceNpc*)thisx;\n    \n    // Standard actor draw call\n    Actor_DrawOpa(play, &this->actor);\n}\n\nconst ActorProfile En_VoiceNpc_InitVars = {\n    /**/ ACTOR_EN_VOICE_NPC,\n    /**/ ACTORCAT_NPC,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnVoiceNpc),\n    /**/ EnVoiceNpc_Init,\n    /**/ EnVoiceNpc_Destroy,\n    /**/ EnVoiceNpc_Update,\n    /**/ EnVoiceNpc_Draw\n};\"\n}"}
{"instruction": "Create a animation system system", "output": "{\n  \"instruction\": \"Create a facial animation system for NPC expressions with reasonable performance\",\n  \"input\": null,\n  \"output\": \"// Authentic facial animation system following OoT patterns\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 eyeTextureIndex;  // Current eye texture\n    /* 0x014E */ s16 mouthTextureIndex; // Current mouth texture \n    /* 0x0150 */ s16 blinkTimer;\n    /* 0x0152 */ s16 expressionTimer;\n    /* 0x0154 */ s16 currentExpression;\n    /* 0x0156 */ s16 nextExpression;\n    /* 0x0158 */ f32 morphProgress;\n    /* 0x015C */ ColliderCylinder collider;\n} EnNpcFace; // size = 0x1A8\n\n// Expression states matching OoT NPC patterns\ntypedef enum {\n    /* 0x00 */ EXPRESSION_NEUTRAL,\n    /* 0x01 */ EXPRESSION_HAPPY,\n    /* 0x02 */ EXPRESSION_SAD,\n    /* 0x03 */ EXPRESSION_SURPRISED\n} ExpressionState;\n\n// Authentic initialization of facial animation system\nvoid EnNpcFace_Init(Actor* thisx, PlayState* play) {\n    EnNpcFace* this = (EnNpcFace*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    \n    // Initialize collision using authentic pattern\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->eyeTextureIndex = 0;\n    this->mouthTextureIndex = 0;\n    this->blinkTimer = (s16)(Rand_ZeroFloat(60.0f) + 20.0f);\n    this->expressionTimer = 0;\n    this->currentExpression = EXPRESSION_NEUTRAL;\n    this->nextExpression = EXPRESSION_NEUTRAL;\n    this->morphProgress = 0.0f;\n}\n\nvoid EnNpcFace_Update(Actor* thisx, PlayState* play) {\n    EnNpcFace* this = (EnNpcFace*)thisx;\n    \n    // Update blink timer using authentic timer pattern\n    this->blinkTimer--;\n    if (this->blinkTimer <= 0) {\n        this->eyeTextureIndex = (this->eyeTextureIndex + 1) % 3;\n        this->blinkTimer = (s16)(Rand_ZeroFloat(60.0f) + 20.0f);\n    }\n    \n    // Handle expression transitions\n    if (this->currentExpression != this->nextExpression) {\n        this->morphProgress += 0.1f;\n        if (this->morphProgress >= 1.0f) {\n            this->currentExpression = this->nextExpression;\n            this->morphProgress = 0.0f;\n        }\n    }\n    \n    // Update collision using authentic pattern\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnNpcFace_Draw(Actor* thisx, PlayState* play) {\n    EnNpcFace* this = (EnNpcFace*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    // Authentic matrix operations\n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_RotateY(BINANG_TO_RAD(this->actor.world.rot.y), MTXMODE_APPLY);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, this->actor.scale.z, MTXMODE_APPLY);\n    \n    // Draw base face mesh\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n    gSPDisplayList(POLY_OPA_DISP++, gNpcFaceDL);\n    \n    // Draw current expression textures\n    gDPPipeSync(POLY_OPA_DISP++);\n    gDPSetCombineMode(POLY_OPA_DISP++, G_CC_MODULATEIA_PRIM, G_CC_MODULATEIA_PRIM);\n    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 255, 255, 255, 255);\n    \n    // Draw eyes and mouth based on current indices\n    gSPDisplayList(POLY_OPA_DISP++, sEyeTextures[this->eyeTextureIndex]);\n    gSPDisplayList(POLY_OPA_DISP++, sMouthTextures[this->mouthTextureIndex]);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile EnNpcFace_Profile = {\n    /**/ ACTOR_EN_NPC_FACE,\n    /**/ ACTORCAT_NPC,\n    /**/ FLAGS,\n    /**/ OBJECT_NPC_FACE,\n    /**/ sizeof(EnNpcFace),\n    /**/ EnNpcFace_Init,\n    /**/ Actor_Destroy,\n    /**/ EnNpcFace_Update,\n    /**/ EnNpcFace_Draw\n};\"\n}"}
