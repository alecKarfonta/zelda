{"instruction": "Create a environmental system", "output": "{\n  \"instruction\": \"Implement a Ganon's Castle tower and barrier system with simple documentation\",\n  \"input\": null,\n  \"output\": \"/**\n * Ganon's Castle Barrier Actor\n * Handles the rainbow barrier around Ganon's Tower\n */\n\n#include \\\"z_en_gnd_barr.h\\\"\n\n#define FLAGS (ACTOR_FLAG_4 | ACTOR_FLAG_5)\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 barrierAlpha;\n    /* 0x014E */ s16 barrierPulse;\n    /* 0x0150 */ f32 barrierScale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnGndBarr; // size = 0x1A0\n\nvoid EnGndBarr_Init(Actor* thisx, PlayState* play) {\n    EnGndBarr* this = (EnGndBarr*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.1f);\n    this->barrierAlpha = 255;\n    this->barrierPulse = 0;\n    this->barrierScale = 1.0f;\n    \n    // Authentic collision setup\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->collider.dim.radius = 50;\n    this->collider.dim.height = 180;\n    this->collider.dim.yShift = 90;\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 0.0f, 0.0f, 0.0f, UPDBGCHECKINFO_FLAG_0);\n}\n\nvoid EnGndBarr_Destroy(Actor* thisx, PlayState* play) {\n    EnGndBarr* this = (EnGndBarr*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnGndBarr_Update(Actor* thisx, PlayState* play) {\n    EnGndBarr* this = (EnGndBarr*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->barrierPulse += 0x0180;\n    this->barrierScale = 1.0f + Math_SinS(this->barrierPulse) * 0.02f;\n    \n    // Check if all sages are awakened\n    if ((gSaveContext.eventChkInf[4] & 0xF) == 0xF) {\n        Actor_Kill(&this->actor);\n        return;\n    }\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnGndBarr_Draw(Actor* thisx, PlayState* play) {\n    EnGndBarr* this = (EnGndBarr*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Push();\n    Matrix_Scale(this->barrierScale, this->barrierScale, this->barrierScale, MTXMODE_APPLY);\n    \n    gDPSetPrimColor(POLY_XLU_DISP++, 0, 0, 255, 100, 100, this->barrierAlpha);\n    gDPSetEnvColor(POLY_XLU_DISP++, 255, 0, 0, 128);\n    \n    Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__);\n    \n    Matrix_Pop();\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Gnd_Barr_InitVars = {\n    /**/ ACTOR_EN_GND_BARR,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnGndBarr),\n    /**/ EnGndBarr_Init,\n    /**/ EnGndBarr_Destroy,\n    /**/ EnGndBarr_Update,\n    /**/ EnGndBarr_Draw\n};\"\n}"}
{"instruction": "Create a environmental system", "output": "{\n  \"instruction\": \"Create a Jabu-Jabu's Belly water and bubble mechanics using simple patterns\",\n  \"input\": null,\n  \"output\": \"\n```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 bubbleTimer;\n    /* 0x0150 */ f32 rippleScale;\n    /* 0x0154 */ Vec3f bubblePos;\n    /* 0x0160 */ ColliderCylinder collider;\n} EnJabuWater; // size = 0x1AC\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_NONE,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000000, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_NONE,\n        OCELEM_ON,\n    },\n    { 30, 45, 0, { 0, 0, 0 } },\n};\n\nvoid EnJabuWater_Init(Actor* thisx, PlayState* play) {\n    EnJabuWater* this = (EnJabuWater*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.1f);\n    this->rippleScale = 0.1f;\n    this->timer = 0;\n    this->bubbleTimer = (s16)(Rand_ZeroOne() * 20.0f) + 30;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.flags &= ~ACTOR_FLAG_0;\n    this->bubblePos = this->actor.world.pos;\n}\n\nvoid EnJabuWater_Destroy(Actor* thisx, PlayState* play) {\n    EnJabuWater* this = (EnJabuWater*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnJabuWater_Update(Actor* thisx, PlayState* play) {\n    EnJabuWater* this = (EnJabuWater*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    // Ripple effect\n    this->rippleScale = 0.1f + (Math_SinS(this->timer * 0x800) * 0.02f);\n    \n    // Bubble spawning logic\n    this->bubbleTimer--;\n    if (this->bubbleTimer <= 0) {\n        this->bubbleTimer = (s16)(Rand_ZeroOne() * 20.0f) + 30;\n        this->bubblePos.x = this->actor.world.pos.x + (Rand_CenteredFloat(40.0f));\n        this->bubblePos.z = this->actor.world.pos.z + (Rand_CenteredFloat(40.0f));\n        \n        Actor_Spawn(&play->actorCtx, play, ACTOR_EN_EFF_DUST, \n            this->bubblePos.x, this->bubblePos.y, this->bubblePos.z,\n            0, (s16)(Rand_ZeroOne() * 0x4000), 0, 1);\n    }\n    \n    // Water surface collision\n    if (sqrtf(SQ(dx) + SQ(dz))(&player->actor.world.pos, &this->actor.world.pos) < 100.0f) {\n        if (player->actor.world.pos.y <= this->actor.world.pos.y) {\n            player->actor.velocity.y = 2.0f;\n        }\n    }\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnJabuWater_Draw(Actor* thisx, PlayState* play) {\n    EnJabuWater* this = (EnJabuWater*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Push();\n    Matrix_Scale(this->rippleScale, 1.0f, this->rippleScale, MTXMODE_APPLY);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n    gSPDisplayList(POLY_OPA_DISP++, gEffWaterRippleDL);\n    Matrix_Pop();\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_JabuWater_InitVars = {\n    /**/ ACTOR_EN_JABU_WATER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnJabuWater),\n    /**/ EnJabuWater_Init,\n    /**/ EnJabuWater_Destroy,\n    /**/ EnJabuWater_Update,\n    /**/ EnJabuWater_Draw\n};\n```\n\"}"}
{"instruction": "Implement a complex feature implementation system for enhanced gameplay implementing standard patterns", "output": "// Implements a crystal switch that toggles platforms\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 switchTimer;\n    /* 0x014E */ s16 switchState;\n    /* 0x0150 */ f32 crystalScale;\n    /* 0x0154 */ ColliderCylinder collider;\n    /* 0x01A0 */ Vec3f effectPos;\n} EnCrystalSwitch; // size = 0x1AC\n\nvoid EnCrystalSwitch_Init(Actor* thisx, PlayState* play) {\n    EnCrystalSwitch* this = (EnCrystalSwitch*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.1f);\n    this->crystalScale = 1.0f;\n    this->switchState = 0;\n    this->switchTimer = 0;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor,\n        &sCylinderInit);\n    \n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\n    Actor_SetFocus(&this->actor, 20.0f);\n}\n\nvoid EnCrystalSwitch_Update(Actor* thisx, PlayState* play) {\n    EnCrystalSwitch* this = (EnCrystalSwitch*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    if (this->switchTimer > 0) {\n        this->switchTimer--;\n    }\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        this->collider.base.acFlags &= ~AC_HIT;\n        \n        if (this->switchTimer == 0) {\n            this->switchState ^= 1;\n            this->switchTimer = 20;\n            \n            // Spawn sparkle effect\n            this->effectPos.x = this->actor.world.pos.x;\n            this->effectPos.y = this->actor.world.pos.y + 25.0f;\n            this->effectPos.z = this->actor.world.pos.z;\n            \n            Actor_PlaySfx(&this->actor, NA_SE_SY_CORRECT_CHIME);\n        }\n    }\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnCrystalSwitch_Draw(Actor* thisx, PlayState* play) {\n    EnCrystalSwitch* this = (EnCrystalSwitch*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Push();\n    Matrix_Scale(this->crystalScale, this->crystalScale, this->crystalScale, MTXMODE_APPLY);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n        G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n    gSPDisplayList(POLY_OPA_DISP++, gCrystalSwitchDL);\n    Matrix_Pop();\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Crystal_Switch_InitVars = {\n    /**/ ACTOR_EN_CRYSTAL_SWITCH,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnCrystalSwitch),\n    /**/ EnCrystalSwitch_Init,\n    /**/ EnCrystalSwitch_Destroy,\n    /**/ EnCrystalSwitch_Update, \n    /**/ EnCrystalSwitch_Draw\n};"}
