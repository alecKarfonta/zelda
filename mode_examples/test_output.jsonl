{"instruction": "Create a actor creation system", "output": "{\n  \"instruction\": \"I want to implement a crystal shield that grants telepathic communication with NPCs using resource management implementing common features\",\n  \"input\": null,\n  \"output\": \"```c\n// EnCrystalShield actor implementation following OoT patterns\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ ColliderCylinder collider;\n    /* 0x0198 */ s16 actionState;\n    /* 0x019A */ s16 timer;\n    /* 0x019C */ f32 floatHeight;\n    /* 0x01A0 */ f32 floatVelocity;\n    /* 0x01A4 */ s16 rotationAngle;\n} EnCrystalShield; // size = 0x01A8\n\nvoid EnCrystalShield_Init(Actor* thisx, PlayState* play) {\n    EnCrystalShield* this = (EnCrystalShield*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    \n    // Initialize collision\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor,\n        &(ColliderCylinderInit){\n            .base = { .colType = COLTYPE_NONE,\n                     .at = COLTYPE_HIT0,\n                     .ac = COLTYPE_NONE,\n                     .oc = COLTYPE_NONE },\n            .dim = { .radius = 20, .height = 50, .yShift = 0 },\n            .info = { .bumperFlags = BUMP_NONE,\n                     .toucherFlags = TOUCH_NONE,\n                     .bumped = BUMP_NONE,\n                     .touched = TOUCH_ON | TOUCH_SFX_NORMAL }});\n\n    this->actionState = 0;\n    this->timer = 0;\n    this->floatHeight = this->actor.world.pos.y;\n    this->floatVelocity = 0.0f;\n    this->rotationAngle = 0;\n}\n\nvoid EnCrystalShield_Destroy(Actor* thisx, PlayState* play) {\n    EnCrystalShield* this = (EnCrystalShield*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnCrystalShield_Update(Actor* thisx, PlayState* play) {\n    EnCrystalShield* this = (EnCrystalShield*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    this->rotationAngle += 0x200;\n    \n    // Floating motion\n    this->floatVelocity += Math_SinS(this->timer * 0x800) * 0.13f;\n    this->actor.world.pos.y = this->floatHeight + this->floatVelocity;\n    \n    // Check if player is nearby and press A\n    if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 100.0f) {\n        if (func_8002F1C4(&this->actor, play, 100.0f, 100.0f, 0)) {\n            // Give crystal shield to player\n            gSaveContext.inventory.items[SLOT_SHIELD] = ITEM_SHIELD_3;\n            gSaveContext.equips.buttonItems[1] = ITEM_SHIELD_3;\n            Actor_Kill(&this->actor);\n            \n            // Play sound and spawn collection effect\n            Audio_PlayActorSound2(&this->actor, NA_SE_IT_GET_SHIELD);\n            Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00, \n                       this->actor.world.pos.x, this->actor.world.pos.y, \n                       this->actor.world.pos.z, 0, 0, 0, 0);\n        }\n    }\n\n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnCrystalShield_Draw(Actor* thisx, PlayState* play) {\n    EnCrystalShield* this = (EnCrystalShield*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Push();\n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, \n                    this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_RotateY(BINANG_TO_RAD(this->rotationAngle), MTXMODE_APPLY);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, \n                this->actor.scale.z, MTXMODE_APPLY);\n                \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_MODELVIEW | G_MTX_LOAD);\n    gSPDisplayList(POLY_OPA_DISP++, gCrystalShieldDL);\n    \n    Matrix_Pop();\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_CrystalShield_InitVars = {\n    /**/ ACTOR_EN_CRYSTAL_SHIELD,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_SHIELD,\n    /**/ sizeof(EnCrystalShield),\n    /**/ EnCrystalShield_Init,\n    /**/ EnCrystalShield_Destroy,\n    /**/ EnCrystalShield_Update,\n    /**/ EnCrystalShield_Draw\n};\n```\"\n}"}
{"instruction": "Create a sound filtering system for different environments using memory-safe practices", "output": "// Authentic pattern from OoT decompilation style\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 soundRadius;\n    /* 0x014E */ s16 filterState;\n    /* 0x0150 */ f32 filterAmount;\n    /* 0x0154 */ Vec3f lastPos;\n    /* 0x0160 */ ColliderCylinder collider;\n} EnSoundFilter; // size = 0x1AC\n\ntypedef enum {\n    /* 0 */ FILTER_STATE_INACTIVE,\n    /* 1 */ FILTER_STATE_CAVE,\n    /* 2 */ FILTER_STATE_UNDERWATER,\n    /* 3 */ FILTER_STATE_MUFFLED\n} FilterState;\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_NONE,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000000, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_NONE,\n        OCELEM_ON,\n    },\n    { 100, 150, 0, { 0, 0, 0 } },\n};\n\nvoid EnSoundFilter_Init(Actor* thisx, PlayState* play) {\n    EnSoundFilter* this = (EnSoundFilter*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.1f);\n    \n    this->soundRadius = 100;\n    this->filterState = FILTER_STATE_INACTIVE;\n    this->filterAmount = 0.0f;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.flags &= ~ACTOR_FLAG_0;\n}\n\nvoid EnSoundFilter_Destroy(Actor* thisx, PlayState* play) {\n    EnSoundFilter* this = (EnSoundFilter*)thisx;\n    \n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnSoundFilter_Update(Actor* thisx, PlayState* play) {\n    EnSoundFilter* this = (EnSoundFilter*)thisx;\n    Player* player = GET_PLAYER(play);\n    f32 dist;\n    \n    dist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    if (dist < this->soundRadius) {\n        // Check if player is in range\n        if (this->filterState == FILTER_STATE_INACTIVE) {\n            this->filterState = FILTER_STATE_CAVE;\n            Audio_SetExtraFilter(40);\n        }\n        \n        // Smoothly adjust filter based on distance\n        Math_SmoothStepToF(&this->filterAmount, 1.0f, 0.1f, 0.3f, 0.01f);\n        \n    } else if (this->filterState != FILTER_STATE_INACTIVE) {\n        Math_SmoothStepToF(&this->filterAmount, 0.0f, 0.1f, 0.3f, 0.01f);\n        \n        if (this->filterAmount < 0.01f) {\n            this->filterState = FILTER_STATE_INACTIVE;\n            Audio_SetExtraFilter(0);\n        }\n    }\n    \n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnSoundFilter_Draw(Actor* thisx, PlayState* play) {\n    // No visual representation needed\n}\n\nconst ActorProfile EnSoundFilter_Profile = {\n    /**/ ACTOR_EN_SOUNDFILTER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnSoundFilter),\n    /**/ EnSoundFilter_Init,\n    /**/ EnSoundFilter_Destroy, \n    /**/ EnSoundFilter_Update,\n    /**/ EnSoundFilter_Draw\n};"}
{"instruction": "Create a environmental system", "output": "{\n  \"instruction\": \"Implement a Deku Tree web and platform system implementing essential features\",\n  \"input\": null,\n  \"output\": \"```c\n// Web platform actor for Deku Tree\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ ColliderCylinder collider;\n    /* 0x0198 */ s16 oscillation;\n    /* 0x019A */ s16 swayTimer;\n    /* 0x019C */ f32 initY;\n    /* 0x01A0 */ f32 webAlpha;\n} EnDekuWeb; // size = 0x01A4\n\nvoid EnDekuWeb_Init(Actor* thisx, PlayState* play) {\n    EnDekuWeb* this = (EnDekuWeb*)thisx;\n    \n    this->initY = this->actor.world.pos.y;\n    this->oscillation = 0;\n    this->swayTimer = 0;\n    this->webAlpha = 255.0f;\n    \n    // Setup collision for platform\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->collider.dim.height = 10;\n    this->collider.dim.radius = 45;\n    \n    Actor_SetScale(&this->actor, 0.1f);\n}\n\nvoid EnDekuWeb_Destroy(Actor* thisx, PlayState* play) {\n    EnDekuWeb* this = (EnDekuWeb*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnDekuWeb_Update(Actor* thisx, PlayState* play) {\n    EnDekuWeb* this = (EnDekuWeb*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->swayTimer += 0x0400;\n    this->oscillation = Math_SinS(this->swayTimer) * 1000.0f;\n    \n    // Web platform sway motion\n    this->actor.world.pos.y = this->initY + (Math_SinS(this->oscillation) * 5.0f);\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Player interaction\n    if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 50.0f) {\n        if (this->webAlpha > 128.0f) {\n            Math_SmoothStepToF(&this->webAlpha, 128.0f, 0.3f, 10.0f, 0.1f);\n        }\n    } else {\n        if (this->webAlpha < 255.0f) {\n            Math_SmoothStepToF(&this->webAlpha, 255.0f, 0.3f, 10.0f, 0.1f);\n        }\n    }\n}\n\nvoid EnDekuWeb_Draw(Actor* thisx, PlayState* play) {\n    EnDekuWeb* this = (EnDekuWeb*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 255, 255, 255, (u8)this->webAlpha);\n    \n    Matrix_Push();\n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, this->actor.scale.z, MTXMODE_APPLY);\n    Matrix_RotateY(this->actor.world.rot.y * (M_PI / 32768.0f), MTXMODE_APPLY);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__), \n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n    gSPDisplayList(POLY_OPA_DISP++, gDekuWebPlatformDL);\n    \n    Matrix_Pop();\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_DekuWeb_InitVars = {\n    /**/ ACTOR_EN_DEKU_WEB,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_DEKU_WEB,\n    /**/ sizeof(EnDekuWeb),\n    /**/ EnDekuWeb_Init,\n    /**/ EnDekuWeb_Destroy,\n    /**/ EnDekuWeb_Update,\n    /**/ EnDekuWeb_Draw\n};\n```\"\n}"}
{"instruction": "Create a Song of Healing effect that cures curses with basic debugging support", "output": "// Effect actor for curse healing visual effect\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 alpha;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ Vec3f effectPos[8];\n    /* 0x01B4 */ Color_RGBA8 effectColor;\n} EffHeal; // size = 0x1B8\n\nvoid EffHeal_Init(Actor* thisx, PlayState* play) {\n    EffHeal* this = (EffHeal*)thisx;\n    s32 i;\n\n    Actor_SetScale(&this->actor, 0.0f);\n    this->timer = 40;\n    this->alpha = 255;\n    this->scale = 0.0f;\n    \n    // Initialize effect positions in a circle\n    for (i = 0; i < 8; i++) {\n        this->effectPos[i].x = Math_SinS(i * 0x2000) * 30.0f;\n        this->effectPos[i].y = 40.0f;\n        this->effectPos[i].z = Math_CosS(i * 0x2000) * 30.0f;\n    }\n\n    this->effectColor.r = 100;\n    this->effectColor.g = 200; \n    this->effectColor.b = 255;\n    this->effectColor.a = 255;\n\n    // Debug print if enabled\n    #ifdef ENABLE_DEBUG\n    osSyncPrintf(VT_FGCOL(GREEN) \"Healing Effect Created\\n\" VT_RST);\n    #endif\n}\n\nvoid EffHeal_Destroy(Actor* thisx, PlayState* play) {\n    #ifdef ENABLE_DEBUG\n    osSyncPrintf(VT_FGCOL(GREEN) \"Healing Effect Destroyed\\n\" VT_RST);\n    #endif\n}\n\nvoid EffHeal_Update(Actor* thisx, PlayState* play) {\n    EffHeal* this = (EffHeal*)thisx;\n    s32 i;\n\n    if (this->timer > 0) {\n        this->timer--;\n        \n        // Smooth scale up\n        Math_SmoothStepToF(&this->scale, 0.01f, 0.2f, 0.001f, 0.0001f);\n\n        // Rotate and move effect points\n        for (i = 0; i < 8; i++) {\n            this->effectPos[i].y += 1.0f;\n            this->effectPos[i].x *= 0.98f;\n            this->effectPos[i].z *= 0.98f;\n        }\n    } else {\n        // Fade out\n        this->alpha -= 6;\n        if (this->alpha <= 0) {\n            Actor_Kill(&this->actor);\n            return;\n        }\n    }\n}\n\nvoid EffHeal_Draw(Actor* thisx, PlayState* play) {\n    EffHeal* this = (EffHeal*)thisx;\n    s32 i;\n    Vec3f pos;\n\n    OPEN_DISPS(play->state.gfxCtx);\n    \n    // Setup for effect drawing\n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gDPSetPrimColor(POLY_XLU_DISP++, 0, 0, \n        this->effectColor.r,\n        this->effectColor.g, \n        this->effectColor.b,\n        this->alpha);\n\n    // Draw healing particles\n    for (i = 0; i < 8; i++) {\n        pos.x = this->actor.world.pos.x + this->effectPos[i].x;\n        pos.y = this->actor.world.pos.y + this->effectPos[i].y;\n        pos.z = this->actor.world.pos.z + this->effectPos[i].z;\n\n        Matrix_Translate(pos.x, pos.y, pos.z, MTXMODE_NEW);\n        Matrix_Scale(this->scale, this->scale, this->scale, MTXMODE_APPLY);\n        Matrix_ReplaceRotation(&play->billboardMtxF);\n\n        gSPMatrix(POLY_XLU_DISP++, \n            Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n            G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n\n        gSPDisplayList(POLY_XLU_DISP++, gEffSparklesDL);\n    }\n\n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile Eff_Heal_InitVars = {\n    /**/ ACTOR_EFF_HEAL,\n    /**/ ACTORCAT_MISC,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EffHeal),\n    /**/ EffHeal_Init,\n    /**/ EffHeal_Destroy,\n    /**/ EffHeal_Update,\n    /**/ EffHeal_Draw,\n};"}
{"instruction": "Implement optimization functionality using authentic code with appropriate documentation", "output": "/**\n * Actor that optimizes performance by disabling rendering and updates for distant objects\n * Based on authentic OoT patterns for actor optimization\n */\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ f32 activationRange;\n    /* 0x0150 */ s16 cullTimer;\n    /* 0x0152 */ s16 actionState;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnOptimizer; // size = 0x1A0\n\nvoid EnOptimizer_Init(Actor* thisx, PlayState* play) {\n    EnOptimizer* this = (EnOptimizer*)thisx;\n    Player* player = GET_PLAYER(play);\n\n    Actor_SetScale(&this->actor, 0.01f);\n    this->activationRange = 2000.0f;\n    this->cullTimer = 0;\n    this->actionState = 0;\n\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n}\n\nvoid EnOptimizer_Update(Actor* thisx, PlayState* play) {\n    EnOptimizer* this = (EnOptimizer*)thisx;\n    Player* player = GET_PLAYER(play);\n    f32 distanceFromPlayer;\n\n    distanceFromPlayer = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n\n    if (distanceFromPlayer > this->activationRange) {\n        if (this->cullTimer < 20) {\n            this->cullTimer++;\n        } else {\n            this->actor.flags &= ~ACTOR_FLAG_0;\n            return;\n        }\n    } else {\n        this->cullTimer = 0;\n        this->actor.flags |= ACTOR_FLAG_0;\n        \n        Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 0.0f, UPDBGCHECKINFO_FLAG_0);\n        Collider_UpdateCylinder(&this->actor, &this->collider);\n        CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    }\n}\n\nvoid EnOptimizer_Draw(Actor* thisx, PlayState* play) {\n    EnOptimizer* this = (EnOptimizer*)thisx;\n    \n    if (this->cullTimer < 20) {\n        OPEN_DISPS(play->state.gfxCtx);\n        \n        Gfx_SetupDL_25Opa(play->state.gfxCtx);\n        gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n                  G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n        \n        CLOSE_DISPS(play->state.gfxCtx);\n    }\n}\n\nconst ActorProfile En_Optimizer_InitVars = {\n    /**/ ACTOR_EN_OPTIMIZER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnOptimizer),\n    /**/ EnOptimizer_Init,\n    /**/ EnOptimizer_Destroy,\n    /**/ EnOptimizer_Update, \n    /**/ EnOptimizer_Draw\n};"}
