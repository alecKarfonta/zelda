{"instruction": "Create a custom mechanics system", "output": "{\n  \"instruction\": \"Implement a Horse riding and Epona mechanics with multiple states and transitions\",\n  \"input\": null,\n  \"output\": \"// en_horse.h\n#ifndef Z_EN_HORSE_H\n#define Z_EN_HORSE_H\n\ntypedef enum {\n    /* 0 */ HORSE_STATE_IDLE,\n    /* 1 */ HORSE_STATE_WALK,\n    /* 2 */ HORSE_STATE_TROT,\n    /* 3 */ HORSE_STATE_GALLOP,\n    /* 4 */ HORSE_STATE_REARING,\n    /* 5 */ HORSE_STATE_STOPPING\n} HorseState;\n\n#endif\n\n// en_horse.c\n#include \\\"z_en_horse.h\\\"\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ Vec3s jointTable[20];\n    /* 0x01F0 */ Vec3s morphTable[20];\n    /* 0x0250 */ s16 timer;\n    /* 0x0252 */ s16 actionState;\n    /* 0x0254 */ f32 currentSpeed;\n    /* 0x0258 */ f32 targetSpeed;\n    /* 0x025C */ s16 riderPos;\n    /* 0x025E */ s16 stickAngle;\n    /* 0x0260 */ ColliderCylinder collider;\n    /* 0x02AC */ ColliderJntSph bodyCollider;\n    /* 0x02CC */ ColliderJntSphElement bodyElements[1];\n} EnHorse; // size = 0x030C\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 30, 100, 0, { 0, 0, 0 } },\n};\n\nvoid EnHorse_Init(Actor* thisx, PlayState* play) {\n    EnHorse* this = (EnHorse*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    \n    SkelAnime_InitFlex(play, &this->skelAnime, &gEponaSkel, &gEponaIdleAnim, \n                       this->jointTable, this->morphTable, 20);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actionState = HORSE_STATE_IDLE;\n    this->currentSpeed = 0.0f;\n    this->targetSpeed = 0.0f;\n}\n\nvoid EnHorse_Update(Actor* thisx, PlayState* play) {\n    EnHorse* this = (EnHorse*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 45.0f, 45.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    \n    // Speed control\n    Math_SmoothStepToF(&this->currentSpeed, this->targetSpeed, 0.3f, 2.0f, 0.1f);\n    \n    // Basic movement\n    this->actor.world.rot.y = this->actor.shape.rot.y;\n    this->actor.speedXZ = this->currentSpeed;\n    Actor_MoveXZGravity(&this->actor);\n    \n    // Collision updates\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // State machine\n    switch (this->actionState) {\n        case HORSE_STATE_IDLE:\n            SkelAnime_Update(&this->skelAnime);\n            if (this->currentSpeed > 0.1f) {\n                this->actionState = HORSE_STATE_WALK;\n            }\n            break;\n            \n        case HORSE_STATE_WALK:\n            SkelAnime_Update(&this->skelAnime);\n            if (this->currentSpeed > 4.0f) {\n                this->actionState = HORSE_STATE_TROT;\n            }\n            break;\n            \n        case HORSE_STATE_TROT:\n            SkelAnime_Update(&this->skelAnime);\n            if (this->currentSpeed > 8.0f) {\n                this->actionState = HORSE_STATE_GALLOP;\n            }\n            break;\n            \n        case HORSE_STATE_GALLOP:\n            SkelAnime_Update(&this->skelAnime);\n            break;\n    }\n}\n\nvoid EnHorse_Draw(Actor* thisx, PlayState* play) {\n    EnHorse* this = (EnHorse*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                          this->skelAnime.dListCount, NULL, NULL, this);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Horse_InitVars = {\n    /**/ ACTOR_EN_HORSE,\n    /**/ ACTORCAT_NPC,\n    /**/ FLAGS_0,\n    /**/ OBJECT_HORSE,\n    /**/ sizeof(EnHorse),\n    /**/ EnHorse_Init,\n    /**/ EnHorse_Destroy,\n    /**/ EnHorse_Update,\n    /**/ EnHorse_Draw\n};\n\"\n}"}
{"instruction": "Create a interaction system system", "output": "{\n  \"instruction\": \"Implement a reputation system that affects available options with appropriate documentation\",\n  \"input\": null,\n  \"output\": \"/**\n * EnReputation tracks player reputation and affects NPC interactions\n * Uses gSaveContext.eventChkInf[] bits to persist reputation state\n */\n\n#include \\\"z_en_reputation.h\\\"\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 reputationValue;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 interactRange;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnReputation;\n\n// Reputation thresholds stored in eventChkInf[7]\n#define REPUTATION_FRIENDLY 0x2000\n#define REPUTATION_NEUTRAL 0x1000 \n#define REPUTATION_HOSTILE 0x0800\n\nvoid EnReputation_Init(Actor* thisx, PlayState* play) {\n    EnReputation* this = (EnReputation*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->interactRange = 100.0f;\n    \n    // Load reputation from save context\n    if (gSaveContext.eventChkInf[7] & REPUTATION_FRIENDLY) {\n        this->reputationValue = 100;\n    } else if (gSaveContext.eventChkInf[7] & REPUTATION_NEUTRAL) {\n        this->reputationValue = 50; \n    } else if (gSaveContext.eventChkInf[7] & REPUTATION_HOSTILE) {\n        this->reputationValue = 0;\n    } else {\n        this->reputationValue = 50;\n    }\n}\n\nvoid EnReputation_Update(Actor* thisx, PlayState* play) {\n    EnReputation* this = (EnReputation*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Check player distance\n    f32 playerDist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    if (playerDist < this->interactRange) {\n        // Update reputation based on player actions\n        if (this->reputationValue > 75) {\n            gSaveContext.eventChkInf[7] |= REPUTATION_FRIENDLY;\n            gSaveContext.eventChkInf[7] &= ~REPUTATION_NEUTRAL;\n            gSaveContext.eventChkInf[7] &= ~REPUTATION_HOSTILE;\n        } else if (this->reputationValue < 25) {\n            gSaveContext.eventChkInf[7] |= REPUTATION_HOSTILE;\n            gSaveContext.eventChkInf[7] &= ~REPUTATION_NEUTRAL;\n            gSaveContext.eventChkInf[7] &= ~REPUTATION_FRIENDLY;\n        } else {\n            gSaveContext.eventChkInf[7] |= REPUTATION_NEUTRAL;\n            gSaveContext.eventChkInf[7] &= ~REPUTATION_FRIENDLY;\n            gSaveContext.eventChkInf[7] &= ~REPUTATION_HOSTILE;\n        }\n    }\n}\n\nvoid EnReputation_Draw(Actor* thisx, PlayState* play) {\n    EnReputation* this = (EnReputation*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n              \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Reputation_InitVars = {\n    /**/ ACTOR_EN_REPUTATION,\n    /**/ ACTORCAT_NPC,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnReputation),\n    /**/ EnReputation_Init,\n    /**/ Actor_Destroy,\n    /**/ EnReputation_Update,\n    /**/ EnReputation_Draw\n};\"\n}"}
{"instruction": "Create a custom mechanics system", "output": "{\n  \"instruction\": \"Create a Fishing system with different fish types with complex mathematical calculations\",\n  \"input\": null,\n  \"output\": \"```c\n// Size: 0x0C\ntypedef struct {\n    /* 0x00 */ f32 weight;\n    /* 0x04 */ f32 length;\n    /* 0x08 */ u16 variant;\n    /* 0x0A */ u16 flags;\n} FishParams;\n\n// Size: 0x1A0\ntypedef struct {\n    /* 0x000 */ Actor actor;\n    /* 0x14C */ s16 timer;\n    /* 0x14E */ s16 actionState;\n    /* 0x150 */ f32 fishingSpeed;\n    /* 0x154 */ f32 waterSurfaceY;\n    /* 0x158 */ f32 lureDistance;\n    /* 0x15C */ f32 fishMouthOffset;\n    /* 0x160 */ Vec3f lurePos;\n    /* 0x16C */ Vec3f fishTargetPos;\n    /* 0x178 */ FishParams params;\n    /* 0x184 */ f32 resistanceForce;\n    /* 0x188 */ f32 swimAngle;\n    /* 0x18C */ f32 yawVelocity;\n    /* 0x190 */ ColliderCylinder collider;\n} EnFish; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnFish_Init(Actor* thisx, PlayState* play) {\n    EnFish* this = (EnFish*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->params.weight = 2.0f + (Rand_ZeroOne() * 8.0f);\n    this->params.length = 30.0f + (Rand_ZeroOne() * 40.0f);\n    this->params.variant = Rand_S16Offset(0, 3);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actionState = 0;\n    this->swimAngle = 0.0f;\n    this->fishingSpeed = 0.0f;\n}\n\nvoid EnFish_UpdateSwimBehavior(EnFish* this, PlayState* play) {\n    Player* player = GET_PLAYER(play);\n    f32 distanceToPlayer = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    // Complex swimming calculations\n    f32 targetSpeed = Math_SinS(this->timer * 0x200) * 2.0f;\n    Math_SmoothStepToF(&this->fishingSpeed, targetSpeed, 0.3f, 1.0f, 0.1f);\n    \n    // Calculate resistance based on weight and speed\n    this->resistanceForce = (this->params.weight * 0.5f) * \n                           (this->fishingSpeed * this->fishingSpeed) * 0.01f;\n    \n    // Update yaw for natural swimming motion\n    f32 yawStep = Math_SinS(this->timer * 0x400) * 500.0f;\n    Math_SmoothStepToF(&this->yawVelocity, yawStep, 0.3f, 100.0f, 0.1f);\n    this->actor.world.rot.y += this->yawVelocity;\n    \n    // Update position based on current angle and speed\n    this->actor.world.pos.x += Math_SinS(this->actor.world.rot.y) * this->fishingSpeed;\n    this->actor.world.pos.z += Math_CosS(this->actor.world.rot.y) * this->fishingSpeed;\n    \n    // Vertical bobbing\n    this->actor.world.pos.y = this->waterSurfaceY - 20.0f + \n                             (Math_SinS(this->timer * 0x800) * 5.0f);\n}\n\nvoid EnFish_Update(Actor* thisx, PlayState* play) {\n    EnFish* this = (EnFish*)thisx;\n    \n    this->timer++;\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 20.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n                           \n    switch (this->actionState) {\n        case 0: // Swimming freely\n            EnFish_UpdateSwimBehavior(this, play);\n            break;\n    }\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile EnFish_Profile = {\n    /**/ ACTOR_EN_FISH,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnFish),\n    /**/ EnFish_Init,\n    /**/ Actor_Destroy,\n    /**/ EnFish_Update,\n    /**/ NULL\n};\n```\"\n}"}
{"instruction": "Create a actor creation system", "output": "{\n  \"instruction\": \"Build a innkeeper character that shares local legends and lore when approached for a trading post with basic debugging support\",\n  \"input\": null,\n  \"output\": \"```c\n// En_Innkeeper.c\n#include \\\"z_en_innkeeper.h\\\"\n#include \\\"assets/objects/object_innkeeper/object_innkeeper.h\\\"\n\n#define FLAGS (ACTOR_FLAG_0 | ACTOR_FLAG_3)\n\ntypedef enum {\n    /* 0 */ INNKEEPER_IDLE,\n    /* 1 */ INNKEEPER_TALKING,\n    /* 2 */ INNKEEPER_WAIT\n} InnkeeperState;\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ ColliderCylinder collider;\n    /* 0x01DC */ s16 actionState;\n    /* 0x01DE */ s16 talkTimer;\n    /* 0x01E0 */ Vec3s jointTable[20];\n    /* 0x0230 */ Vec3s morphTable[20];\n} EnInnkeeper; // size = 0x0280\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_NONE,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000000, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_NONE,\n        OCELEM_ON,\n    },\n    { 20, 60, 0, { 0, 0, 0 } },\n};\n\nvoid EnInnkeeper_Init(Actor* thisx, PlayState* play) {\n    EnInnkeeper* this = (EnInnkeeper*)thisx;\n    \n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 36.0f);\n    SkelAnime_InitFlex(play, &this->skelAnime, &gInnkeeperSkel, &gInnkeeperIdleAnim, \n                       this->jointTable, this->morphTable, 20);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.targetMode = 6;\n    Actor_SetScale(&this->actor, 0.01f);\n    \n    this->actionState = INNKEEPER_IDLE;\n    this->talkTimer = 0;\n}\n\nvoid EnInnkeeper_Destroy(Actor* thisx, PlayState* play) {\n    EnInnkeeper* this = (EnInnkeeper*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnInnkeeper_Talk(EnInnkeeper* this, PlayState* play) {\n    Player* player = GET_PLAYER(play);\n    \n    if (Actor_ProcessTalkRequest(&this->actor, play)) {\n        this->actionState = INNKEEPER_TALKING;\n        this->talkTimer = 100;\n    } else if (this->actor.xzDistToPlayer < 100.0f) {\n        func_8002F2CC(&this->actor, play, 100.0f);\n    }\n}\n\nvoid EnInnkeeper_Update(Actor* thisx, PlayState* play) {\n    EnInnkeeper* this = (EnInnkeeper*)thisx;\n    \n    SkelAnime_Update(&this->skelAnime);\n    \n    if (this->talkTimer > 0) {\n        this->talkTimer--;\n        if (this->talkTimer == 0) {\n            this->actionState = INNKEEPER_IDLE;\n        }\n    }\n    \n    switch (this->actionState) {\n        case INNKEEPER_IDLE:\n            EnInnkeeper_Talk(this, play);\n            break;\n            \n        case INNKEEPER_TALKING:\n            if (Message_GetState(&play->msgCtx) == TEXT_STATE_NONE) {\n                this->actionState = INNKEEPER_WAIT;\n            }\n            break;\n            \n        case INNKEEPER_WAIT:\n            if (this->talkTimer == 0) {\n                this->actionState = INNKEEPER_IDLE;\n            }\n            break;\n    }\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnInnkeeper_Draw(Actor* thisx, PlayState* play) {\n    EnInnkeeper* this = (EnInnkeeper*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                          this->skelAnime.dListCount, NULL, NULL, this);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Innkeeper_InitVars = {\n    /**/ ACTOR_EN_INNKEEPER,\n    /**/ ACTORCAT_NPC,\n    /**/ FLAGS,\n    /**/ OBJECT_INNKEEPER,\n    /**/ sizeof(EnInnkeeper),\n    /**/ EnInnkeeper_Init,\n    /**/ EnInnkeeper_Destroy,\n    /**/ EnInnkeeper_Update,\n    /**/ EnInnkeeper_Draw\n};\n```\"\n}"}
{"instruction": "Create a actor creation system", "output": "{\n  \"instruction\": \"How do I create a merchant NPC that gives quests based on player progress? using basic interaction patterns with multiple states and transitions\",\n  \"input\": null,\n  \"output\": \"```c\n// Merchant NPC with quest states\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ ColliderCylinder collider;\n    /* 0x01DC */ s16 actionState;\n    /* 0x01DE */ s16 dialogState;\n    /* 0x01E0 */ Vec3s jointTable[25];\n    /* 0x0242 */ Vec3s morphTable[25];\n    /* 0x02A4 */ s16 blinkTimer;\n    /* 0x02A6 */ s16 eyeState;\n} EnMerchant; // size = 0x02A8\n\ntypedef enum {\n    /* 0 */ MERCHANT_STATE_IDLE,\n    /* 1 */ MERCHANT_STATE_TALKING,\n    /* 2 */ MERCHANT_STATE_GIVE_QUEST,\n    /* 3 */ MERCHANT_STATE_WAIT_QUEST\n} MerchantState;\n\nvoid EnMerchant_Init(Actor* thisx, PlayState* play) {\n    EnMerchant* this = (EnMerchant*)thisx;\n    \n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 20.0f);\n    SkelAnime_InitFlex(play, &this->skelAnime, &gMerchantSkel, &gMerchantIdleAnim, \n                       this->jointTable, this->morphTable, 25);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.targetMode = 6;\n    this->actionState = MERCHANT_STATE_IDLE;\n    this->dialogState = 0;\n    this->blinkTimer = 0;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnMerchant_Talk(EnMerchant* this, PlayState* play) {\n    Player* player = GET_PLAYER(play);\n    \n    if (Actor_ProcessTalkRequest(&this->actor, play)) {\n        this->actionState = MERCHANT_STATE_TALKING;\n        \n        // Check quest progress using save flags\n        if (!(gSaveContext.eventChkInf[3] & 0x0080)) {\n            Message_ContinueTextbox(play, 0x1040); // First quest dialog\n        } else if (!(gSaveContext.eventChkInf[3] & 0x0100)) {\n            if (gSaveContext.inventory.items[SLOT_KOKIRI_SWORD] != ITEM_NONE) {\n                Message_ContinueTextbox(play, 0x1041); // Second quest dialog\n                this->actionState = MERCHANT_STATE_GIVE_QUEST;\n            } else {\n                Message_ContinueTextbox(play, 0x1042); // Need sword dialog\n            }\n        } else {\n            Message_ContinueTextbox(play, 0x1043); // Complete dialog\n        }\n    }\n}\n\nvoid EnMerchant_Update(Actor* thisx, PlayState* play) {\n    EnMerchant* this = (EnMerchant*)thisx;\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Update blink animation\n    if (this->blinkTimer > 0) {\n        this->blinkTimer--;\n    } else {\n        this->blinkTimer = (s16)Rand_ZeroFloat(60.0f) + 20;\n        this->eyeState = 2;  // Blink state\n    }\n    \n    SkelAnime_Update(&this->skelAnime);\n    \n    switch (this->actionState) {\n        case MERCHANT_STATE_IDLE:\n            if (this->actor.xzDistToPlayer < 100.0f) {\n                func_8002F2CC(&this->actor, play, 100.0f);\n            }\n            EnMerchant_Talk(this, play);\n            break;\n            \n        case MERCHANT_STATE_TALKING:\n            if (Message_GetState(&play->msgCtx) == TEXT_STATE_DONE) {\n                if (Message_ShouldAdvance(play)) {\n                    Message_CloseTextbox(play);\n                    this->actionState = MERCHANT_STATE_IDLE;\n                }\n            }\n            break;\n            \n        case MERCHANT_STATE_GIVE_QUEST:\n            if (Message_GetState(&play->msgCtx) == TEXT_STATE_DONE) {\n                if (Message_ShouldAdvance(play)) {\n                    gSaveContext.eventChkInf[3] |= 0x0100;\n                    Message_CloseTextbox(play);\n                    this->actionState = MERCHANT_STATE_IDLE;\n                    Actor_PlaySfx(&this->actor, NA_SE_SY_TRE_BOX_APPEAR);\n                }\n            }\n            break;\n    }\n}\n\nvoid EnMerchant_Draw(Actor* thisx, PlayState* play) {\n    EnMerchant* this = (EnMerchant*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    gSPSegment(POLY_OPA_DISP++, 0x08, \n               SEGMENTED_TO_VIRTUAL(eyeTextures[this->eyeState]));\n               \n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                          this->skelAnime.dListCount, NULL, NULL, this);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Merchant_InitVars = {\n    /**/ ACTOR_EN_MERCHANT,\n    /**/ ACTORCAT_NPC,\n    /**/ FLAGS,\n    /**/ OBJECT_MERCHANT,\n    /**/ sizeof(EnMerchant),\n    /**/ EnMerchant_Init,\n    /**/ EnMerchant_Destroy,\n    /**/ EnMerchant_Update,\n    /**/ EnMerchant_Draw\n};\n```\"\n}"}
{"instruction": "Create a environmental system", "output": "{\n  \"instruction\": \"Create a Jabu-Jabu's Belly water and bubble mechanics with basic error checking\",\n  \"input\": null,\n  \"output\": \"\n```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 bubbleTimer;\n    /* 0x0150 */ f32 rippleScale;\n    /* 0x0154 */ Vec3f bubblePos;\n    /* 0x0160 */ ColliderCylinder collider;\n} EnJabuWater; // size = 0x1AC\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_NONE,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000000, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_NONE,\n        OCELEM_ON,\n    },\n    { 60, 45, 0, { 0, 0, 0 } },\n};\n\nvoid EnJabuWater_Init(Actor* thisx, PlayState* play) {\n    EnJabuWater* this = (EnJabuWater*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.flags &= ~ACTOR_FLAG_0;\n    Actor_SetScale(&this->actor, 0.1f);\n    \n    this->timer = 0;\n    this->bubbleTimer = (s16)(Rand_ZeroOne() * 20.0f) + 30;\n    this->rippleScale = 1.0f;\n    \n    // Set initial bubble position\n    this->bubblePos.x = this->actor.world.pos.x;\n    this->bubblePos.y = this->actor.world.pos.y;\n    this->bubblePos.z = this->actor.world.pos.z;\n}\n\nvoid EnJabuWater_Destroy(Actor* thisx, PlayState* play) {\n    EnJabuWater* this = (EnJabuWater*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnJabuWater_Update(Actor* thisx, PlayState* play) {\n    EnJabuWater* this = (EnJabuWater*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    // Update ripple effect\n    Math_SmoothStepToF(&this->rippleScale, 1.0f, 0.1f, 0.1f, 0.0f);\n    \n    // Bubble spawning logic\n    if (--this->bubbleTimer <= 0) {\n        // Spawn bubble effect using authentic effect system\n        EffectSsGRipple_Spawn(play, &this->bubblePos, 100, 500, 0);\n        this->bubbleTimer = (s16)(Rand_ZeroOne() * 20.0f) + 30;\n        \n        // Update bubble position randomly within water area\n        this->bubblePos.x = this->actor.world.pos.x + (Rand_CenteredFloat(40.0f));\n        this->bubblePos.z = this->actor.world.pos.z + (Rand_CenteredFloat(40.0f));\n    }\n    \n    // Basic collision check with player\n    if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 60.0f) {\n        if (player->actor.world.pos.y <= this->actor.world.pos.y) {\n            // Apply water physics - authentic pattern\n            player->actor.gravity = -1.0f;\n            player->actor.velocity.y *= 0.5f;\n        }\n    }\n    \n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnJabuWater_Draw(Actor* thisx, PlayState* play) {\n    EnJabuWater* this = (EnJabuWater*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Push();\n    Matrix_Scale(this->rippleScale, 1.0f, this->rippleScale, MTXMODE_APPLY);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n    Matrix_Pop();\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_JabuWater_InitVars = {\n    /**/ ACTOR_EN_JABU_WATER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnJabuWater),\n    /**/ EnJabuWater_Init,\n    /**/ EnJabuWater_Destroy,\n    /**/ EnJabuWater_Update,\n    /**/ EnJabuWater_Draw\n};\n```\"\n}"}
{"instruction": "Create a combat system system", "output": "{\n  \"instruction\": \"Create a Bow and arrow aiming and shooting system with extensive error handling and edge cases\",\n  \"input\": null,\n  \"output\": \"\n```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 aimState;\n    /* 0x0150 */ f32 bowPull;\n    /* 0x0154 */ Vec3f aimDir;\n    /* 0x0160 */ SkelAnime skelAnime;\n    /* 0x01A4 */ Vec3s jointTable[20];\n    /* 0x01F4 */ Vec3s morphTable[20];\n    /* 0x0244 */ ColliderCylinder collider;\n} EnBowAim; // size = 0x0290\n\nvoid EnBowAim_Init(Actor* thisx, PlayState* play) {\n    EnBowAim* this = (EnBowAim*)thisx;\n    Player* player = GET_PLAYER(play);\n\n    Actor_SetScale(&this->actor, 0.01f);\n    \n    // Initialize collision\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    // Initialize skeleton animation\n    SkelAnime_InitFlex(play, &this->skelAnime, &gBowSkel, &gBowAimAnim, \n                       this->jointTable, this->morphTable, 20);\n                       \n    this->aimState = 0;\n    this->bowPull = 0.0f;\n}\n\nvoid EnBowAim_Update(Actor* thisx, PlayState* play) {\n    EnBowAim* this = (EnBowAim*)thisx;\n    Player* player = GET_PLAYER(play);\n    s16 targetYaw;\n\n    // Only allow aiming if player has bow and arrows\n    if (!(gSaveContext.inventory.items[SLOT_BOW] == ITEM_BOW &&\n          gSaveContext.ammo[SLOT_BOW] > 0)) {\n        Actor_Kill(&this->actor);\n        return;\n    }\n\n    switch(this->aimState) {\n        case 0: // Start aiming\n            if (player->stateFlags1 & PLAYER_STATE1_11) { // Button held\n                this->aimState = 1;\n                this->bowPull = 0.0f;\n            }\n            break;\n\n        case 1: // Pulling bow\n            // Smoothly pull back bow\n            Math_SmoothStepToF(&this->bowPull, 1.0f, 0.2f, 0.3f, 0.01f);\n            \n            // Calculate aim direction from player rotation\n            targetYaw = player->actor.shape.rot.y;\n            Math_SmoothStepToS(&this->actor.shape.rot.y, targetYaw, 6, 2000, 30);\n\n            // Update aim direction\n            this->aimDir.x = Math_SinS(this->actor.shape.rot.y);\n            this->aimDir.z = Math_CosS(this->actor.shape.rot.y);\n            \n            if (!(player->stateFlags1 & PLAYER_STATE1_11)) { // Button released\n                // Spawn arrow actor with current aim parameters\n                Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ARROW, \n                    this->actor.world.pos.x,\n                    this->actor.world.pos.y + 50.0f,\n                    this->actor.world.pos.z,\n                    this->actor.shape.rot.x,\n                    this->actor.shape.rot.y,\n                    this->actor.shape.rot.z,\n                    ARROW_NORMAL);\n                    \n                gSaveContext.ammo[SLOT_BOW]--;\n                this->aimState = 2;\n            }\n            break;\n\n        case 2: // Shot arrow, reset\n            this->aimState = 0;\n            this->bowPull = 0.0f;\n            break;\n    }\n\n    // Update collision and position\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 50.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n                           \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnBowAim_Draw(Actor* thisx, PlayState* play) {\n    EnBowAim* this = (EnBowAim*)thisx;\n\n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    // Draw bow model with current pull animation\n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                         this->skelAnime.dListCount, NULL, NULL, this);\n                         \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile EnBowAim_InitVars = {\n    /**/ ACTOR_EN_BOW_AIM,\n    /**/ ACTORCAT_MISC,\n    /**/ FLAGS,\n    /**/ OBJECT_BOW,\n    /**/ sizeof(EnBowAim),\n    /**/ EnBowAim_Init,\n    /**/ EnBowAim_Destroy,\n    /**/ EnBowAim_Update,\n    /**/ EnBowAim_Draw\n};\n```\n\"}"}
{"instruction": "Create a interaction system system", "output": "{\n  \"instruction\": \"Create a relationship system between NPCs and the player with complex mathematical calculations\",\n  \"input\": null,\n  \"output\": \"```c\n// Authentic relationship value tracking structure following OoT patterns\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 relationshipValue;\n    /* 0x014E */ s16 interactionTimer;\n    /* 0x0150 */ f32 playerDist;\n    /* 0x0154 */ f32 interactionRange;\n    /* 0x0158 */ s16 interactionCount;\n    /* 0x015A */ s16 moodTimer;\n    /* 0x015C */ ColliderCylinder collider;\n} EnNpcRelation;\n\nvoid EnNpcRelation_Init(Actor* thisx, PlayState* play) {\n    EnNpcRelation* this = (EnNpcRelation*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->relationshipValue = 0;\n    this->interactionTimer = 0;\n    this->interactionRange = 100.0f;\n    this->interactionCount = 0;\n    this->moodTimer = 0;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnNpcRelation_Update(Actor* thisx, PlayState* play) {\n    EnNpcRelation* this = (EnNpcRelation*)thisx;\n    Player* player = GET_PLAYER(play);\n    f32 relationModifier;\n    \n    // Authentic distance calculation\n    this->playerDist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    // Update collision and bg check using authentic patterns\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 20.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (this->playerDist < this->interactionRange) {\n        this->interactionTimer++;\n        \n        // Complex relationship calculation based on multiple factors\n        relationModifier = Math_CosS(this->interactionTimer * 0x200) * 0.5f;\n        relationModifier += Math_SinS(this->moodTimer * 0x100) * 0.3f;\n        \n        // Modify relationship based on player's equipped items\n        if (gSaveContext.inventory.items[SLOT_OCARINA] == ITEM_OCARINA_TIME) {\n            relationModifier += 0.2f;\n        }\n        \n        // Update relationship value with clamping\n        this->relationshipValue += (s16)(relationModifier * 10.0f);\n        this->relationshipValue = CLAMP(this->relationshipValue, -1000, 1000);\n        \n        // Mood timer affects relationship fluctuation\n        this->moodTimer = (this->moodTimer + 1) % 100;\n    }\n    \n    // Update interaction count when player is very close\n    if (this->playerDist < 50.0f) {\n        if (this->interactionCount < 0x7FFF) {\n            this->interactionCount++;\n        }\n    }\n}\n\nvoid EnNpcRelation_Draw(Actor* thisx, PlayState* play) {\n    EnNpcRelation* this = (EnNpcRelation*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, this->actor.scale.z, MTXMODE_APPLY);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__), \n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n              \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile EnNpcRelation_Profile = {\n    ACTOR_EN_NPC_RELATION,\n    ACTORCAT_NPC,\n    FLAGS,\n    OBJECT_GAMEPLAY_KEEP,\n    sizeof(EnNpcRelation),\n    EnNpcRelation_Init,\n    EnNpcRelation_Destroy,\n    EnNpcRelation_Update,\n    EnNpcRelation_Draw\n};\n```\"\n}"}
{"instruction": "Create a code explanation system", "output": "{\n  \"instruction\": \"Implement a complex code explanation system for enhanced gameplay using simple patterns\",\n  \"input\": null,\n  \"output\": \"// Simple hint system actor that displays messages when approached\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 messageState;\n    /* 0x014E */ s16 messageTimer;\n    /* 0x0150 */ f32 detectionRange;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnHint;\n\nvoid EnHint_Init(Actor* thisx, PlayState* play) {\n    EnHint* this = (EnHint*)thisx;\n    \n    // Initialize collision detection cylinder\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->detectionRange = 100.0f;\n    this->messageState = 0;\n    this->messageTimer = 0;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnHint_Update(Actor* thisx, PlayState* play) {\n    EnHint* this = (EnHint*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    // Update collision checking\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    f32 playerDist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    // Show message when player is in range\n    if (playerDist < this->detectionRange && this->messageState == 0) {\n        Message_StartTextbox(play, 0x1234, NULL); // Use real message ID\n        this->messageState = 1;\n        this->messageTimer = 30;\n    }\n    \n    if (this->messageTimer > 0) {\n        this->messageTimer--;\n        if (this->messageTimer == 0) {\n            this->messageState = 0;\n        }\n    }\n}\n\nvoid EnHint_Draw(Actor* thisx, PlayState* play) {\n    EnHint* this = (EnHint*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n    gSPDisplayList(POLY_OPA_DISP++, gEffFlash1DL);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Hint_InitVars = {\n    /**/ ACTOR_EN_HINT,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnHint),\n    /**/ EnHint_Init,\n    /**/ Actor_Destroy,\n    /**/ EnHint_Update, \n    /**/ EnHint_Draw\n};\"\n}"}
{"instruction": "Create a collision system system", "output": "{\n  \"instruction\": \"Create a collision filtering system for different object types implementing sophisticated AI behaviors\",\n  \"input\": null,\n  \"output\": \"\n```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 behaviorState;\n    /* 0x0150 */ f32 detectionRange;\n    /* 0x0154 */ Vec3f lastTargetPos;\n    /* 0x0160 */ ColliderCylinder collider;\n    /* 0x01AC */ ColliderJntSph colliderSph;\n    /* 0x01CC */ ColliderJntSphElement elements[1];\n} EnSensor; // size = 0x020C\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 25, 70, 0, { 0, 0, 0 } },\n};\n\nstatic ColliderJntSphElementInit sJntSphElementsInit[1] = {\n    {\n        {\n            ELEMTYPE_UNK0,\n            { 0x00000000, 0x00, 0x00 },\n            { 0xFFCFFFFF, 0x00, 0x00 },\n            TOUCH_NONE,\n            BUMP_ON,\n            OCELEM_ON,\n        },\n        { 0, { 0, 0, 0 }, 20 },\n    },\n};\n\nstatic ColliderJntSphInit sJntSphInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_JNTSPH,\n    },\n    1,\n    sJntSphElementsInit,\n};\n\nvoid EnSensor_Init(Actor* thisx, PlayState* play) {\n    EnSensor* this = (EnSensor*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Collider_InitJntSph(play, &this->colliderSph);\n    Collider_SetJntSph(play, &this->colliderSph, &this->actor, &sJntSphInit, this->elements);\n    \n    this->detectionRange = 200.0f;\n    this->behaviorState = 0;\n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnSensor_DetectCollisions(EnSensor* this, PlayState* play) {\n    Player* player = GET_PLAYER(play);\n    \n    if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < this->detectionRange) {\n        if (this->collider.base.acFlags & AC_HIT) {\n            this->behaviorState = 1;\n            this->lastTargetPos = player->actor.world.pos;\n        } else if (this->colliderSph.base.acFlags & AC_HIT) {\n            this->behaviorState = 2;\n            this->lastTargetPos = player->actor.world.pos;\n        }\n    }\n}\n\nvoid EnSensor_Update(Actor* thisx, PlayState* play) {\n    EnSensor* this = (EnSensor*)thisx;\n    f32 dx;\n    f32 dz;\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 35.0f, 60.0f, 60.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    Collider_UpdateJntSph(&this->actor, &this->colliderSph);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->colliderSph.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->colliderSph.base);\n    \n    EnSensor_DetectCollisions(this, play);\n    \n    switch (this->behaviorState) {\n        case 0:\n            break;\n        case 1:\n            dx = this->lastTargetPos.x - this->actor.world.pos.x;\n            dz = this->lastTargetPos.z - this->actor.world.pos.z;\n            Math_SmoothStepToF(&this->actor.speedXZ, 5.0f, 0.3f, 1.0f, 0.0f);\n            Math_SmoothStepToS(&this->actor.world.rot.y, Math_FAtan2F(dz, dx) * (0x8000 / M_PI), 5, 3000, 0);\n            break;\n        case 2:\n            Math_SmoothStepToF(&this->actor.speedXZ, 0.0f, 0.3f, 1.0f, 0.0f);\n            break;\n    }\n    \n    Actor_MoveXZGravity(&this->actor);\n    \n    this->timer++;\n    if (this->timer > 300) {\n        this->behaviorState = 0;\n        this->timer = 0;\n    }\n}\n\nconst ActorProfile EnSensor_Profile = {\n    ACTOR_EN_SENSOR,\n    ACTORCAT_PROP,\n    FLAGS,\n    OBJECT_GAMEPLAY_KEEP,\n    sizeof(EnSensor),\n    EnSensor_Init,\n    EnSensor_Destroy,\n    EnSensor_Update,\n    NULL\n};\n```\n\"\n}"}
{"instruction": "Create a custom mechanics system", "output": "{\n  \"instruction\": \"Create a Treasure Chest opening and item collection with basic debugging support\",\n  \"input\": null,\n  \"output\": \"```c\n// Treasure chest actor with authentic OoT patterns\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 openingState;\n    /* 0x014E */ s16 timer;\n    /* 0x0150 */ f32 lidAngle;\n    /* 0x0154 */ s16 getItemId;\n    /* 0x0156 */ s16 debugMode;\n    /* 0x0158 */ ColliderCylinder collider;\n} EnTreasure;\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000010, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnTreasure_Init(Actor* thisx, PlayState* play) {\n    EnTreasure* this = (EnTreasure*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    \n    this->openingState = 0;\n    this->timer = 0;\n    this->lidAngle = 0.0f;\n    this->getItemId = GI_RUPEE_GREEN; // Default item\n    this->debugMode = 0;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    // Debug: Print initialization\n    #ifdef ENABLE_DEBUG\n    osSyncPrintf(VT_FGCOL(GREEN) \\\"Treasure Chest Init: pos(%f, %f, %f)\\\\n\\\" VT_RST,\n        this->actor.world.pos.x,\n        this->actor.world.pos.y,\n        this->actor.world.pos.z);\n    #endif\n}\n\nvoid EnTreasure_Update(Actor* thisx, PlayState* play) {\n    EnTreasure* this = (EnTreasure*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    switch (this->openingState) {\n        case 0: // Closed\n            if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 50.0f) {\n                if (Actor_IsFacingPlayer(&this->actor, 0x2000)) {\n                    if (!(player->stateFlags1 & PLAYER_STATE1_27)) {\n                        Message_StartTextbox(play, 0x7010, NULL);\n                        this->openingState = 1;\n                        \n                        #ifdef ENABLE_DEBUG\n                        osSyncPrintf(VT_FGCOL(YELLOW) \\\"Treasure Opening Started\\\\n\\\" VT_RST);\n                        #endif\n                    }\n                }\n            }\n            break;\n            \n        case 1: // Opening\n            Math_SmoothStepToF(&this->lidAngle, 120.0f, 0.3f, 5.0f, 0.1f);\n            \n            if (this->lidAngle >= 119.0f) {\n                this->openingState = 2;\n                Actor_OfferGetItem(&this->actor, play, this->getItemId, 50.0f, 100.0f);\n            }\n            break;\n            \n        case 2: // Opened\n            if (Actor_HasParent(&this->actor, play)) {\n                this->openingState = 3;\n            } else {\n                Actor_OfferGetItem(&this->actor, play, this->getItemId, 50.0f, 100.0f);\n            }\n            break;\n            \n        case 3: // Item collected\n            if (Actor_HasNoParent(&this->actor, play)) {\n                Actor_Kill(&this->actor);\n                \n                #ifdef ENABLE_DEBUG\n                osSyncPrintf(VT_FGCOL(RED) \\\"Treasure Destroyed\\\\n\\\" VT_RST);\n                #endif\n            }\n            break;\n    }\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnTreasure_Draw(Actor* thisx, PlayState* play) {\n    EnTreasure* this = (EnTreasure*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_RotateY(BINANG_TO_RAD(this->actor.world.rot.y), MTXMODE_APPLY);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, this->actor.scale.z, MTXMODE_APPLY);\n    \n    // Draw chest base and lid with rotation\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__), \n        G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n    gSPDisplayList(POLY_OPA_DISP++, gChestBaseDL);\n    \n    Matrix_RotateX(BINANG_TO_RAD(this->lidAngle), MTXMODE_APPLY);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n        G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n    gSPDisplayList(POLY_OPA_DISP++, gChestLidDL);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Treasure_InitVars = {\n    /**/ ACTOR_EN_TREASURE,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnTreasure),\n    /**/ EnTreasure_Init,\n    /**/ EnTreasure_Destroy,\n    /**/ EnTreasure_Update,\n    /**/ EnTreasure_Draw\n};\n```\"\n}"}
{"instruction": "Implement an inventory system with item management with proper error handling", "output": "// Authentic inventory system using OoT patterns\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 itemId;\n    /* 0x014E */ s16 itemCount;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnItemManager; // size = 0x1A0\n\n// Authentic collision init data\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000010, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 12, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnItemManager_Init(Actor* thisx, PlayState* play) {\n    EnItemManager* this = (EnItemManager*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->itemId = -1;\n    this->itemCount = 0;\n}\n\nvoid EnItemManager_Update(Actor* thisx, PlayState* play) {\n    EnItemManager* this = (EnItemManager*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    // Authentic collision update\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Check if player is near and handle item pickup\n    if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 50.0f) {\n        if (this->itemId >= 0) {\n            // Verify item slot is available\n            s16 slot = SLOT_BOTTLE;\n            if (gSaveContext.inventory.items[slot] == ITEM_NONE) {\n                gSaveContext.inventory.items[slot] = this->itemId;\n                Actor_Kill(&this->actor);\n                return;\n            }\n        }\n    }\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 26.0f, 10.0f, 0.0f, UPDBGCHECKINFO_FLAG_0);\n}\n\nvoid EnItemManager_Draw(Actor* thisx, PlayState* play) {\n    EnItemManager* this = (EnItemManager*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile EnItemManager_Profile = {\n    /**/ ACTOR_EN_ITEM_MANAGER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnItemManager),\n    /**/ EnItemManager_Init,\n    /**/ Actor_Destroy,\n    /**/ EnItemManager_Update, \n    /**/ EnItemManager_Draw\n};"}
{"instruction": "Implement code explanation functionality using authentic code implementing common features", "output": "// Authentic actor that displays text when approached and interacted with\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ ColliderCylinder collider;\n    /* 0x0198 */ s16 actionState;\n    /* 0x019A */ s16 textId;\n    /* 0x019C */ s16 textBoxTimer;\n} EnGuide; // size = 0x01A0\n\nvoid EnGuide_Init(Actor* thisx, PlayState* play) {\n    EnGuide* this = (EnGuide*)thisx;\n\n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.targetMode = 6;\n    this->actionState = 0;\n    this->textId = 0x1000; // Default message ID\n    \n    // Initialize collision cylinder for player detection\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor,\n        &(ColliderCylinderInit){\n            .base = { .colType = COLTYPE_NONE },\n            .dim = { .radius = 50, .height = 80 },\n            .pos = { 0, 40, 0 }\n        });\n}\n\nvoid EnGuide_Update(Actor* thisx, PlayState* play) {\n    EnGuide* this = (EnGuide*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    // Check if player is nearby\n    f32 dist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n\n    switch(this->actionState) {\n        case 0: // Waiting for player approach\n            if (dist < 100.0f) {\n                this->actionState = 1;\n                // Show prompt icon\n                Actor_SetFocus(&this->actor, 60.0f);\n            }\n            break;\n\n        case 1: // Player in range\n            if (Actor_ProcessTalkRequest(&this->actor, play)) {\n                this->actionState = 2;\n                this->textBoxTimer = 0;\n            }\n            break;\n            \n        case 2: // Showing text\n            this->textBoxTimer++;\n            if (Message_GetState(&play->msgCtx) == TEXT_STATE_DONE && \n                this->textBoxTimer > 4) {\n                this->actionState = 0;\n                Message_CloseTextbox(play);\n            }\n            break;\n    }\n}\n\nvoid EnGuide_Draw(Actor* thisx, PlayState* play) {\n    EnGuide* this = (EnGuide*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n    // Draw model here\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile EnGuide_InitVars = {\n    /**/ ACTOR_EN_GUIDE,\n    /**/ ACTORCAT_NPC,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnGuide),\n    /**/ EnGuide_Init,\n    /**/ EnGuide_Destroy,\n    /**/ EnGuide_Update, \n    /**/ EnGuide_Draw\n};"}
{"instruction": "Create a custom mechanics system", "output": "{\n  \"instruction\": \"Make a Gossip Stone hint system with good code organization\",\n  \"input\": null,\n  \"output\": \"```c\n// en_gs.h\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ ColliderCylinder collider;\n    /* 0x0198 */ s16 actionState;\n    /* 0x019A */ s16 timer;\n    /* 0x019C */ s16 hintIndex;\n    /* 0x019E */ s16 alpha;\n} EnGs; // size = 0x01A0\n\n// en_gs.c\n#include \\\"z_en_gs.h\\\"\n\ntypedef struct {\n    u16 messageId;\n    u8 requirement; // Item or flag needed to show hint\n    u8 regionFlag;  // Region this hint belongs to\n} GsHint;\n\nstatic const GsHint sHintTable[] = {\n    { 0x5001, ITEM_SWORD_KOKIRI, 1 }, // Kokiri Forest hints\n    { 0x5002, ITEM_SLINGSHOT, 2 },    // Death Mountain hints\n    { 0x5003, ITEM_OCARINA_FAIRY, 3 }, // Zora's Domain hints\n    // Add more authentic message IDs and requirements\n};\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000010, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 60, 0, { 0, 0, 0 } },\n};\n\nvoid EnGs_Init(Actor* thisx, PlayState* play) {\n    EnGs* this = (EnGs*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.focus.pos = this->actor.world.pos;\n    this->actor.focus.pos.y += 50.0f;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actionState = 0;\n    this->timer = 0;\n    this->alpha = 255;\n    \n    // Assign hint based on actor params\n    this->hintIndex = this->actor.params & 0xFF;\n}\n\nvoid EnGs_Destroy(Actor* thisx, PlayState* play) {\n    EnGs* this = (EnGs*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnGs_CheckPlayer(EnGs* this, PlayState* play) {\n    Player* player = GET_PLAYER(play);\n    \n    if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 100.0f) {\n        if (gSaveContext.inventory.items[SLOT_OCARINA] != ITEM_NONE) {\n            // Check if player has required item for this hint\n            if (gSaveContext.inventory.items[SLOT_KOKIRI_SWORD] == sHintTable[this->hintIndex].requirement) {\n                Message_StartTextbox(play, sHintTable[this->hintIndex].messageId, NULL);\n                this->actionState = 1;\n            }\n        }\n    }\n}\n\nvoid EnGs_Update(Actor* thisx, PlayState* play) {\n    EnGs* this = (EnGs*)thisx;\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    switch (this->actionState) {\n        case 0:\n            EnGs_CheckPlayer(this, play);\n            break;\n            \n        case 1:\n            if (Message_GetState(&play->msgCtx) == TEXT_STATE_NONE) {\n                this->actionState = 0;\n            }\n            break;\n    }\n}\n\nvoid EnGs_Draw(Actor* thisx, PlayState* play) {\n    EnGs* this = (EnGs*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 255, 255, 255, this->alpha);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n              \n    gSPDisplayList(POLY_OPA_DISP++, gGossipStoneDL);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Gs_InitVars = {\n    ACTOR_EN_GS,\n    ACTORCAT_PROP,\n    FLAGS_TALK,\n    OBJECT_GS,\n    sizeof(EnGs),\n    (ActorFunc)EnGs_Init,\n    (ActorFunc)EnGs_Destroy,\n    (ActorFunc)EnGs_Update,\n    (ActorFunc)EnGs_Draw\n};\n```\"\n}"}
{"instruction": "Create a ai behavior system", "output": "{\n  \"instruction\": \"Implement a Sword combat with different attack patterns with complex mathematical calculations\",\n  \"input\": null,\n  \"output\": \"```c\n// Complex sword enemy with mathematical attack patterns\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ Vec3s jointTable[25];\n    /* 0x01F4 */ Vec3s morphTable[25];\n    /* 0x0258 */ s16 timer;\n    /* 0x025A */ s16 attackState;\n    /* 0x025C */ f32 attackAngle;\n    /* 0x0260 */ f32 swordRadius;\n    /* 0x0264 */ f32 targetDist;\n    /* 0x0268 */ Vec3f swordTip;\n    /* 0x0274 */ ColliderCylinder bodyCollider;\n    /* 0x02C0 */ ColliderQuad swordCollider;\n} EnSwordEnemy;\n\nvoid EnSwordEnemy_Init(Actor* thisx, PlayState* play) {\n    EnSwordEnemy* this = (EnSwordEnemy*)thisx;\n    \n    SkelAnime_InitFlex(play, &this->skelAnime, &gSwordEnemySkel, &gSwordEnemyIdleAnim, \n                       this->jointTable, this->morphTable, 25);\n    \n    Collider_InitCylinder(play, &this->bodyCollider);\n    Collider_SetCylinder(play, &this->bodyCollider, &this->actor, &sBodyColInit);\n    \n    Collider_InitQuad(play, &this->swordCollider);\n    Collider_SetQuad(play, &this->swordCollider, &this->actor, &sSwordColInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->attackState = 0;\n    this->swordRadius = 80.0f;\n}\n\nvoid EnSwordEnemy_CalcAttackPattern(EnSwordEnemy* this, PlayState* play) {\n    Player* player = GET_PLAYER(play);\n    f32 dx = player->actor.world.pos.x - this->actor.world.pos.x;\n    f32 dz = player->actor.world.pos.z - this->actor.world.pos.z;\n    \n    // Calculate distance to player\n    this->targetDist = sqrtf(SQ(dx) + SQ(dz));\n    \n    // Complex attack pattern based on sine waves and distance\n    if (this->attackState == 1) {\n        this->attackAngle += sinf(this->timer * 0.1f) * 0.2f;\n        this->swordTip.x = this->actor.world.pos.x + cosf(this->attackAngle) * this->swordRadius;\n        this->swordTip.z = this->actor.world.pos.z + sinf(this->attackAngle) * this->swordRadius;\n        this->swordTip.y = this->actor.world.pos.y + 40.0f + sinf(this->timer * 0.2f) * 20.0f;\n    }\n}\n\nvoid EnSwordEnemy_Update(Actor* thisx, PlayState* play) {\n    EnSwordEnemy* this = (EnSwordEnemy*)thisx;\n    s16 angleToPlayer;\n    \n    this->timer++;\n    \n    // Update animation\n    SkelAnime_Update(&this->skelAnime);\n    \n    if (this->targetDist < 200.0f) {\n        this->attackState = 1;\n        // Face player smoothly\n        angleToPlayer = Actor_WorldYawTowardActor(&this->actor, &GET_PLAYER(play)->actor);\n        Math_SmoothStepToS(&this->actor.world.rot.y, angleToPlayer, 5, 3000, 0);\n    } else {\n        this->attackState = 0;\n    }\n    \n    EnSwordEnemy_CalcAttackPattern(this, play);\n    \n    // Update colliders\n    Collider_UpdateCylinder(&this->actor, &this->bodyCollider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->bodyCollider.base);\n    \n    if (this->attackState == 1) {\n        // Update sword collision quad based on calculated tip position\n        Collider_SetQuadVertices(&this->swordCollider,\n            &this->actor.world.pos,\n            &this->swordTip,\n            &this->swordTip,\n            &this->actor.world.pos);\n        CollisionCheck_SetAC(play, &play->colChkCtx, &this->swordCollider.base);\n    }\n    \n    // Update physics and ground alignment\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 30.0f, 30.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n}\n\nvoid EnSwordEnemy_Draw(Actor* thisx, PlayState* play) {\n    EnSwordEnemy* this = (EnSwordEnemy*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    // Draw skeleton\n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                          this->skelAnime.dListCount, NULL, NULL, this);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_SwordEnemy_InitVars = {\n    /**/ ACTOR_EN_SWORD_ENEMY,\n    /**/ ACTORCAT_ENEMY,\n    /**/ FLAGS,\n    /**/ OBJECT_SWORD_ENEMY,\n    /**/ sizeof(EnSwordEnemy),\n    /**/ EnSwordEnemy_Init,\n    /**/ EnSwordEnemy_Destroy,\n    /**/ EnSwordEnemy_Update,\n    /**/ EnSwordEnemy_Draw\n};\n```\"\n}"}
{"instruction": "Create a puzzle system system", "output": "{\n  \"instruction\": \"Build a puzzle pedestal object that creates temporary bridges across gaps when activated using advanced rendering techniques\",\n  \"input\": null,\n  \"output\": \"```c\n// Puzzle pedestal that creates temporary light bridges\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 bridgeState;\n    /* 0x0150 */ f32 bridgeAlpha;\n    /* 0x0154 */ Vec3f bridgeStart;\n    /* 0x0160 */ Vec3f bridgeEnd; \n    /* 0x16C */ ColliderCylinder collider;\n} EnBridgePedestal;\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 60, 0, { 0, 0, 0 } },\n};\n\nvoid EnBridgePedestal_Init(Actor* thisx, PlayState* play) {\n    EnBridgePedestal* this = (EnBridgePedestal*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.1f);\n    \n    this->bridgeState = 0;\n    this->bridgeAlpha = 0.0f;\n    this->timer = 0;\n    \n    // Store bridge endpoints relative to pedestal\n    this->bridgeStart = this->actor.world.pos;\n    this->bridgeEnd = this->actor.world.pos;\n    this->bridgeEnd.z += 300.0f;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n}\n\nvoid EnBridgePedestal_Destroy(Actor* thisx, PlayState* play) {\n    EnBridgePedestal* this = (EnBridgePedestal*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnBridgePedestal_Update(Actor* thisx, PlayState* play) {\n    EnBridgePedestal* this = (EnBridgePedestal*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Check if player is near pedestal\n    if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 80.0f) {\n        if (this->bridgeState == 0) {\n            this->bridgeState = 1;\n            this->timer = 200; // Bridge duration\n        }\n    }\n    \n    // Handle bridge state\n    if (this->bridgeState == 1) {\n        Math_SmoothStepToF(&this->bridgeAlpha, 255.0f, 0.3f, 10.0f, 0.1f);\n        \n        if (this->timer > 0) {\n            this->timer--;\n        } else {\n            this->bridgeState = 2;\n        }\n    } else if (this->bridgeState == 2) {\n        Math_SmoothStepToF(&this->bridgeAlpha, 0.0f, 0.3f, 10.0f, 0.1f);\n        \n        if (this->bridgeAlpha <= 0.0f) {\n            this->bridgeState = 0;\n        }\n    }\n}\n\nvoid EnBridgePedestal_Draw(Actor* thisx, PlayState* play) {\n    EnBridgePedestal* this = (EnBridgePedestal*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    // Draw pedestal\n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 100, 100, 255, 255);\n    \n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, \n                    this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, \n                this->actor.scale.z, MTXMODE_APPLY);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n    gSPDisplayList(POLY_OPA_DISP++, gCubeBaseDL);\n    \n    // Draw bridge if active\n    if (this->bridgeAlpha > 0.0f) {\n        Gfx_SetupDL_25Xlu(play->state.gfxCtx);\n        gDPSetPrimColor(POLY_XLU_DISP++, 0, 0, 100, 200, 255, (u8)this->bridgeAlpha);\n        \n        Matrix_Translate(this->bridgeStart.x, this->bridgeStart.y + 20.0f,\n                        this->bridgeStart.z, MTXMODE_NEW);\n        Matrix_Scale(3.0f, 0.1f, 30.0f, MTXMODE_APPLY);\n        \n        gSPMatrix(POLY_XLU_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n                  G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n        gSPDisplayList(POLY_XLU_DISP++, gCubeBaseDL);\n    }\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_BridgePedestal_InitVars = {\n    /**/ ACTOR_EN_BRIDGE_PEDESTAL,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnBridgePedestal),\n    /**/ EnBridgePedestal_Init,\n    /**/ EnBridgePedestal_Destroy,\n    /**/ EnBridgePedestal_Update,\n    /**/ EnBridgePedestal_Draw\n};\n```\"\n}"}
{"instruction": "Create a ai behavior system", "output": "{\n\"instruction\": \"Create a Magic spell casting and mana system with complex interaction patterns\",\n\"input\": null,\n\"output\": \"\n```c\n// Magic spell effect actor\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 scale;\n    /* 0x0152 */ Vec3f effectPos[8];\n    /* 0x0182 */ s16 effectTimer[8];\n    /* 0x0192 */ ColliderCylinder collider;\n    /* 0x01DE */ SkelAnime skelAnime;\n    /* 0x0222 */ Vec3s jointTable[20];\n    /* 0x0286 */ Vec3s morphTable[20];\n} EnMagicEffect;\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_ON | AT_TYPE_PLAYER,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000002, 0x00, 0x01 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_ON | TOUCH_SFX_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 45, 0, { 0, 0, 0 } }\n};\n\nvoid EnMagicEffect_Init(Actor* thisx, PlayState* play) {\n    EnMagicEffect* this = (EnMagicEffect*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actionState = 0;\n    this->timer = 0;\n    \n    // Initialize effect positions\n    for (s32 i = 0; i < 8; i++) {\n        this->effectTimer[i] = 0;\n    }\n    \n    // Only use magic if player has enough MP\n    if (gSaveContext.magic < 4) {\n        Actor_Kill(&this->actor);\n        return;\n    }\n    \n    gSaveContext.magic -= 4;\n}\n\nvoid EnMagicEffect_Update(Actor* thisx, PlayState* play) {\n    EnMagicEffect* this = (EnMagicEffect*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    switch(this->actionState) {\n        case 0: // Startup\n            if (this->timer > 8) {\n                this->actionState = 1;\n                this->timer = 0;\n            }\n            break;\n            \n        case 1: // Active\n            // Update effect positions\n            for (s32 i = 0; i < 8; i++) {\n                if (this->effectTimer[i] > 0) {\n                    this->effectTimer[i]--;\n                    Math_ApproachF(&this->effectPos[i].y, this->actor.world.pos.y + 50.0f, 0.3f, 3.0f);\n                }\n            }\n            \n            // Check collision with enemies\n            if (this->collider.base.atFlags & AT_HIT) {\n                this->actionState = 2;\n                this->timer = 0;\n            }\n            \n            // Update collision\n            Collider_UpdateCylinder(&this->actor, &this->collider);\n            CollisionCheck_SetAT(play, &play->colChkCtx, &this->collider.base);\n            CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n            break;\n            \n        case 2: // Finish\n            if (this->timer > 20) {\n                Actor_Kill(&this->actor);\n            }\n            break;\n    }\n    \n    // Update background collision\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 50.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n}\n\nvoid EnMagicEffect_Draw(Actor* thisx, PlayState* play) {\n    EnMagicEffect* this = (EnMagicEffect*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Push();\n    Matrix_Scale(this->scale, this->scale, this->scale, MTXMODE_APPLY);\n    Matrix_RotateY(this->actor.world.rot.y * (M_PI / 32768.0f), MTXMODE_APPLY);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__), \n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n              \n    Matrix_Pop();\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_MagicEffect_InitVars = {\n    /**/ ACTOR_EN_MAGIC_EFFECT,\n    /**/ ACTORCAT_MISC,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnMagicEffect),\n    /**/ EnMagicEffect_Init,\n    /**/ EnMagicEffect_Destroy,\n    /**/ EnMagicEffect_Update,\n    /**/ EnMagicEffect_Draw\n};\n```\n\"}"}
{"instruction": "Create a interaction system system", "output": "{\n  \"instruction\": \"Make a skill system that improves with use implementing multiple subsystems\",\n  \"input\": null,\n  \"output\": \"```c\n// EnSkill.h\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 swordLevel;\n    /* 0x014E */ s16 shieldLevel; \n    /* 0x0150 */ s16 magicLevel;\n    /* 0x0152 */ s16 hitCount;\n    /* 0x0154 */ s16 blockCount;\n    /* 0x0156 */ s16 spellCount;\n    /* 0x0158 */ ColliderCylinder collider;\n} EnSkill;\n\n// EnSkill.c\n#include \\\"z_en_skill.h\\\"\n\n#define SKILL_MAX_LEVEL 3\n#define HITS_PER_LEVEL 10\n#define BLOCKS_PER_LEVEL 8\n#define SPELLS_PER_LEVEL 5\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnSkill_Init(Actor* thisx, PlayState* play) {\n    EnSkill* this = (EnSkill*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->swordLevel = 0;\n    this->shieldLevel = 0;\n    this->magicLevel = 0;\n    this->hitCount = 0;\n    this->blockCount = 0;\n    this->spellCount = 0;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnSkill_Destroy(Actor* thisx, PlayState* play) {\n    EnSkill* this = (EnSkill*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnSkill_CheckSkillProgress(EnSkill* this) {\n    // Sword skill progression\n    if (this->hitCount >= HITS_PER_LEVEL && this->swordLevel < SKILL_MAX_LEVEL) {\n        this->swordLevel++;\n        this->hitCount = 0;\n        \n        // Save progression\n        gSaveContext.save.info.playerData.swordLevel = this->swordLevel;\n    }\n    \n    // Shield skill progression  \n    if (this->blockCount >= BLOCKS_PER_LEVEL && this->shieldLevel < SKILL_MAX_LEVEL) {\n        this->shieldLevel++;\n        this->blockCount = 0;\n        \n        gSaveContext.save.info.playerData.shieldLevel = this->shieldLevel;\n    }\n    \n    // Magic skill progression\n    if (this->spellCount >= SPELLS_PER_LEVEL && this->magicLevel < SKILL_MAX_LEVEL) {\n        this->magicLevel++;\n        this->spellCount = 0;\n        \n        gSaveContext.save.info.playerData.magicLevel = this->magicLevel;\n    }\n}\n\nvoid EnSkill_Update(Actor* thisx, PlayState* play) {\n    EnSkill* this = (EnSkill*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    // Check for sword hits\n    if (player->swordAnimation) {\n        this->hitCount++;\n    }\n    \n    // Check for successful blocks\n    if (player->isBlocking && (this->collider.base.acFlags & AC_HIT)) {\n        this->blockCount++;\n    }\n    \n    // Check for magic usage\n    if (gSaveContext.magicState == MAGIC_STATE_CONSUME) {\n        this->spellCount++;\n    }\n    \n    EnSkill_CheckSkillProgress(this);\n    \n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnSkill_Draw(Actor* thisx, PlayState* play) {\n    // No visual representation needed\n}\n\nconst ActorProfile En_Skill_InitVars = {\n    /**/ ACTOR_EN_SKILL,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnSkill),\n    /**/ EnSkill_Init,\n    /**/ EnSkill_Destroy,\n    /**/ EnSkill_Update,\n    /**/ EnSkill_Draw\n};\n```\"\n}"}
{"instruction": "Implement a procedural animation system for natural movement with basic functionality", "output": "typedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 animState;\n    /* 0x0150 */ f32 yOffset;\n    /* 0x0154 */ f32 bobPhase;\n    /* 0x0158 */ f32 bobSpeed;\n    /* 0x015C */ f32 bobHeight;\n    /* 0x0160 */ ColliderCylinder collider;\n} EnFloater; // size = 0x1AC\n\nvoid EnFloater_Init(Actor* thisx, PlayState* play) {\n    EnFloater* this = (EnFloater*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->bobPhase = 0.0f;\n    this->bobSpeed = 0.05f;\n    this->bobHeight = 5.0f;\n    this->yOffset = this->actor.world.pos.y;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n}\n\nvoid EnFloater_Update(Actor* thisx, PlayState* play) {\n    EnFloater* this = (EnFloater*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->bobPhase += this->bobSpeed;\n    if (this->bobPhase >= M_PI * 2) {\n        this->bobPhase -= M_PI * 2;\n    }\n    \n    // Smooth bobbing motion\n    this->actor.world.pos.y = this->yOffset + (Math_SinS(this->bobPhase * (0x8000 / M_PI)) * this->bobHeight);\n    \n    // Face player naturally\n    Math_SmoothStepToS(&this->actor.shape.rot.y, \n        Math_Vec3f_Yaw(&this->actor.world.pos, &player->actor.world.pos),\n        2, 0x300, 0x20);\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnFloater_Draw(Actor* thisx, PlayState* play) {\n    EnFloater* this = (EnFloater*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n    gSPDisplayList(POLY_OPA_DISP++, gCubeModelDL);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Floater_InitVars = {\n    /**/ ACTOR_EN_FLOATER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnFloater),\n    /**/ EnFloater_Init,\n    /**/ EnFloater_Destroy,\n    /**/ EnFloater_Update, \n    /**/ EnFloater_Draw\n};"}
{"instruction": "Create a ai behavior system", "output": "{\n  \"instruction\": \"Implement a Boomerang throwing and returning mechanics with good code organization\",\n  \"input\": null,\n  \"output\": \"```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 returnTimer;\n    /* 0x0150 */ f32 flightSpeed;\n    /* 0x0154 */ Vec3f originalPos;\n    /* 0x0160 */ Actor* targetActor;\n    /* 0x0164 */ ColliderCylinder collider;\n} EnBoomerang;\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_ON | AT_TYPE_PLAYER,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000002, 0x00, 0x01 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_ON | TOUCH_SFX_WOOD,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 12, 20, 0, { 0, 0, 0 } },\n};\n\nvoid EnBoomerang_Init(Actor* thisx, PlayState* play) {\n    EnBoomerang* this = (EnBoomerang*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->timer = 0;\n    this->returnTimer = 0;\n    this->flightSpeed = 8.0f;\n    \n    this->originalPos = this->actor.world.pos;\n    this->targetActor = NULL;\n}\n\nvoid EnBoomerang_Destroy(Actor* thisx, PlayState* play) {\n    EnBoomerang* this = (EnBoomerang*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnBoomerang_Update(Actor* thisx, PlayState* play) {\n    EnBoomerang* this = (EnBoomerang*)thisx;\n    Player* player = GET_PLAYER(play);\n    Vec3f targetPos;\n    f32 distToTarget;\n    \n    this->timer++;\n    \n    if (this->timer >= 30) {\n        this->returnTimer++;\n        \n        // Return to player\n        targetPos = player->actor.world.pos;\n        targetPos.y += 30.0f;\n        \n        distToTarget = Math_Vec3f_DistXYZ(&this->actor.world.pos, &targetPos);\n        \n        if (distToTarget < 20.0f) {\n            Actor_Kill(&this->actor);\n            return;\n        }\n        \n        // Smoothly turn towards player\n        Math_SmoothStepToF(&this->actor.world.pos.x, targetPos.x, 0.3f, this->flightSpeed, 0.0f);\n        Math_SmoothStepToF(&this->actor.world.pos.y, targetPos.y, 0.3f, this->flightSpeed, 0.0f);\n        Math_SmoothStepToF(&this->actor.world.pos.z, targetPos.z, 0.3f, this->flightSpeed, 0.0f);\n    } else {\n        // Initial throw movement\n        this->actor.world.pos.x += Math_SinS(this->actor.world.rot.y) * this->flightSpeed;\n        this->actor.world.pos.z += Math_CosS(this->actor.world.rot.y) * this->flightSpeed;\n    }\n    \n    // Rotation for visual effect\n    this->actor.shape.rot.z += 0x800;\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnBoomerang_Draw(Actor* thisx, PlayState* play) {\n    EnBoomerang* this = (EnBoomerang*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    Matrix_Mult(&play->billboardMtxF, MTXMODE_APPLY);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n              \n    // Draw boomerang model\n    gSPDisplayList(POLY_OPA_DISP++, gBoomerangDL);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Boomerang_InitVars = {\n    /**/ ACTOR_EN_BOOMERANG,\n    /**/ ACTORCAT_MISC,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnBoomerang),\n    /**/ EnBoomerang_Init,\n    /**/ EnBoomerang_Destroy,\n    /**/ EnBoomerang_Update,\n    /**/ EnBoomerang_Draw\n};\n```\"}"}
{"instruction": "Create a actor creation system", "output": "{\n  \"instruction\": \"How would you implement a elemental altar that opens passages based on player inventory? with multiple states for dungeon progression using standard approaches\",\n  \"input\": null,\n  \"output\": \"```c\n// Altar that checks for specific items and opens passages\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 actionState;\n    /* 0x014E */ s16 timer;\n    /* 0x0150 */ ColliderCylinder collider;\n} EnAltar; // size = 0x19C\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000010, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 25, 80, 0, { 0, 0, 0 } },\n};\n\nvoid EnAltar_Init(Actor* thisx, PlayState* play) {\n    EnAltar* this = (EnAltar*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actionState = 0;\n    this->timer = 0;\n    \n    // Set initial switch flag if needed\n    if (Flags_GetSwitch(play, this->actor.params & 0x3F)) {\n        this->actionState = 2; // Already activated\n    }\n}\n\nvoid EnAltar_Destroy(Actor* thisx, PlayState* play) {\n    EnAltar* this = (EnAltar*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnAltar_Update(Actor* thisx, PlayState* play) {\n    EnAltar* this = (EnAltar*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    switch (this->actionState) {\n        case 0: // Waiting for player with correct items\n            if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 100.0f) {\n                // Check for required items (example: Fire Arrow + Bow)\n                if ((gSaveContext.inventory.items[SLOT_BOW] == ITEM_BOW) &&\n                    (gSaveContext.inventory.items[SLOT_ARROW_FIRE] == ITEM_ARROW_FIRE)) {\n                    this->actionState = 1;\n                    this->timer = 30;\n                }\n            }\n            break;\n            \n        case 1: // Activation sequence\n            this->timer--;\n            if (this->timer <= 0) {\n                // Set permanent switch flag\n                Flags_SetSwitch(play, this->actor.params & 0x3F);\n                this->actionState = 2;\n                \n                // Play activation sound\n                Audio_PlayActorSound2(&this->actor, NA_SE_EV_STONE_BOUND);\n            }\n            break;\n            \n        case 2: // Activated state\n            break;\n    }\n}\n\nvoid EnAltar_Draw(Actor* thisx, PlayState* play) {\n    EnAltar* this = (EnAltar*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    // Draw altar model based on state\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n              \n    if (this->actionState == 2) {\n        gSPDisplayList(POLY_OPA_DISP++, gAltarActivatedDL);\n    } else {\n        gSPDisplayList(POLY_OPA_DISP++, gAltarNormalDL);\n    }\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Altar_InitVars = {\n    /**/ ACTOR_EN_ALTAR,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_ALTAR,\n    /**/ sizeof(EnAltar),\n    /**/ EnAltar_Init,\n    /**/ EnAltar_Destroy,\n    /**/ EnAltar_Update,\n    /**/ EnAltar_Draw\n};\n```\"\n}"}
{"instruction": "Create a actor creation system", "output": "{\n  \"instruction\": \"Explain how to build a shadow assassin with the ability to coordinate attacks with other enemies with multiple interaction types in a fire temple environment using advanced rendering techniques\",\n  \"input\": null,\n  \"output\": \"```c\n// Shadow Assassin - Fire Temple Enemy\n// Uses authentic OoT patterns for enemy coordination and rendering\n\ntypedef enum {\n    /* 0x00 */ ASSASSIN_IDLE,\n    /* 0x01 */ ASSASSIN_STALK,\n    /* 0x02 */ ASSASSIN_ATTACK,\n    /* 0x03 */ ASSASSIN_RETREAT\n} AssassinState;\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ Vec3s jointTable[25];\n    /* 0x01F4 */ Vec3s morphTable[25];\n    /* 0x0258 */ s16 actionState;\n    /* 0x025A */ s16 attackTimer;\n    /* 0x025C */ s16 blendAlpha;\n    /* 0x025E */ s16 targetActor;\n    /* 0x0260 */ f32 attackDist;\n    /* 0x0264 */ ColliderCylinder collider;\n    /* 0x02B0 */ ColliderJntSph bodyCollider;\n    /* 0x02D0 */ ColliderJntSphElement bodyElements[2];\n} EnFireAssassin; // size = 0x0350\n\nvoid EnFireAssassin_Init(Actor* thisx, PlayState* play) {\n    EnFireAssassin* this = (EnFireAssassin*)thisx;\n    \n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 30.0f);\n    SkelAnime_InitFlex(play, &this->skelAnime, &gAssassinSkel, &gAssassinIdleAnim, \n                       this->jointTable, this->morphTable, 25);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Collider_InitJntSph(play, &this->bodyCollider);\n    Collider_SetJntSph(play, &this->bodyCollider, &this->actor, &sJntSphInit, this->bodyElements);\n    \n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\n    this->blendAlpha = 255;\n    this->actionState = ASSASSIN_IDLE;\n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnFireAssassin_UpdateTargeting(EnFireAssassin* this, PlayState* play) {\n    Actor* nearestEnemy = NULL;\n    f32 minDist = 500.0f;\n    \n    Actor* curActor = play->actorCtx.actorLists[ACTORCAT_ENEMY].head;\n    while (curActor != NULL) {\n        if (curActor != &this->actor && !(curActor->flags & ACTOR_FLAG_7)) {\n            f32 dist = Actor_WorldDistXZToActor(&this->actor, curActor);\n            if (dist < minDist) {\n                minDist = dist;\n                nearestEnemy = curActor;\n            }\n        }\n        curActor = curActor->next;\n    }\n    \n    if (nearestEnemy != NULL) {\n        this->targetActor = nearestEnemy->id;\n    }\n}\n\nvoid EnFireAssassin_Update(Actor* thisx, PlayState* play) {\n    EnFireAssassin* this = (EnFireAssassin*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 35.0f, 60.0f, 60.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    \n    SkelAnime_Update(&this->skelAnime);\n    \n    switch (this->actionState) {\n        case ASSASSIN_IDLE:\n            if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 200.0f) {\n                this->actionState = ASSASSIN_STALK;\n            }\n            break;\n            \n        case ASSASSIN_STALK:\n            EnFireAssassin_UpdateTargeting(this, play);\n            Math_SmoothStepToF(&this->actor.speedXZ, 8.0f, 0.3f, 1.0f, 0.0f);\n            this->blendAlpha = 128;\n            break;\n    }\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnFireAssassin_Draw(Actor* thisx, PlayState* play) {\n    EnFireAssassin* this = (EnFireAssassin*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    // Authentic shadow render\n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gDPSetEnvColor(POLY_OPA_DISP++, 255, 0, 0, this->blendAlpha);\n    \n    // Fire temple environment effect\n    Matrix_RotateY(BINANG_TO_RAD(this->actor.shape.rot.y), MTXMODE_APPLY);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n    \n    // Draw assassin model with authentic skelanime\n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                         this->skelAnime.dListCount, NULL, NULL, this);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_FireAssassin_InitVars = {\n    /**/ ACTOR_EN_FIRE_ASSASSIN,\n    /**/ ACTORCAT_ENEMY,\n    /**/ FLAGS,\n    /**/ OBJECT_ASSASSIN,\n    /**/ sizeof(EnFireAssassin),\n    /**/ EnFireAssassin_Init,\n    /**/ EnFireAssassin_Destroy,\n    /**/ EnFireAssassin_Update, \n    /**/ EnFireAssassin_Draw\n};\n```\"\n}"}
{"instruction": "Create a actor creation system", "output": "{\n  \"instruction\": \"Design a puzzle pedestal mechanism that generates force fields and barriers with multiple states for dungeon progression with complex mathematical calculations\",\n  \"input\": null,\n  \"output\": \"\n```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 activeState;\n    /* 0x014E */ s16 timer;\n    /* 0x0150 */ f32 barrierAlpha;\n    /* 0x0154 */ f32 pulseScale;\n    /* 0x0158 */ f32 rotationAngle;\n    /* 0x015C */ Vec3f barrierPos[4];\n    /* 0x018C */ ColliderCylinder collider;\n} EnBarrierPedestal;\n\nvoid EnBarrierPedestal_Init(Actor* thisx, PlayState* play) {\n    EnBarrierPedestal* this = (EnBarrierPedestal*)thisx;\n    s32 i;\n\n    Actor_SetScale(&this->actor, 0.1f);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->activeState = 0;\n    this->timer = 0;\n    this->barrierAlpha = 255.0f;\n    this->pulseScale = 1.0f;\n    this->rotationAngle = 0.0f;\n    \n    // Initialize barrier positions in cardinal directions\n    for (i = 0; i < 4; i++) {\n        this->barrierPos[i].x = this->actor.world.pos.x + (Math_SinS(i * 0x4000) * 100.0f);\n        this->barrierPos[i].y = this->actor.world.pos.y + 60.0f;\n        this->barrierPos[i].z = this->actor.world.pos.z + (Math_CosS(i * 0x4000) * 100.0f);\n    }\n}\n\nvoid EnBarrierPedestal_Destroy(Actor* thisx, PlayState* play) {\n    EnBarrierPedestal* this = (EnBarrierPedestal*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnBarrierPedestal_Update(Actor* thisx, PlayState* play) {\n    EnBarrierPedestal* this = (EnBarrierPedestal*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    // Pulse effect\n    this->pulseScale = 1.0f + (Math_SinS(this->timer * 0x800) * 0.1f);\n    this->rotationAngle += 0.1f;\n    \n    // Update barrier alpha based on state\n    if (this->activeState == 1) {\n        Math_ApproachF(&this->barrierAlpha, 0.0f, 0.3f, 10.0f);\n    } else {\n        Math_ApproachF(&this->barrierAlpha, 255.0f, 0.3f, 10.0f);\n    }\n    \n    // Check player interaction\n    if (Actor_WorldDistXYZToActor(&this->actor, &player->actor) < 100.0f) {\n        if (player->stateFlags1 & 0x20) { // Authentic OoT player interaction flag\n            this->activeState ^= 1;\n            Audio_PlayActorSound2(&this->actor, NA_SE_EV_STONE_BOUND);\n        }\n    }\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnBarrierPedestal_Draw(Actor* thisx, PlayState* play) {\n    EnBarrierPedestal* this = (EnBarrierPedestal*)thisx;\n    s32 i;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    // Draw pedestal\n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 100, 100, 255, 255);\n    Matrix_Push();\n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_Scale(0.1f, 0.1f, 0.1f, MTXMODE_APPLY);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__), \n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n    gSPDisplayList(POLY_OPA_DISP++, gPedestalDL);\n    Matrix_Pop();\n    \n    // Draw barriers\n    Gfx_SetupDL_25Xlu(play->state.gfxCtx);\n    for (i = 0; i < 4; i++) {\n        if (this->barrierAlpha > 0.0f) {\n            Matrix_Push();\n            Matrix_Translate(this->barrierPos[i].x, this->barrierPos[i].y, this->barrierPos[i].z, MTXMODE_NEW);\n            Matrix_RotateY(this->rotationAngle, MTXMODE_APPLY);\n            Matrix_Scale(this->pulseScale, 1.0f, this->pulseScale, MTXMODE_APPLY);\n            gDPSetPrimColor(POLY_XLU_DISP++, 0, 0, 0, 255, 255, (u8)this->barrierAlpha);\n            gSPMatrix(POLY_XLU_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n                     G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n            gSPDisplayList(POLY_XLU_DISP++, gBarrierDL);\n            Matrix_Pop();\n        }\n    }\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Barrier_Pedestal_InitVars = {\n    /**/ ACTOR_EN_BARRIER_PEDESTAL,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnBarrierPedestal),\n    /**/ EnBarrierPedestal_Init,\n    /**/ EnBarrierPedestal_Destroy,\n    /**/ EnBarrierPedestal_Update,\n    /**/ EnBarrierPedestal_Draw\n};\n```\n\"}"}
{"instruction": "Create a debugging help system", "output": "{\n  \"instruction\": \"Make a debugging help that follows OoT decompilation standards implementing core requirements\",\n  \"input\": null,\n  \"output\": \"// Authentic debug helper based on OoT decompilation patterns\n#include \\\"z_debug.h\\\"\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 debugState;\n    /* 0x0150 */ f32 debugScale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnDebugHelper; // size = 0x1A0\n\nvoid EnDebugHelper_Init(Actor* thisx, PlayState* play) {\n    EnDebugHelper* this = (EnDebugHelper*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.focus.pos = this->actor.world.pos;\n    Actor_SetScale(&this->actor, 0.01f);\n    \n    this->debugState = 0;\n    this->timer = 0;\n    this->debugScale = 1.0f;\n}\n\nvoid EnDebugHelper_Destroy(Actor* thisx, PlayState* play) {\n    EnDebugHelper* this = (EnDebugHelper*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnDebugHelper_Update(Actor* thisx, PlayState* play) {\n    EnDebugHelper* this = (EnDebugHelper*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    // Debug distance check to player\n    f32 dist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    if (dist < 100.0f) {\n        // Print debug info when player is nearby\n        osSyncPrintf(\\\"Debug Helper: Distance to player = %f\\\\n\\\", dist);\n        osSyncPrintf(\\\"Debug Helper: Timer = %d\\\\n\\\", this->timer);\n        osSyncPrintf(\\\"Debug Helper: State = %d\\\\n\\\", this->debugState);\n    }\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 0.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnDebugHelper_Draw(Actor* thisx, PlayState* play) {\n    EnDebugHelper* this = (EnDebugHelper*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 255, 255, 255, 255);\n    Matrix_Push();\n    Matrix_Scale(this->debugScale, this->debugScale, this->debugScale, MTXMODE_APPLY);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__), \n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n    Matrix_Pop();\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_DebugHelper_InitVars = {\n    /**/ ACTOR_EN_DEBUGHELPER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnDebugHelper),\n    /**/ EnDebugHelper_Init,\n    /**/ EnDebugHelper_Destroy, \n    /**/ EnDebugHelper_Update,\n    /**/ EnDebugHelper_Draw\n};\"\n}"}
{"instruction": "Create a actor creation system", "output": "{\n  \"instruction\": \"Make a Shadow Temple darkness and light mechanics with appropriate documentation\",\n  \"input\": null,\n  \"output\": \"/**\n * Shadow Temple Darkness Effect Actor\n * Handles darkness mechanics and light source interactions\n */\n\n#include \\\"z_en_shadow_dark.h\\\"\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ f32 darknessFactor;\n    /* 0x0150 */ f32 targetDarkness;\n    /* 0x0154 */ f32 lightRadius;\n    /* 0x0158 */ s16 lightTimer;\n    /* 0x015A */ s16 effectTimer;\n    /* 0x015C */ ColliderCylinder collider;\n} EnShadowDark; // size = 0x1A8\n\nvoid EnShadowDark_Init(Actor* thisx, PlayState* play) {\n    EnShadowDark* this = (EnShadowDark*)thisx;\n    \n    Actor_SetScale(&this->actor, 1.0f);\n    this->darknessFactor = 1.0f;\n    this->targetDarkness = 1.0f;\n    this->lightRadius = 100.0f;\n    this->lightTimer = 0;\n    \n    // Initialize collision for light source detection\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n}\n\nvoid EnShadowDark_Destroy(Actor* thisx, PlayState* play) {\n    EnShadowDark* this = (EnShadowDark*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnShadowDark_Update(Actor* thisx, PlayState* play) {\n    EnShadowDark* this = (EnShadowDark*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->effectTimer++;\n    \n    // Check if player has light source equipped (e.g. Fire Arrow)\n    if (gSaveContext.inventory.items[SLOT_BOW] == ITEM_BOW_FIRE) {\n        f32 dist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n        if (dist < this->lightRadius) {\n            this->targetDarkness = 0.0f;\n            this->lightTimer = 30;\n        }\n    }\n    \n    // Update darkness fade\n    if (this->lightTimer > 0) {\n        this->lightTimer--;\n        if (this->lightTimer == 0) {\n            this->targetDarkness = 1.0f;\n        }\n    }\n    \n    // Smooth darkness transition\n    Math_SmoothStepToF(&this->darknessFactor, this->targetDarkness, 0.1f, 0.2f, 0.01f);\n    \n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnShadowDark_Draw(Actor* thisx, PlayState* play) {\n    EnShadowDark* this = (EnShadowDark*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    // Set up dark overlay\n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 0, 0, 0, (u8)(255.0f * this->darknessFactor));\n    gDPFillRectangle(POLY_OPA_DISP++, 0, 0, SCREEN_WIDTH-1, SCREEN_HEIGHT-1);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_ShadowDark_InitVars = {\n    /**/ ACTOR_EN_SHADOW_DARK,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnShadowDark),\n    /**/ EnShadowDark_Init,\n    /**/ EnShadowDark_Destroy,\n    /**/ EnShadowDark_Update,\n    /**/ EnShadowDark_Draw\n};\n\"\n}"}
{"instruction": "Create a feature implementation system", "output": "{\n  \"instruction\": \"Implement a complex feature implementation system for enhanced gameplay using memory-safe practices\",\n  \"input\": null,\n  \"output\": \"\n```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState; \n    /* 0x0150 */ f32 hoverHeight;\n    /* 0x0154 */ f32 oscSpeed;\n    /* 0x0158 */ Vec3f targetPos;\n    /* 0x0164 */ ColliderCylinder collider;\n    /* 0x01B0 */ SkelAnime skelAnime;\n    /* 0x01F4 */ Vec3s jointTable[20];\n    /* 0x0244 */ Vec3s morphTable[20];\n} EnFloatingPlatform;\n\nvoid EnFloatingPlatform_Init(Actor* thisx, PlayState* play) {\n    EnFloatingPlatform* this = (EnFloatingPlatform*)thisx;\n    \n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 6.0f);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    SkelAnime_InitFlex(play, &this->skelAnime, &gPlatformSkel, &gPlatformIdleAnim, \n                       this->jointTable, this->morphTable, 20);\n    \n    this->hoverHeight = this->actor.world.pos.y;\n    this->oscSpeed = 0.05f;\n    this->targetPos = this->actor.world.pos;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnFloatingPlatform_Update(Actor* thisx, PlayState* play) {\n    EnFloatingPlatform* this = (EnFloatingPlatform*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    // Hover oscillation\n    this->actor.world.pos.y = this->hoverHeight + (Math_SinS(this->timer * 0x800) * 5.0f);\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Check if player is on platform\n    if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 80.0f &&\n        fabsf(player->actor.world.pos.y - this->actor.world.pos.y) < 20.0f) {\n        \n        // Move player with platform\n        Math_ApproachF(&player->actor.world.pos.y, \n                      this->actor.world.pos.y + 40.0f, 1.0f, 5.0f);\n    }\n    \n    // Update skeleton animation\n    SkelAnime_Update(&this->skelAnime);\n}\n\nvoid EnFloatingPlatform_Draw(Actor* thisx, PlayState* play) {\n    EnFloatingPlatform* this = (EnFloatingPlatform*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, \n                    this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_RotateY(this->actor.world.rot.y * (M_PI / 32768.0f), MTXMODE_APPLY);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, \n                this->actor.scale.z, MTXMODE_APPLY);\n    \n    if (Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__)) {\n        SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                             this->skelAnime.dListCount, NULL, NULL, this);\n    }\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile EnFloatingPlatform_Profile = {\n    /**/ ACTOR_EN_FLOATING_PLATFORM,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_PLATFORM,\n    /**/ sizeof(EnFloatingPlatform),\n    /**/ EnFloatingPlatform_Init,\n    /**/ Actor_Destroy,\n    /**/ EnFloatingPlatform_Update, \n    /**/ EnFloatingPlatform_Draw\n};\n```\n\"}"}
{"instruction": "Create a puzzle system system", "output": "{\n  \"instruction\": \"Build a crystal mechanism object that opens passages based on player inventory when activated using interconnected systems with straightforward logic\",\n  \"input\": null,\n  \"output\": \"\n```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 actionState;\n    /* 0x014E */ s16 timer;\n    /* 0x0150 */ f32 crystalScale;\n    /* 0x0154 */ f32 glowIntensity;\n    /* 0x0158 */ ColliderCylinder collider;\n} EnCrystalSwitch; // size = 0x1A4\n\nvoid EnCrystalSwitch_Init(Actor* thisx, PlayState* play) {\n    EnCrystalSwitch* this = (EnCrystalSwitch*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.1f);\n    this->crystalScale = 1.0f;\n    this->glowIntensity = 0.0f;\n    this->actionState = 0;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\n    this->collider.dim.radius = 20;\n    this->collider.dim.height = 50;\n}\n\nvoid EnCrystalSwitch_Update(Actor* thisx, PlayState* play) {\n    EnCrystalSwitch* this = (EnCrystalSwitch*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    if (this->actionState == 0) {\n        // Check if player has bow and is near\n        if (gSaveContext.inventory.items[SLOT_BOW] != ITEM_NONE) {\n            if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 200.0f) {\n                if (this->collider.base.acFlags & AC_HIT) {\n                    this->actionState = 1;\n                    this->timer = 30;\n                    Audio_PlayActorSound2(&this->actor, NA_SE_SY_CORRECT_CHIME);\n                }\n            }\n        }\n        \n        this->glowIntensity = 0.0f;\n        this->crystalScale = 1.0f;\n        \n    } else {\n        this->timer--;\n        Math_SmoothStepToF(&this->glowIntensity, 1.0f, 0.2f, 0.3f, 0.1f);\n        Math_SmoothStepToF(&this->crystalScale, 1.2f, 0.2f, 0.1f, 0.01f);\n        \n        if (this->timer <= 0) {\n            this->actionState = 0;\n        }\n    }\n    \n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnCrystalSwitch_Draw(Actor* thisx, PlayState* play) {\n    EnCrystalSwitch* this = (EnCrystalSwitch*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Push();\n    Matrix_Scale(this->crystalScale, this->crystalScale, this->crystalScale, MTXMODE_APPLY);\n    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, \n                    (s32)(255 * this->glowIntensity),\n                    (s32)(100 + (155 * this->glowIntensity)),\n                    (s32)(255 * this->glowIntensity), 255);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_MODELVIEW | G_MTX_LOAD);\n    gSPDisplayList(POLY_OPA_DISP++, gCrystalSwitchDL);\n    \n    Matrix_Pop();\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Crystal_Switch_InitVars = {\n    /**/ ACTOR_EN_CRYSTAL_SWITCH,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnCrystalSwitch),\n    /**/ EnCrystalSwitch_Init,\n    /**/ EnCrystalSwitch_Destroy,\n    /**/ EnCrystalSwitch_Update,\n    /**/ EnCrystalSwitch_Draw\n};\n```\n\"}"}
{"instruction": "Create a actor creation system", "output": "{\n  \"instruction\": \"Design a ancient statue mechanism that opens passages based on player inventory with complex sequences with proper error handling\",\n  \"input\": null,\n  \"output\": \"```c\n// Statue mechanism that checks inventory sequence and opens passages\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 actionState;\n    /* 0x014E */ s16 timer;\n    /* 0x0150 */ s16 sequenceIndex;\n    /* 0x0152 */ s16 checkDelay;\n    /* 0x0154 */ ColliderCylinder collider;\n    /* 0x01A0 */ f32 openAmount;\n    /* 0x01A4 */ Vec3f doorOffset;\n} EnStatueDoor; // size = 0x1B0\n\n// Required item sequence checks\nstatic const u8 sRequiredSequence[] = {\n    ITEM_FAIRY_SLINGSHOT,\n    ITEM_BOOMERANG, \n    ITEM_HOOKSHOT,\n    ITEM_BOW\n};\n\nvoid EnStatueDoor_Init(Actor* thisx, PlayState* play) {\n    EnStatueDoor* this = (EnStatueDoor*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    \n    // Initialize collision for interaction\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, \n        &(ColliderCylinderInit){\n            .base = { .colType = COLTYPE_NONE },\n            .dim = { .radius = 30, .height = 100 },\n            .info = { .bumperFlags = BUMP_ON }\n        });\n        \n    this->actionState = 0;\n    this->sequenceIndex = 0;\n    this->openAmount = 0.0f;\n    this->checkDelay = 0;\n    \n    // Set door offset relative to statue\n    this->doorOffset.x = 0.0f;\n    this->doorOffset.y = 60.0f; \n    this->doorOffset.z = 100.0f;\n}\n\nvoid EnStatueDoor_Destroy(Actor* thisx, PlayState* play) {\n    EnStatueDoor* this = (EnStatueDoor*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnStatueDoor_Update(Actor* thisx, PlayState* play) {\n    EnStatueDoor* this = (EnStatueDoor*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    if (this->checkDelay > 0) {\n        this->checkDelay--;\n    }\n    \n    switch(this->actionState) {\n        case 0: // Waiting for sequence\n            if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 100.0f) {\n                \n                // Only check sequence when not on cooldown\n                if (this->checkDelay == 0) {\n                    \n                    // Check current sequence item\n                    if (gSaveContext.inventory.items[SLOT_BOW + this->sequenceIndex] \n                        == sRequiredSequence[this->sequenceIndex]) {\n                        \n                        this->sequenceIndex++;\n                        Audio_PlayActorSound2(&this->actor, NA_SE_EV_STONE_BOUND);\n                        \n                        // Completed sequence\n                        if (this->sequenceIndex >= ARRAY_COUNT(sRequiredSequence)) {\n                            this->actionState = 1;\n                            this->timer = 0;\n                        }\n                        \n                    } else {\n                        // Wrong sequence - reset\n                        this->sequenceIndex = 0;\n                        this->checkDelay = 30;\n                        Audio_PlayActorSound2(&this->actor, NA_SE_EN_STAL_DAMAGE);\n                    }\n                }\n            }\n            break;\n            \n        case 1: // Opening door\n            Math_SmoothStepToF(&this->openAmount, 1.0f, 0.1f, 0.02f, 0.0f);\n            \n            if (this->openAmount >= 0.99f) {\n                this->actionState = 2;\n            }\n            break;\n            \n        case 2: // Fully open\n            break;\n    }\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnStatueDoor_Draw(Actor* thisx, PlayState* play) {\n    EnStatueDoor* this = (EnStatueDoor*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    // Draw base statue\n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n    gSPDisplayList(POLY_OPA_DISP++, gStatueDL);\n    \n    // Draw door with offset and opening animation\n    Matrix_Translate(this->doorOffset.x, \n                    this->doorOffset.y - (this->openAmount * 100.0f),\n                    this->doorOffset.z, MTXMODE_APPLY);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n    gSPDisplayList(POLY_OPA_DISP++, gDoorDL);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_StatueDoor_InitVars = {\n    /**/ ACTOR_EN_STATUE_DOOR,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnStatueDoor),\n    /**/ EnStatueDoor_Init,\n    /**/ EnStatueDoor_Destroy,\n    /**/ EnStatueDoor_Update,\n    /**/ EnStatueDoor_Draw\n};\n```\"\n}"}
{"instruction": "Create a Song of Time effect that advances time using efficient algorithms", "output": "// EnTimeEffect actor for Song of Time visual effect\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 alpha;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ Vec3f effectPos[16];\n    /* 0x01F4 */ Color_RGBA8 primColor;\n    /* 0x01F8 */ Color_RGBA8 envColor;\n} EnTimeEffect; // size = 0x01FC\n\nvoid EnTimeEffect_Init(Actor* thisx, PlayState* play) {\n    EnTimeEffect* this = (EnTimeEffect*)thisx;\n    Player* player = GET_PLAYER(play);\n    s32 i;\n\n    Actor_SetScale(&this->actor, 0.0f);\n    this->timer = 0;\n    this->alpha = 255;\n    this->scale = 0.1f;\n\n    // Initialize effect positions around player\n    for (i = 0; i < 16; i++) {\n        this->effectPos[i].x = player->actor.world.pos.x + Math_SinS(i * 0x1000) * 30.0f;\n        this->effectPos[i].y = player->actor.world.pos.y + 40.0f;\n        this->effectPos[i].z = player->actor.world.pos.z + Math_CosS(i * 0x1000) * 30.0f;\n    }\n\n    this->primColor.r = 100;\n    this->primColor.g = 100; \n    this->primColor.b = 255;\n    this->primColor.a = 255;\n    \n    this->envColor.r = 255;\n    this->envColor.g = 255;\n    this->envColor.b = 255;\n    this->envColor.a = 255;\n}\n\nvoid EnTimeEffect_Destroy(Actor* thisx, PlayState* play) {\n}\n\nvoid EnTimeEffect_Update(Actor* thisx, PlayState* play) {\n    EnTimeEffect* this = (EnTimeEffect*)thisx;\n    s32 i;\n\n    this->timer++;\n\n    if (this->timer >= 60) {\n        Actor_Kill(&this->actor);\n        gSaveContext.dayTime += 0x4000; // Advance time\n        return;\n    }\n\n    // Update effect positions\n    for (i = 0; i < 16; i++) {\n        this->effectPos[i].y += 2.0f;\n        this->effectPos[i].x += Math_SinS(this->timer * 0x800 + i * 0x1000) * 1.0f;\n        this->effectPos[i].z += Math_CosS(this->timer * 0x800 + i * 0x1000) * 1.0f;\n    }\n\n    this->alpha = (60 - this->timer) * 4;\n    if (this->alpha > 255) {\n        this->alpha = 255;\n    }\n\n    this->scale += 0.001f;\n}\n\nvoid EnTimeEffect_Draw(Actor* thisx, PlayState* play) {\n    EnTimeEffect* this = (EnTimeEffect*)thisx;\n    s32 i;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    // Draw sparkle effects\n    for (i = 0; i < 16; i++) {\n        Matrix_Translate(this->effectPos[i].x, this->effectPos[i].y, this->effectPos[i].z, MTXMODE_NEW);\n        Matrix_Scale(this->scale, this->scale, this->scale, MTXMODE_APPLY);\n        \n        gDPPipeSync(POLY_XLU_DISP++);\n        gDPSetPrimColor(POLY_XLU_DISP++, 0, 0, \n            this->primColor.r, this->primColor.g, this->primColor.b, this->alpha);\n        gDPSetEnvColor(POLY_XLU_DISP++,\n            this->envColor.r, this->envColor.g, this->envColor.b, 128);\n        \n        Matrix_ReplaceRotation(&play->billboardMtxF);\n        gSPMatrix(POLY_XLU_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n                  G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n        gSPDisplayList(POLY_XLU_DISP++, gEffSparklesDL);\n    }\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_TimeEffect_InitVars = {\n    /**/ ACTOR_EN_TIME_EFFECT,\n    /**/ ACTORCAT_MISC,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnTimeEffect),\n    /**/ EnTimeEffect_Init,\n    /**/ EnTimeEffect_Destroy,\n    /**/ EnTimeEffect_Update, \n    /**/ EnTimeEffect_Draw\n};"}
{"instruction": "Create a interaction system system", "output": "{\n  \"instruction\": \"Implement a reputation system that affects NPC interactions using memory-safe practices\",\n  \"input\": null,\n  \"output\": \"// Reputation system using save context flags and NPC actor\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 reputationLevel;\n    /* 0x014E */ s16 talkState;\n    /* 0x0150 */ ColliderCylinder collider;\n} EnReputation;\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000004, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 60, 0, { 0, 0, 0 } },\n};\n\nvoid EnReputation_Init(Actor* thisx, PlayState* play) {\n    EnReputation* this = (EnReputation*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    \n    this->reputationLevel = (gSaveContext.eventChkInf[7] & 0xF); // Use 4 bits for rep\n    this->talkState = 0;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.targetMode = 6;\n    this->actor.flags |= ACTOR_FLAG_0;\n}\n\nvoid EnReputation_UpdateReputation(EnReputation* this) {\n    s16 newRep = this->reputationLevel;\n    \n    // Update reputation based on quest flags\n    if (gSaveContext.questItems & (1 << QUEST_MEDALLION_FOREST)) {\n        newRep++;\n    }\n    if (gSaveContext.questItems & (1 << QUEST_MEDALLION_FIRE)) {\n        newRep++;\n    }\n    \n    // Clamp reputation between 0-15 (4 bits)\n    if (newRep > 15) {\n        newRep = 15;\n    }\n    \n    // Store in event check info flags\n    gSaveContext.eventChkInf[7] = (gSaveContext.eventChkInf[7] & ~0xF) | (newRep & 0xF);\n    this->reputationLevel = newRep;\n}\n\nvoid EnReputation_Update(Actor* thisx, PlayState* play) {\n    EnReputation* this = (EnReputation*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (Actor_ProcessTalkRequest(&this->actor, play)) {\n        // Different dialog based on reputation\n        if (this->reputationLevel < 5) {\n            Message_StartTextbox(play, 0x1000, NULL); // Low rep dialog\n        } else if (this->reputationLevel < 10) {\n            Message_StartTextbox(play, 0x1001, NULL); // Med rep dialog  \n        } else {\n            Message_StartTextbox(play, 0x1002, NULL); // High rep dialog\n        }\n        this->talkState = 1;\n    }\n    \n    // Update reputation periodically\n    if ((play->gameplayFrames % 32) == 0) {\n        EnReputation_UpdateReputation(this);\n    }\n}\n\nconst ActorProfile En_Reputation_InitVars = {\n    /**/ ACTOR_EN_REPUTATION,\n    /**/ ACTORCAT_NPC,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnReputation),\n    /**/ EnReputation_Init,\n    /**/ Actor_Destroy,\n    /**/ EnReputation_Update,\n    /**/ NULL\n};\"\n}"}
{"instruction": "Create a actor creation system", "output": "{\n  \"instruction\": \"Build a energy conduit object that creates temporary bridges across gaps when activated with multiple states with appropriate documentation\",\n  \"input\": null,\n  \"output\": \"/**\n * Energy Conduit - Creates temporary energy bridges when activated\n */\n\n#include \\\"z_en_energy_conduit.h\\\"\n\n#define FLAGS (ACTOR_FLAG_0 | ACTOR_FLAG_4)\n\ntypedef enum {\n    /* 0 */ CONDUIT_INACTIVE,\n    /* 1 */ CONDUIT_CHARGING,\n    /* 2 */ CONDUIT_ACTIVE,\n    /* 3 */ CONDUIT_FADING\n} EnEnergyConduitState;\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 activeTime;\n    /* 0x0150 */ f32 bridgeScale;\n    /* 0x0154 */ f32 chargeLevel;\n    /* 0x0158 */ Vec3f bridgeStart;\n    /* 0x0164 */ Vec3f bridgeEnd;\n    /* 0x0170 */ ColliderCylinder collider;\n    /* 0x01BC */ EnEnergyConduitState state;\n} EnEnergyConduit; // size = 0x01C0\n\nvoid EnEnergyConduit_Init(Actor* thisx, PlayState* play) {\n    EnEnergyConduit* this = (EnEnergyConduit*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.1f);\n    \n    this->bridgeScale = 0.0f;\n    this->chargeLevel = 0.0f;\n    this->timer = 0;\n    this->activeTime = 200;\n    this->state = CONDUIT_INACTIVE;\n    \n    // Set bridge endpoints\n    this->bridgeStart = this->actor.world.pos;\n    this->bridgeEnd = this->actor.world.pos;\n    this->bridgeEnd.z += 300.0f;\n    \n    // Initialize collision cylinder for activation\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, \n        &(ColliderCylinderInit){\n            .base = { .colType = COLTYPE_NONE },\n            .dim = { .radius = 25, .height = 50 },\n            .info = { .bumperFlags = BUMP_ON }\n        });\n}\n\nvoid EnEnergyConduit_Destroy(Actor* thisx, PlayState* play) {\n    EnEnergyConduit* this = (EnEnergyConduit*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnEnergyConduit_Update(Actor* thisx, PlayState* play) {\n    EnEnergyConduit* this = (EnEnergyConduit*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    switch(this->state) {\n        case CONDUIT_INACTIVE:\n            if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 100.0f) {\n                this->state = CONDUIT_CHARGING;\n                Audio_PlayActorSound2(&this->actor, NA_SE_EV_CHARGE_UP);\n            }\n            break;\n            \n        case CONDUIT_CHARGING:\n            Math_SmoothStepToF(&this->chargeLevel, 1.0f, 0.1f, 0.05f, 0.01f);\n            if (this->chargeLevel >= 0.99f) {\n                this->state = CONDUIT_ACTIVE;\n                Audio_PlayActorSound2(&this->actor, NA_SE_EV_BRIDGE_OPEN);\n            }\n            break;\n            \n        case CONDUIT_ACTIVE:\n            Math_SmoothStepToF(&this->bridgeScale, 1.0f, 0.1f, 0.1f, 0.01f);\n            \n            if (this->timer++ > this->activeTime) {\n                this->state = CONDUIT_FADING;\n                Audio_PlayActorSound2(&this->actor, NA_SE_EV_BRIDGE_CLOSE);\n            }\n            break;\n            \n        case CONDUIT_FADING:\n            Math_SmoothStepToF(&this->bridgeScale, 0.0f, 0.1f, 0.05f, 0.01f);\n            Math_SmoothStepToF(&this->chargeLevel, 0.0f, 0.1f, 0.05f, 0.01f);\n            \n            if (this->bridgeScale < 0.01f) {\n                this->state = CONDUIT_INACTIVE;\n                this->timer = 0;\n            }\n            break;\n    }\n}\n\nvoid EnEnergyConduit_Draw(Actor* thisx, PlayState* play) {\n    EnEnergyConduit* this = (EnEnergyConduit*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    // Draw base conduit\n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 100, 100, 255, 255);\n    Matrix_Push();\n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y,\n        this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, \n        this->actor.scale.z, MTXMODE_APPLY);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n        G_MTX_MODELVIEW | G_MTX_LOAD);\n    gSPDisplayList(POLY_OPA_DISP++, gCubeEdgesDL);\n    Matrix_Pop();\n    \n    // Draw energy bridge if active\n    if (this->bridgeScale > 0.0f) {\n        Gfx_SetupDL_25Xlu(play->state.gfxCtx);\n        gDPSetPrimColor(POLY_XLU_DISP++, 0, 0, 80, 100, 255, \n            (s8)(this->bridgeScale * 128.0f));\n        \n        Matrix_Translate(this->bridgeStart.x, this->bridgeStart.y,\n            this->bridgeStart.z, MTXMODE_NEW);\n        Matrix_Scale(5.0f * this->bridgeScale, 0.5f, \n            Actor_WorldDistXZToPoint(&this->actor, &this->bridgeEnd) / 100.0f, \n            MTXMODE_APPLY);\n        \n        gSPMatrix(POLY_XLU_DISP++, \n            Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n            G_MTX_MODELVIEW | G_MTX_LOAD);\n        gSPDisplayList(POLY_XLU_DISP++, gCubeDL);\n    }\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Energy_Conduit_InitVars = {\n    /**/ ACTOR_EN_ENERGY_CONDUIT,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnEnergyConduit),\n    /**/ EnEnergyConduit_Init,\n    /**/ EnEnergyConduit_Destroy,\n    /**/ EnEnergyConduit_Update,\n    /**/ EnEnergyConduit_Draw\n};\"\n}"}
{"instruction": "Create a animation system system", "output": "{\n  \"instruction\": \"Create a facial animation system for NPC expressions with basic debugging support\",\n  \"input\": null,\n  \"output\": \"// EnFace.h\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 expressionState;\n    /* 0x0150 */ s16 blinkTimer;\n    /* 0x0152 */ s16 eyeTextureIndex;\n    /* 0x0154 */ s16 mouthTextureIndex;\n    /* 0x0156 */ s16 debugMode;\n    /* 0x0158 */ SkelAnime skelAnime;\n    /* 0x019C */ Vec3s jointTable[20];\n    /* 0x01F4 */ Vec3s morphTable[20];\n} EnFace;\n\n// EnFace.c\n#include \\\"z_en_face.h\\\"\n\n#define FACE_EXPRESSION_NEUTRAL 0\n#define FACE_EXPRESSION_HAPPY   1\n#define FACE_EXPRESSION_SAD     2\n#define FACE_EXPRESSION_ANGRY   3\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_NONE,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000000, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_NONE,\n        OCELEM_ON,\n    },\n    { 20, 40, 0, { 0, 0, 0 } },\n};\n\nvoid EnFace_Init(Actor* thisx, PlayState* play) {\n    EnFace* this = (EnFace*)thisx;\n    \n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 20.0f);\n    SkelAnime_InitFlex(play, &this->skelAnime, &gNPCHeadSkel, &gNPCHeadIdleAnim, \n                       this->jointTable, this->morphTable, 20);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->expressionState = FACE_EXPRESSION_NEUTRAL;\n    this->blinkTimer = (s16)(Rand_ZeroFloat(60.0f) + 20.0f);\n    this->eyeTextureIndex = 0;\n    this->mouthTextureIndex = 0;\n    this->debugMode = 0;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnFace_UpdateExpression(EnFace* this) {\n    if (this->blinkTimer > 0) {\n        this->blinkTimer--;\n    } else {\n        this->eyeTextureIndex = (this->eyeTextureIndex + 1) % 3;\n        this->blinkTimer = (s16)(Rand_ZeroFloat(60.0f) + 20.0f);\n    }\n    \n    switch (this->expressionState) {\n        case FACE_EXPRESSION_NEUTRAL:\n            this->mouthTextureIndex = 0;\n            break;\n        case FACE_EXPRESSION_HAPPY:\n            this->mouthTextureIndex = 1;\n            break;\n        case FACE_EXPRESSION_SAD:\n            this->mouthTextureIndex = 2;\n            break;\n        case FACE_EXPRESSION_ANGRY:\n            this->mouthTextureIndex = 3;\n            break;\n    }\n}\n\nvoid EnFace_Update(Actor* thisx, PlayState* play) {\n    EnFace* this = (EnFace*)thisx;\n    \n    if (this->debugMode) {\n        osSyncPrintf(VT_FGCOL(GREEN) \\\"Expression: %d Eye: %d Mouth: %d\\\\n\\\" VT_RST,\n                     this->expressionState, this->eyeTextureIndex, this->mouthTextureIndex);\n    }\n    \n    SkelAnime_Update(&this->skelAnime);\n    EnFace_UpdateExpression(this);\n}\n\nvoid EnFace_Draw(Actor* thisx, PlayState* play) {\n    EnFace* this = (EnFace*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    gSPSegment(POLY_OPA_DISP++, 0x08, \n               SEGMENTED_TO_VIRTUAL(sEyeTextures[this->eyeTextureIndex]));\n    gSPSegment(POLY_OPA_DISP++, 0x09, \n               SEGMENTED_TO_VIRTUAL(sMouthTextures[this->mouthTextureIndex]));\n    \n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                          this->skelAnime.dListCount, NULL, NULL, this);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Face_InitVars = {\n    /**/ ACTOR_EN_FACE,\n    /**/ ACTORCAT_NPC,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnFace),\n    /**/ EnFace_Init,\n    /**/ EnFace_Destroy,\n    /**/ EnFace_Update,\n    /**/ EnFace_Draw\n};\"\n}"}
{"instruction": "Create a collision system system", "output": "{\n  \"instruction\": \"Create a dynamic collision detection system for moving objects implementing sophisticated AI behaviors\",\n  \"input\": null,\n  \"output\": \"typedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 detectionRange;\n    /* 0x0154 */ Vec3f targetPos;\n    /* 0x0160 */ Vec3f initialPos;\n    /* 0x16C */ SkelAnime skelAnime;\n    /* 0x1B0 */ Vec3s jointTable[20];\n    /* 0x1F8 */ Vec3s morphTable[20];\n    /* 0x240 */ ColliderCylinder collider;\n} EnPatroller; // size = 0x28C\n\nvoid EnPatroller_Init(Actor* thisx, PlayState* play) {\n    EnPatroller* this = (EnPatroller*)thisx;\n    \n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 30.0f);\n    SkelAnime_InitFlex(play, &this->skelAnime, &gEnemySkel, &gEnemyAnim, this->jointTable, \n                       this->morphTable, 20);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->detectionRange = 200.0f;\n    this->initialPos = this->actor.world.pos;\n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnPatroller_Update(Actor* thisx, PlayState* play) {\n    EnPatroller* this = (EnPatroller*)thisx;\n    Player* player = GET_PLAYER(play);\n    f32 dx, dz;\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 30.0f, 30.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    \n    switch(this->actionState) {\n        case 0: // Patrol state\n            this->timer++;\n            if (this->timer > 60) {\n                this->timer = 0;\n                this->targetPos.x = this->initialPos.x + (Rand_ZeroOne() - 0.5f) * 100.0f;\n                this->targetPos.z = this->initialPos.z + (Rand_ZeroOne() - 0.5f) * 100.0f;\n            }\n            \n            // Check player distance\n            if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < this->detectionRange) {\n                this->actionState = 1;\n            }\n            break;\n            \n        case 1: // Chase state\n            this->targetPos = player->actor.world.pos;\n            break;\n    }\n    \n    // Move toward target position\n    dx = this->targetPos.x - this->actor.world.pos.x;\n    dz = this->targetPos.z - this->actor.world.pos.z;\n    Math_SmoothStepToF(&this->actor.world.pos.x, this->targetPos.x, 0.3f, 3.0f, 0.0f);\n    Math_SmoothStepToF(&this->actor.world.pos.z, this->targetPos.z, 0.3f, 3.0f, 0.0f);\n    this->actor.shape.rot.y = Math_Atan2S(dz, dx);\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnPatroller_Draw(Actor* thisx, PlayState* play) {\n    EnPatroller* this = (EnPatroller*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                          this->skelAnime.dListCount, NULL, NULL, this);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Patroller_InitVars = {\n    /**/ ACTOR_EN_PATROLLER,\n    /**/ ACTORCAT_ENEMY,\n    /**/ FLAGS,\n    /**/ OBJECT_ENEMY,\n    /**/ sizeof(EnPatroller),\n    /**/ EnPatroller_Init,\n    /**/ EnPatroller_Destroy,\n    /**/ EnPatroller_Update,\n    /**/ EnPatroller_Draw\n};\"\n}"}
{"instruction": "Create a puzzle system system", "output": "{\n  \"instruction\": \"How would you implement a gravity well that opens passages based on player inventory? for puzzle rooms implementing standard patterns\",\n  \"input\": null,\n  \"output\": \"```c\n// Gravity well that checks inventory and opens passages\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 activeState;\n    /* 0x0150 */ f32 pullRadius;\n    /* 0x0154 */ f32 pullStrength;\n    /* 0x0158 */ ColliderCylinder collider;\n    /* 0x01A4 */ Vec3f effectPos[8];\n    /* 0x01DC */ s16 effectTimer;\n} EnGravityWell; // size = 0x1E0\n\nvoid EnGravityWell_Init(Actor* thisx, PlayState* play) {\n    EnGravityWell* this = (EnGravityWell*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->pullRadius = 200.0f;\n    this->pullStrength = 5.0f;\n    this->activeState = 0;\n    this->effectTimer = 0;\n    \n    Actor_SetScale(&this->actor, 0.1f);\n}\n\nvoid EnGravityWell_Update(Actor* thisx, PlayState* play) {\n    EnGravityWell* this = (EnGravityWell*)thisx;\n    Player* player = GET_PLAYER(play);\n    Vec3f pullDir;\n    f32 dist;\n    s32 i;\n\n    this->effectTimer++;\n    \n    // Check if player has required items to activate\n    if (gSaveContext.inventory.items[SLOT_BOW] != ITEM_NONE &&\n        gSaveContext.inventory.items[SLOT_HOOKSHOT] != ITEM_NONE) {\n        this->activeState = 1;\n    }\n\n    if (this->activeState) {\n        // Calculate distance to player\n        dist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n        \n        // Apply pull force if player is within radius\n        if (dist < this->pullRadius) {\n            pullDir.x = this->actor.world.pos.x - player->actor.world.pos.x;\n            pullDir.y = this->actor.world.pos.y - player->actor.world.pos.y;\n            pullDir.z = this->actor.world.pos.z - player->actor.world.pos.z;\n            \n            // Normalize and apply pull strength\n            f32 scale = this->pullStrength / sqrtf(SQ(pullDir.x) + SQ(pullDir.y) + SQ(pullDir.z));\n            pullDir.x *= scale;\n            pullDir.y *= scale;\n            pullDir.z *= scale;\n            \n            // Update player velocity through authentic means\n            player->actor.world.pos.x += pullDir.x;\n            player->actor.world.pos.y += pullDir.y;\n            player->actor.world.pos.z += pullDir.z;\n        }\n\n        // Update effect positions\n        for (i = 0; i < 8; i++) {\n            this->effectPos[i].x = this->actor.world.pos.x + (Math_SinS(this->effectTimer * 0x800 + i * 0x2000) * 30.0f);\n            this->effectPos[i].y = this->actor.world.pos.y;\n            this->effectPos[i].z = this->actor.world.pos.z + (Math_CosS(this->effectTimer * 0x800 + i * 0x2000) * 30.0f);\n        }\n    }\n\n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnGravityWell_Draw(Actor* thisx, PlayState* play) {\n    EnGravityWell* this = (EnGravityWell*)thisx;\n    s32 i;\n\n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    // Draw main well\n    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 100, 100, 255, 255);\n    Matrix_Push();\n    Matrix_Scale(0.5f, 0.5f, 0.5f, MTXMODE_APPLY);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n    gSPDisplayList(POLY_OPA_DISP++, gEffFlash1DL);\n    Matrix_Pop();\n\n    // Draw orbiting effects when active\n    if (this->activeState) {\n        for (i = 0; i < 8; i++) {\n            Matrix_Translate(this->effectPos[i].x, this->effectPos[i].y, \n                           this->effectPos[i].z, MTXMODE_NEW);\n            Matrix_Scale(0.2f, 0.2f, 0.2f, MTXMODE_APPLY);\n            gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n                     G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n            gSPDisplayList(POLY_OPA_DISP++, gEffSparklesDL);\n        }\n    }\n\n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_GravityWell_InitVars = {\n    /**/ ACTOR_EN_GRAVITY_WELL,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnGravityWell),\n    /**/ EnGravityWell_Init,\n    /**/ EnGravityWell_Destroy,\n    /**/ EnGravityWell_Update,\n    /**/ EnGravityWell_Draw\n};\n```\"\n}"}
{"instruction": "Create a memory management system with proper OoT patterns using standard approaches", "output": "// Authentic memory management patterns from OoT decompilation\n\n#include \"global.h\"\n\n// Authentic arena structure from z_malloc.c\ntypedef struct {\n    /* 0x00 */ void* start;\n    /* 0x04 */ void* ptr;\n    /* 0x08 */ u32 size;\n    /* 0x0C */ u32 maxSpace;\n} ZeldaArena; // size = 0x10\n\n// Authentic global arena from z_malloc.c\nstatic ZeldaArena sZeldaArena;\n\n// Authentic initialization pattern\nvoid ZeldaArena_Init(void* start, u32 size) {\n    sZeldaArena.start = start;\n    sZeldaArena.ptr = start;\n    sZeldaArena.size = size;\n    sZeldaArena.maxSpace = 0;\n}\n\n// Authentic allocation pattern from z_malloc.c\nvoid* ZeldaArena_Malloc(u32 size) {\n    void* ptr;\n    u32 alignedSize = (size + 0xF) & ~0xF;\n    \n    if ((u32)sZeldaArena.ptr + alignedSize > (u32)sZeldaArena.start + sZeldaArena.size) {\n        return NULL;\n    }\n    \n    ptr = sZeldaArena.ptr;\n    sZeldaArena.ptr = (void*)((u32)sZeldaArena.ptr + alignedSize);\n    \n    if (((u32)sZeldaArena.ptr - (u32)sZeldaArena.start) > sZeldaArena.maxSpace) {\n        sZeldaArena.maxSpace = (u32)sZeldaArena.ptr - (u32)sZeldaArena.start;\n    }\n    \n    return ptr;\n}\n\n// Authentic cleanup pattern\nvoid ZeldaArena_Free(void* ptr) {\n    // OoT doesn't actually free individual allocations\n    // Memory is managed in blocks that are cleared together\n}\n\n// Authentic arena check\nvoid* ZeldaArena_Realloc(void* ptr, size_t newSize) {\n    void* newPtr = ZeldaArena_Malloc(newSize);\n    \n    if (newPtr == NULL) {\n        return NULL;\n    }\n    \n    if (ptr != NULL) {\n        bcopy(ptr, newPtr, newSize);\n    }\n    \n    return newPtr;\n}\n\n// Authentic arena reset\nvoid ZeldaArena_Reset(void) {\n    sZeldaArena.ptr = sZeldaArena.start;\n    sZeldaArena.maxSpace = 0;\n}\n\n// Authentic size check\nu32 ZeldaArena_GetFreeBytes(void) {\n    return ((u32)sZeldaArena.start + sZeldaArena.size) - (u32)sZeldaArena.ptr;\n}\n"}
{"instruction": "Create a sound effect system for actions and events implementing common features", "output": "// Sound effect system using authentic OoT patterns\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 soundTimer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 soundRadius;\n    /* 0x154 */ Vec3f soundPos;\n    /* 0x160 */ ColliderCylinder collider;\n} EnSoundFx; // size = 0x1AC\n\n// Collision initialization data\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_NONE,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000000, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_NONE,\n        OCELEM_ON,\n    },\n    { 30, 60, 0, { 0, 0, 0 } },\n};\n\nvoid EnSoundFx_Init(Actor* thisx, PlayState* play) {\n    EnSoundFx* this = (EnSoundFx*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->soundTimer = 0;\n    this->actionState = 0;\n    this->soundRadius = 300.0f;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnSoundFx_Destroy(Actor* thisx, PlayState* play) {\n    EnSoundFx* this = (EnSoundFx*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnSoundFx_Update(Actor* thisx, PlayState* play) {\n    EnSoundFx* this = (EnSoundFx*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->soundTimer++;\n    \n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Check distance to player for sound radius\n    f32 playerDist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    // Play different sounds based on state and distance\n    switch(this->actionState) {\n        case 0:\n            if (playerDist < this->soundRadius) {\n                Audio_PlayActorSound2(&this->actor, NA_SE_EV_BOMB_BOUND);\n                this->actionState = 1;\n            }\n            break;\n            \n        case 1:\n            if (this->soundTimer > 30) {\n                Audio_PlayActorSound2(&this->actor, NA_SE_EN_STAL_JUMP);\n                this->soundTimer = 0;\n            }\n            break;\n    }\n    \n    // Update background collision info\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 0.0f, UPDBGCHECKINFO_FLAG_0);\n}\n\nvoid EnSoundFx_Draw(Actor* thisx, PlayState* play) {\n    EnSoundFx* this = (EnSoundFx*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_SoundFx_InitVars = {\n    /**/ ACTOR_EN_SOUNDFX,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnSoundFx),\n    /**/ EnSoundFx_Init,\n    /**/ EnSoundFx_Destroy,\n    /**/ EnSoundFx_Update,\n    /**/ EnSoundFx_Draw\n};"}
{"instruction": "Create a custom mechanics system", "output": "{\n  \"instruction\": \"Implement a Trading sequence with various NPCs with basic debugging support\",\n  \"input\": null,\n  \"output\": \"```c\n// Trade sequence actor that handles item swapping\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 tradeItemId;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ s16 timer;\n    /* 0x0152 */ s16 interactState;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnTrader;\n\n// Trade item IDs matching gSaveContext.eventChkInf flags\n#define TRADE_ITEM_ODD_MUSHROOM 0\n#define TRADE_ITEM_POACHERS_SAW 1\n#define TRADE_ITEM_GORON_SWORD 2\n#define TRADE_ITEM_PRESCRIPTION 3\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000010, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 50, 0, { 0, 0, 0 } },\n};\n\nvoid EnTrader_Init(Actor* thisx, PlayState* play) {\n    EnTrader* this = (EnTrader*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actionState = 0;\n    this->timer = 0;\n    this->interactState = 0;\n    \n    // Set initial trade item based on event flags\n    if (gSaveContext.eventChkInf[3] & 0x0080) {\n        this->tradeItemId = TRADE_ITEM_POACHERS_SAW;\n    } else if (gSaveContext.eventChkInf[3] & 0x0040) {\n        this->tradeItemId = TRADE_ITEM_ODD_MUSHROOM;\n    } else {\n        this->tradeItemId = TRADE_ITEM_ODD_MUSHROOM;\n    }\n}\n\nvoid EnTrader_Destroy(Actor* thisx, PlayState* play) {\n    EnTrader* this = (EnTrader*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnTrader_Update(Actor* thisx, PlayState* play) {\n    EnTrader* this = (EnTrader*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Basic interaction when player is near\n    if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 100.0f) {\n        if (this->interactState == 0) {\n            // Debug print current trade item\n            osSyncPrintf(VT_FGCOL(GREEN) \\\"Trading NPC has item: %d\\n\\\" VT_RST, this->tradeItemId);\n            this->interactState = 1;\n        }\n        \n        // Check if player has matching trade item\n        if (gSaveContext.inventory.items[SLOT_TRADE_ADULT] == this->tradeItemId) {\n            // Trade sequence logic\n            switch(this->tradeItemId) {\n                case TRADE_ITEM_ODD_MUSHROOM:\n                    gSaveContext.eventChkInf[3] |= 0x0080;\n                    gSaveContext.inventory.items[SLOT_TRADE_ADULT] = TRADE_ITEM_POACHERS_SAW;\n                    break;\n                    \n                case TRADE_ITEM_POACHERS_SAW:\n                    gSaveContext.eventChkInf[3] |= 0x0100; \n                    gSaveContext.inventory.items[SLOT_TRADE_ADULT] = TRADE_ITEM_GORON_SWORD;\n                    break;\n            }\n            \n            // Debug print trade completion\n            osSyncPrintf(VT_FGCOL(YELLOW) \\\"Trade completed! New item: %d\\n\\\" VT_RST,\n                gSaveContext.inventory.items[SLOT_TRADE_ADULT]);\n        }\n    } else {\n        this->interactState = 0;\n    }\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 50.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n}\n\nvoid EnTrader_Draw(Actor* thisx, PlayState* play) {\n    EnTrader* this = (EnTrader*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n              \n    // Draw trader model based on current trade item\n    switch(this->tradeItemId) {\n        case TRADE_ITEM_ODD_MUSHROOM:\n            gSPDisplayList(POLY_OPA_DISP++, gTraderMushromDL);\n            break;\n        case TRADE_ITEM_POACHERS_SAW:\n            gSPDisplayList(POLY_OPA_DISP++, gTraderSawDL);\n            break;\n    }\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Trader_InitVars = {\n    /**/ ACTOR_EN_TRADER,\n    /**/ ACTORCAT_NPC,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnTrader),\n    /**/ EnTrader_Init,\n    /**/ EnTrader_Destroy,\n    /**/ EnTrader_Update,\n    /**/ EnTrader_Draw\n};\n```\"\n}"}
{"instruction": "Create a animation system system", "output": "{\n  \"instruction\": \"Create a skeletal animation system for character movement with reasonable performance\",\n  \"input\": null,\n  \"output\": \"// Authentic pattern from OoT decompilation\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ Vec3s jointTable[20];\n    /* 0x01F0 */ Vec3s morphTable[20];\n    /* 0x0250 */ s16 actionState;\n    /* 0x0252 */ s16 animTimer;\n    /* 0x0254 */ ColliderCylinder collider;\n} EnCharacter;\n\nstatic AnimationHeader* sAnimations[] = {\n    &gCharacterIdleAnim,\n    &gCharacterWalkAnim,\n    &gCharacterRunAnim\n};\n\nvoid EnCharacter_Init(Actor* thisx, PlayState* play) {\n    EnCharacter* this = (EnCharacter*)thisx;\n    \n    // Initialize skeleton animation\n    SkelAnime_InitFlex(play, &this->skelAnime, &gCharacterSkel, \n                       &gCharacterIdleAnim, this->jointTable,\n                       this->morphTable, 20);\n    \n    // Initialize collision\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    // Set initial properties\n    Actor_SetScale(&this->actor, 0.01f);\n    this->actionState = 0;\n    this->animTimer = 0;\n}\n\nvoid EnCharacter_Update(Actor* thisx, PlayState* play) {\n    EnCharacter* this = (EnCharacter*)thisx;\n    s32 pad;\n    \n    // Update animation\n    SkelAnime_Update(&this->skelAnime);\n    \n    // Update collision detection\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 50.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Basic state machine for animations\n    switch (this->actionState) {\n        case 0: // Idle\n            if (this->actor.speed != 0.0f) {\n                Animation_Change(&this->skelAnime, sAnimations[1], 1.0f, 0.0f,\n                               Animation_GetLastFrame(sAnimations[1]), ANIMMODE_LOOP, 4.0f);\n                this->actionState = 1;\n            }\n            break;\n            \n        case 1: // Walking\n            if (this->actor.speed == 0.0f) {\n                Animation_Change(&this->skelAnime, sAnimations[0], 1.0f, 0.0f,\n                               Animation_GetLastFrame(sAnimations[0]), ANIMMODE_LOOP, 4.0f);\n                this->actionState = 0;\n            }\n            break;\n    }\n    \n    // Update movement\n    Actor_MoveXZGravity(&this->actor);\n}\n\nvoid EnCharacter_Draw(Actor* thisx, PlayState* play) {\n    EnCharacter* this = (EnCharacter*)thisx;\n    \n    // Standard graphics setup\n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    // Draw skeletal animation\n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                          this->skelAnime.dListCount, NULL, NULL, this);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Character_InitVars = {\n    /**/ ACTOR_EN_CHARACTER,\n    /**/ ACTORCAT_NPC,\n    /**/ FLAGS,\n    /**/ OBJECT_CHARACTER,\n    /**/ sizeof(EnCharacter),\n    /**/ EnCharacter_Init,\n    /**/ EnCharacter_Destroy,\n    /**/ EnCharacter_Update,\n    /**/ EnCharacter_Draw\n};\"\n}"}
{"instruction": "Create a interaction system system", "output": "{\n  \"instruction\": \"Create a relationship system between NPCs and the player implementing sophisticated AI behaviors\",\n  \"input\": null,\n  \"output\": \"```c\n// NPCRelations actor that manages NPC relationships\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ s16 npcAffinity[16];  // Track affinity for up to 16 NPCs\n    /* 0x0170 */ s16 targetNpcIndex;\n    /* 0x0172 */ s16 interactionCooldown;\n    /* 0x0174 */ ColliderCylinder collider;\n} EnNpcRelations; // size = 0x1C0\n\nvoid EnNpcRelations_Init(Actor* thisx, PlayState* play) {\n    EnNpcRelations* this = (EnNpcRelations*)thisx;\n    s32 i;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    \n    // Initialize NPC affinities to neutral\n    for (i = 0; i < 16; i++) {\n        this->npcAffinity[i] = 50;\n    }\n    \n    this->interactionCooldown = 0;\n    this->targetNpcIndex = -1;\n    this->actionState = 0;\n}\n\nvoid EnNpcRelations_UpdateAffinity(EnNpcRelations* this, s32 npcIndex, s16 amount) {\n    this->npcAffinity[npcIndex] += amount;\n    \n    // Clamp affinity between 0-100\n    if (this->npcAffinity[npcIndex] > 100) {\n        this->npcAffinity[npcIndex] = 100;\n    }\n    if (this->npcAffinity[npcIndex] < 0) {\n        this->npcAffinity[npcIndex] = 0;\n    }\n}\n\nvoid EnNpcRelations_Update(Actor* thisx, PlayState* play) {\n    EnNpcRelations* this = (EnNpcRelations*)thisx;\n    Player* player = GET_PLAYER(play);\n    f32 distToPlayer;\n    \n    if (this->interactionCooldown > 0) {\n        this->interactionCooldown--;\n    }\n    \n    // Update collision detection\n    Actor_UpdateBgCheckInfo(play, &this->actor, 26.0f, 10.0f, 0.0f, UPDBGCHECKINFO_FLAG_0);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    distToPlayer = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    switch (this->actionState) {\n        case 0: // Idle\n            if (distToPlayer < 100.0f && this->interactionCooldown == 0) {\n                this->actionState = 1;\n                this->timer = 30;\n            }\n            break;\n            \n        case 1: // Interaction\n            if (this->timer > 0) {\n                this->timer--;\n                \n                // Example: Increase affinity when player plays ocarina\n                if (gSaveContext.inventory.items[SLOT_OCARINA] != ITEM_NONE) {\n                    if (this->targetNpcIndex >= 0) {\n                        EnNpcRelations_UpdateAffinity(this, this->targetNpcIndex, 1);\n                    }\n                }\n            } else {\n                this->actionState = 0;\n                this->interactionCooldown = 60;\n            }\n            break;\n    }\n}\n\nvoid EnNpcRelations_Draw(Actor* thisx, PlayState* play) {\n    EnNpcRelations* this = (EnNpcRelations*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n              \n    // Draw relationship indicator\n    if (this->actionState == 1) {\n        gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 255, 255, 255, 255);\n        gSPDisplayList(POLY_OPA_DISP++, gEffFlash1DL);\n    }\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_NpcRelations_InitVars = {\n    /**/ ACTOR_EN_NPC_RELATIONS,\n    /**/ ACTORCAT_NPC,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnNpcRelations),\n    /**/ EnNpcRelations_Init,\n    /**/ EnNpcRelations_Destroy,\n    /**/ EnNpcRelations_Update, \n    /**/ EnNpcRelations_Draw\n};\n```\"\n}"}
{"instruction": "Create a memory management system", "output": "{\n  \"instruction\": \"Implement a complex memory management system for enhanced gameplay implementing standard patterns\",\n  \"input\": null,\n  \"output\": \"// Memory management must use pre-allocated structures in OoT\n// This example shows proper actor memory patterns\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 memoryTimer;\n    /* 0x014E */ s16 allocState;\n    /* 0x0150 */ f32 memoryScale;\n    /* 0x0154 */ ColliderCylinder collider;\n    /* 0x01A0 */ Vec3s jointTable[20];      // Pre-allocated array for skeleton\n    /* 0x01F0 */ Vec3s morphTable[20];      // Pre-allocated array for morphing\n    /* 0x0240 */ SkelAnime skelAnime;       // Must declare if using skeleton\n} EnMemory; // size = 0x0284\n\nvoid EnMemory_Init(Actor* thisx, PlayState* play) {\n    EnMemory* this = (EnMemory*)thisx;\n    \n    // Proper collision initialization\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    // Initialize skeleton animation properly\n    SkelAnime_InitFlex(play, &this->skelAnime, &gSomeSkeleton, \n                       &gSomeAnim, this->jointTable, this->morphTable, 20);\n    \n    // Pre-allocated memory is already available through struct\n    this->memoryTimer = 0;\n    this->allocState = 0;\n    this->memoryScale = 0.01f;\n    \n    Actor_SetScale(&this->actor, this->memoryScale);\n}\n\nvoid EnMemory_Update(Actor* thisx, PlayState* play) {\n    EnMemory* this = (EnMemory*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    // Proper collision update pattern\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Proper distance check to player\n    f32 dist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    // Proper item check\n    if (gSaveContext.inventory.items[SLOT_OCARINA] != ITEM_NONE) {\n        this->memoryTimer++;\n    }\n    \n    // Update skeleton animation\n    SkelAnime_Update(&this->skelAnime);\n    \n    // Proper background collision check\n    Actor_UpdateBgCheckInfo(play, &this->actor, 35.0f, 60.0f, 60.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n}\n\nvoid EnMemory_Draw(Actor* thisx, PlayState* play) {\n    EnMemory* this = (EnMemory*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    // Proper graphics setup\n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    // Proper matrix creation\n    Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__);\n    \n    // Proper skeleton drawing\n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, \n                          this->skelAnime.jointTable,\n                          this->skelAnime.dListCount, NULL, NULL, this);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile EnMemory_Profile = {\n    /**/ ACTOR_EN_MEMORY,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnMemory),\n    /**/ EnMemory_Init,\n    /**/ Actor_Destroy,\n    /**/ EnMemory_Update, \n    /**/ EnMemory_Draw\n};\"\n}"}
{"instruction": "Create a environmental system", "output": "{\n  \"instruction\": \"Make a Shadow Temple darkness and light mechanics using efficient algorithms\",\n  \"input\": null,\n  \"output\": \"```c\n// Shadow Temple darkness effect actor\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 lightRadius;\n    /* 0x014E */ s16 darknessFade;\n    /* 0x0150 */ f32 lightIntensity;\n    /* 0x0154 */ Color_RGBA8 darkColor;\n} EnDarkness; // size = 0x158\n\nvoid EnDarkness_Init(Actor* thisx, PlayState* play) {\n    EnDarkness* this = (EnDarkness*)thisx;\n    \n    this->lightRadius = 0;\n    this->darknessFade = 255;\n    this->lightIntensity = 0.0f;\n    this->darkColor.r = 0;\n    this->darkColor.g = 0;\n    this->darkColor.b = 0;\n    this->darkColor.a = 255;\n    \n    Actor_SetScale(&this->actor, 1.0f);\n}\n\nvoid EnDarkness_Destroy(Actor* thisx, PlayState* play) {\n}\n\nvoid EnDarkness_Update(Actor* thisx, PlayState* play) {\n    EnDarkness* this = (EnDarkness*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    // Check if player has light source equipped\n    if (gSaveContext.equips.buttonItems[1] == ITEM_FAIRY_OCARINA) {\n        // Increase light radius when light source present\n        Math_SmoothStepToS(&this->lightRadius, 100, 5, 10, 1);\n        Math_SmoothStepToS(&this->darknessFade, 100, 5, 10, 1);\n        Math_SmoothStepToF(&this->lightIntensity, 1.0f, 0.1f, 0.1f, 0.01f);\n    } else {\n        // Decrease light radius when no light source\n        Math_SmoothStepToS(&this->lightRadius, 30, 5, 10, 1);\n        Math_SmoothStepToS(&this->darknessFade, 255, 5, 10, 1);\n        Math_SmoothStepToF(&this->lightIntensity, 0.2f, 0.1f, 0.1f, 0.01f);\n    }\n}\n\nvoid EnDarkness_Draw(Actor* thisx, PlayState* play) {\n    EnDarkness* this = (EnDarkness*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    // Set up darkness overlay\n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, \n        this->darkColor.r,\n        this->darkColor.g, \n        this->darkColor.b,\n        this->darknessFade);\n        \n    // Draw darkness quad\n    gDPFillRectangle(POLY_OPA_DISP++,\n        0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);\n    \n    // Set up light effect\n    Gfx_SetupDL_25Xlu(play->state.gfxCtx);\n    gDPSetPrimColor(POLY_XLU_DISP++, 0, 0,\n        255, 255, 200, (s8)(128.0f * this->lightIntensity));\n        \n    // Draw light radius around player\n    Matrix_Translate(this->actor.world.pos.x,\n        this->actor.world.pos.y,\n        this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_Scale(this->lightRadius * 0.1f,\n        this->lightRadius * 0.1f,\n        this->lightRadius * 0.1f, MTXMODE_APPLY);\n    gSPMatrix(POLY_XLU_DISP++,\n        Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n        G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Darkness_InitVars = {\n    /**/ ACTOR_EN_DARKNESS,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnDarkness),\n    /**/ EnDarkness_Init,\n    /**/ EnDarkness_Destroy,\n    /**/ EnDarkness_Update,\n    /**/ EnDarkness_Draw\n};\n```\"\n}"}
{"instruction": "Create a combat system system", "output": "{\n  \"instruction\": \"Make a Ocarina playing and song system with complex interaction patterns\",\n  \"input\": null,\n  \"output\": \"```c\n// Authentic pattern from OoT decompilation\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 songTimer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ s16 noteIndex;\n    /* 0x0152 */ s16 requiredSong;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnSongPoint; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_NONE,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000000, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_NONE,\n        OCELEM_ON,\n    },\n    { 30, 60, 0, { 0, 0, 0 } },\n};\n\nvoid EnSongPoint_Init(Actor* thisx, PlayState* play) {\n    EnSongPoint* this = (EnSongPoint*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->songTimer = 0;\n    this->actionState = 0;\n    this->noteIndex = 0;\n    this->requiredSong = this->actor.params & 0xFF;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnSongPoint_Destroy(Actor* thisx, PlayState* play) {\n    EnSongPoint* this = (EnSongPoint*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnSongPoint_Update(Actor* thisx, PlayState* play) {\n    EnSongPoint* this = (EnSongPoint*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    switch (this->actionState) {\n        case 0:\n            if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 100.0f) {\n                if (gSaveContext.inventory.items[SLOT_OCARINA] != ITEM_NONE) {\n                    this->actionState = 1;\n                    play->msgCtx.ocarinaMode = OCARINA_MODE_01;\n                }\n            }\n            break;\n            \n        case 1:\n            if (play->msgCtx.ocarinaMode == OCARINA_MODE_04) {\n                if (play->msgCtx.lastPlayedSong == this->requiredSong) {\n                    this->actionState = 2;\n                    this->songTimer = 30;\n                } else {\n                    this->actionState = 0;\n                }\n                play->msgCtx.ocarinaMode = OCARINA_MODE_00;\n            }\n            break;\n            \n        case 2:\n            if (this->songTimer > 0) {\n                this->songTimer--;\n            } else {\n                Actor_PlaySfx(&this->actor, NA_SE_EV_CORRECT_CHIME);\n                this->actionState = 0;\n            }\n            break;\n    }\n}\n\nvoid EnSongPoint_Draw(Actor* thisx, PlayState* play) {\n    EnSongPoint* this = (EnSongPoint*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Push();\n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, this->actor.scale.z, MTXMODE_APPLY);\n    Matrix_RotateY(this->actor.world.rot.y * (M_PI / 32768.0f), MTXMODE_APPLY);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n              \n    Matrix_Pop();\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_SongPoint_InitVars = {\n    /**/ ACTOR_EN_SONGPOINT,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnSongPoint),\n    /**/ EnSongPoint_Init,\n    /**/ EnSongPoint_Destroy,\n    /**/ EnSongPoint_Update,\n    /**/ EnSongPoint_Draw\n};\n```\"\n}"}
{"instruction": "Create a interaction system system", "output": "{\n  \"instruction\": \"Create a trading system for buying and selling items with minimal features\",\n  \"input\": null,\n  \"output\": \"\n```c\n#include \\\"z_en_shop.h\\\"\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 actionState;\n    /* 0x014E */ s16 timer;\n    /* 0x0150 */ s16 selectedItem;\n    /* 0x0152 */ s16 price;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnShop; // size = 0x1A0\n\ntypedef struct {\n    s16 item;\n    s16 price;\n} ShopItem;\n\nstatic const ShopItem sShopInventory[] = {\n    { ITEM_DEKU_STICK, 10 },\n    { ITEM_DEKU_NUT, 5 },\n    { ITEM_HEART, 10 },\n    { ITEM_BOMBS_5, 25 }\n};\n\nvoid EnShop_Init(Actor* thisx, PlayState* play) {\n    EnShop* this = (EnShop*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    \n    this->actionState = 0;\n    this->timer = 0;\n    this->selectedItem = 0;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.targetMode = 2;\n    this->actor.flags |= ACTOR_FLAG_0;\n}\n\nvoid EnShop_Destroy(Actor* thisx, PlayState* play) {\n    EnShop* this = (EnShop*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnShop_Update(Actor* thisx, PlayState* play) {\n    EnShop* this = (EnShop*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (Actor_ProcessTalkRequest(&this->actor, play)) {\n        if (Message_GetState(&play->msgCtx) == TEXT_STATE_EVENT) {\n            if (Message_ShouldAdvance(play)) {\n                if (gSaveContext.rupees >= sShopInventory[this->selectedItem].price) {\n                    gSaveContext.rupees -= sShopInventory[this->selectedItem].price;\n                    Item_Give(play, sShopInventory[this->selectedItem].item);\n                    Message_CloseTextbox(play);\n                } else {\n                    Message_ContinueTextbox(play, 0x0849); // Not enough rupees\n                }\n            }\n        }\n    } else if (this->actor.xzDistToPlayer < 100.0f) {\n        this->actor.textId = 0x0848; // Would you like to buy?\n        func_8002F2CC(&this->actor, play, 100.0f);\n    }\n}\n\nvoid EnShop_Draw(Actor* thisx, PlayState* play) {\n    EnShop* this = (EnShop*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_MODELVIEW | G_MTX_LOAD);\n    gSPDisplayList(POLY_OPA_DISP++, gShopkeeperDL);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Shop_InitVars = {\n    /**/ ACTOR_EN_SHOP,\n    /**/ ACTORCAT_NPC,\n    /**/ FLAGS,\n    /**/ OBJECT_SHOPKEEPER,\n    /**/ sizeof(EnShop),\n    /**/ EnShop_Init,\n    /**/ EnShop_Destroy, \n    /**/ EnShop_Update,\n    /**/ EnShop_Draw\n};\n```\"\n}"}
{"instruction": "Create a collision debugging system for development implementing sophisticated AI behaviors", "output": "// Authentic collision debug visualization actor based on OoT patterns\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 debugMode;\n    /* 0x0150 */ ColliderCylinder collider;\n    /* 0x019C */ Vec3f lastPos;\n    /* 0x01A8 */ f32 detectionRange;\n} EnDebugCol; // size = 0x1AC\n\nvoid EnDebugCol_Init(Actor* thisx, PlayState* play) {\n    EnDebugCol* this = (EnDebugCol*)thisx;\n    \n    // Initialize collision using authentic pattern\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.flags |= ACTOR_FLAG_0;\n    this->detectionRange = 200.0f;\n    this->debugMode = 0;\n    \n    Actor_SetScale(&this->actor, 0.02f);\n}\n\nvoid EnDebugCol_Destroy(Actor* thisx, PlayState* play) {\n    EnDebugCol* this = (EnDebugCol*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnDebugCol_Update(Actor* thisx, PlayState* play) {\n    EnDebugCol* this = (EnDebugCol*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    // Update collision check info using authentic pattern\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 20.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    \n    // Update collision cylinder\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Store last position for visualization\n    this->lastPos = this->actor.world.pos;\n    \n    // Basic AI behavior - follow player when in range\n    f32 distToPlayer = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    if (distToPlayer < this->detectionRange) {\n        f32 speed = 2.0f;\n        Math_SmoothStepToF(&this->actor.world.pos.x, player->actor.world.pos.x, 0.3f, speed, 0.0f);\n        Math_SmoothStepToF(&this->actor.world.pos.z, player->actor.world.pos.z, 0.3f, speed, 0.0f);\n    }\n}\n\nvoid EnDebugCol_Draw(Actor* thisx, PlayState* play) {\n    EnDebugCol* this = (EnDebugCol*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    // Setup display list\n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    // Draw collision cylinder visualization\n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_Scale(0.5f, 1.0f, 0.5f, MTXMODE_APPLY);\n    \n    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 255, 0, 0, 128);\n    \n    Matrix_Push();\n    Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__), \n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n    Matrix_Pop();\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_DebugCol_InitVars = {\n    /**/ ACTOR_EN_DEBUGCOL,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnDebugCol),\n    /**/ EnDebugCol_Init,\n    /**/ EnDebugCol_Destroy, \n    /**/ EnDebugCol_Update,\n    /**/ EnDebugCol_Draw\n};\n"}
{"instruction": "Create a actor creation system", "output": "{\n  \"instruction\": \"I want to make a healer that teaches new skills or abilities with the player using complex relationship systems in a dungeon entrance with basic debugging support\",\n  \"input\": null,\n  \"output\": \"```c\n// EnHealer struct follows authentic OoT actor pattern\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ Vec3s jointTable[16];\n    /* 0x01F0 */ Vec3s morphTable[16];\n    /* 0x0250 */ s16 actionState;\n    /* 0x0252 */ s16 trainLevel;\n    /* 0x0254 */ s16 talkState;\n    /* 0x0256 */ s16 timer;\n    /* 0x0258 */ f32 interactRange;\n    /* 0x025C */ ColliderCylinder collider;\n} EnHealer; // size = 0x02A8\n\nvoid EnHealer_Init(Actor* thisx, PlayState* play) {\n    EnHealer* this = (EnHealer*)thisx;\n    \n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 36.0f);\n    SkelAnime_InitFlex(play, &this->skelAnime, &gHealerSkel, &gHealerIdleAnim, \n                       this->jointTable, this->morphTable, 16);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.targetMode = 6;\n    this->interactRange = 100.0f;\n    this->trainLevel = 0;\n    this->talkState = 0;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnHealer_Destroy(Actor* thisx, PlayState* play) {\n    EnHealer* this = (EnHealer*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnHealer_Talk(EnHealer* this, PlayState* play) {\n    Player* player = GET_PLAYER(play);\n    \n    if (Actor_ProcessTalkRequest(&this->actor, play)) {\n        if (this->trainLevel == 0) {\n            Message_ContinueTextbox(play, 0x1000); // First meeting\n        } else if (gSaveContext.rupees >= 100) {\n            Message_ContinueTextbox(play, 0x1001); // Can train\n            gSaveContext.rupees -= 100;\n            this->trainLevel++;\n            \n            // Grant skill based on trainLevel\n            if (this->trainLevel == 1) {\n                gSaveContext.infTable[25] |= 0x0001; // Learned basic skill\n            }\n        } else {\n            Message_ContinueTextbox(play, 0x1002); // Need more rupees\n        }\n        this->actionState = 1;\n    }\n    \n    // Check interaction range\n    if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < this->interactRange) {\n        this->actor.textId = 0x1000;\n        func_8002F2CC(&this->actor, play, this->interactRange);\n    }\n}\n\nvoid EnHealer_Update(Actor* thisx, PlayState* play) {\n    EnHealer* this = (EnHealer*)thisx;\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    SkelAnime_Update(&this->skelAnime);\n    \n    switch (this->actionState) {\n        case 0:\n            EnHealer_Talk(this, play);\n            break;\n            \n        case 1:\n            if (Message_GetState(&play->msgCtx) == TEXT_STATE_NONE) {\n                this->actionState = 0;\n            }\n            break;\n    }\n    \n    // Debug print training level if debug flag set\n    if (play->debugState) {\n        osSyncPrintf(\\\"Healer Training Level: %d\\\\n\\\", this->trainLevel);\n    }\n}\n\nvoid EnHealer_Draw(Actor* thisx, PlayState* play) {\n    EnHealer* this = (EnHealer*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, \n                          this->skelAnime.jointTable,\n                          this->skelAnime.dListCount, NULL, NULL, this);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Healer_InitVars = {\n    /**/ ACTOR_EN_HEALER,\n    /**/ ACTORCAT_NPC,\n    /**/ FLAGS,\n    /**/ OBJECT_HEALER,\n    /**/ sizeof(EnHealer),\n    /**/ EnHealer_Init,\n    /**/ EnHealer_Destroy,\n    /**/ EnHealer_Update,\n    /**/ EnHealer_Draw\n};\n```\"\n}"}
{"instruction": "Create a collision prediction system for AI pathfinding using efficient algorithms", "output": "// Authentic pattern following z_actor.c and z_en_item00.c style\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 pathIndex;\n    /* 0x014E */ s16 waitTimer;\n    /* 0x0150 */ Vec3f targetPos;\n    /* 0x015C */ Vec3s waypointAngles[8];\n    /* 0x017C */ Vec3f waypointPos[8];\n    /* 0x01DC */ ColliderCylinder collider;\n    /* 0x0228 */ Vec3s jointTable[20];\n    /* 0x0278 */ Vec3s morphTable[20];\n    /* 0x02C8 */ SkelAnime skelAnime;\n} EnPathfinder; // size = 0x030C\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_HIT0,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 45, 0, { 0, 0, 0 } },\n};\n\nvoid EnPathfinder_Init(Actor* thisx, PlayState* play) {\n    EnPathfinder* this = (EnPathfinder*)thisx;\n    s32 i;\n\n    Actor_SetScale(&this->actor, 0.01f);\n    \n    // Initialize collision\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n\n    // Initialize pathfinding data\n    this->pathIndex = 0;\n    this->waitTimer = 0;\n\n    // Setup initial waypoints in a patrol pattern\n    for (i = 0; i < 8; i++) {\n        this->waypointPos[i].x = this->actor.world.pos.x + (Math_SinS(i * 0x2000) * 100.0f);\n        this->waypointPos[i].y = this->actor.world.pos.y;\n        this->waypointPos[i].z = this->actor.world.pos.z + (Math_CosS(i * 0x2000) * 100.0f);\n    }\n\n    // Initialize skeleton animation if needed\n    SkelAnime_InitFlex(play, &this->skelAnime, &gSomeSkeleton, &gSomeAnim, this->jointTable, \n                       this->morphTable, 20);\n}\n\nvoid EnPathfinder_Update(Actor* thisx, PlayState* play) {\n    EnPathfinder* this = (EnPathfinder*)thisx;\n    Player* player = GET_PLAYER(play);\n    Vec3f nextWaypoint;\n    f32 dx, dz;\n\n    // Update collision detection\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 50.0f, UPDBGCHECKINFO_FLAG_0 | \n                           UPDBGCHECKINFO_FLAG_2);\n\n    if (this->waitTimer > 0) {\n        this->waitTimer--;\n        return;\n    }\n\n    // Get next waypoint\n    nextWaypoint = this->waypointPos[this->pathIndex];\n\n    // Calculate direction to waypoint\n    dx = nextWaypoint.x - this->actor.world.pos.x;\n    dz = nextWaypoint.z - this->actor.world.pos.z;\n\n    // Rotate towards waypoint\n    Math_SmoothStepToS(&this->actor.world.rot.y, Math_Atan2S(dz, dx), 10, 2000, 0);\n\n    // Move towards waypoint\n    this->actor.world.pos.x += Math_SinS(this->actor.world.rot.y) * 2.0f;\n    this->actor.world.pos.z += Math_CosS(this->actor.world.rot.y) * 2.0f;\n\n    // Check if waypoint reached\n    if (sqrtf(SQ(dx) + SQ(dz))(&this->actor.world.pos, &nextWaypoint) < 20.0f) {\n        this->pathIndex = (this->pathIndex + 1) & 7;\n        this->waitTimer = 20;\n    }\n\n    // Update collision checking\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile EnPathfinder_Profile = {\n    /**/ ACTOR_EN_PATHFINDER,\n    /**/ ACTORCAT_ENEMY,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnPathfinder),\n    /**/ EnPathfinder_Init,\n    /**/ Actor_Destroy,\n    /**/ EnPathfinder_Update,\n    /**/ NULL\n};"}
{"instruction": "Create a ai behavior system", "output": "{\n  \"instruction\": \"Make a Bomb throwing and explosion mechanics using efficient algorithms\",\n  \"input\": null,\n  \"output\": \"```c\n// Authentic pattern from OoT decompilation\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 explosionState;\n    /* 0x0150 */ f32 blastRadius;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnBomb; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_HIT6,\n        AT_ON | AT_TYPE_ENEMY,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x20000000, 0x07, 0x04 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_ON | TOUCH_SFX_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 12, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnBomb_Init(Actor* thisx, PlayState* play) {\n    EnBomb* this = (EnBomb*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->timer = 70;\n    this->explosionState = 0;\n    this->blastRadius = 80.0f;\n    \n    this->actor.gravity = -1.0f;\n    this->actor.velocity.y = 6.0f;\n    this->actor.velocity.z = 8.0f;\n}\n\nvoid EnBomb_Destroy(Actor* thisx, PlayState* play) {\n    EnBomb* this = (EnBomb*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnBomb_Update(Actor* thisx, PlayState* play) {\n    EnBomb* this = (EnBomb*)thisx;\n    Player* player = GET_PLAYER(play);\n    Vec3f pos;\n\n    Actor_UpdateBgCheckInfo(play, &this->actor, 15.0f, 20.0f, 0.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    \n    if (this->explosionState == 0) {\n        // Regular bomb physics\n        Actor_MoveXZGravity(&this->actor);\n        \n        if (this->actor.bgCheckFlags & UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2) {\n            this->actor.velocity.y = 0.0f;\n            this->actor.velocity.z *= 0.8f;\n        }\n        \n        this->timer--;\n        if (this->timer <= 0) {\n            this->explosionState = 1;\n            this->timer = 10; // Explosion duration\n            \n            // Spawn explosion effect\n            pos = this->actor.world.pos;\n            EffectSsExplosion_SpawnNormal(play, &pos, 50.0f);\n            Audio_PlayActorSound2(&this->actor, NA_SE_IT_BOMB_EXPLOSION);\n        }\n    } else if (this->explosionState == 1) {\n        // Explosion damage check\n        if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < this->blastRadius) {\n            if (!Player_HasBottleContents(play)) {\n                func_8002F7DC(&this->actor, play);\n            }\n        }\n        \n        this->timer--;\n        if (this->timer <= 0) {\n            Actor_Kill(&this->actor);\n            return;\n        }\n    }\n\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnBomb_Draw(Actor* thisx, PlayState* play) {\n    EnBomb* this = (EnBomb*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n    gSPDisplayList(POLY_OPA_DISP++, gBombDL);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Bomb_InitVars = {\n    /**/ ACTOR_EN_BOMB,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnBomb),\n    /**/ EnBomb_Init,\n    /**/ EnBomb_Destroy,\n    /**/ EnBomb_Update,\n    /**/ EnBomb_Draw\n};\n```\"\n}"}
{"instruction": "Make a collision memory system for persistent interactions using memory-safe practices", "output": "// Authentic pattern from OoT - using static memory allocation\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 hitCount;\n    /* 0x014E */ s16 hitFlags[8]; // Pre-allocated array for hit tracking\n    /* 0x015E */ s16 timer;\n    /* 0x0160 */ ColliderCylinder collider;\n} EnCollMemory; // size = 0x1AC\n\ntypedef enum {\n    /* 0 */ COLLMEM_STATE_IDLE,\n    /* 1 */ COLLMEM_STATE_HIT,\n    /* 2 */ COLLMEM_STATE_COOLDOWN\n} CollMemoryState;\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000010, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 45, 0, { 0, 0, 0 } },\n};\n\nvoid EnCollMemory_Init(Actor* thisx, PlayState* play) {\n    EnCollMemory* this = (EnCollMemory*)thisx;\n    s32 i;\n\n    // Initialize collision detector\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n\n    // Initialize hit tracking array\n    for (i = 0; i < 8; i++) {\n        this->hitFlags[i] = 0;\n    }\n    this->hitCount = 0;\n    this->timer = 0;\n\n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnCollMemory_Update(Actor* thisx, PlayState* play) {\n    EnCollMemory* this = (EnCollMemory*)thisx;\n    s32 i;\n\n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    // Check for new collisions\n    if (this->collider.base.acFlags & AC_HIT) {\n        // Find empty slot in hit tracking array\n        for (i = 0; i < 8; i++) {\n            if (this->hitFlags[i] == 0) {\n                this->hitFlags[i] = 1;\n                this->hitCount++;\n                break;\n            }\n        }\n        this->collider.base.acFlags &= ~AC_HIT;\n    }\n\n    // Update timer and clear old hits\n    if (this->timer > 0) {\n        this->timer--;\n    } else {\n        for (i = 0; i < 8; i++) {\n            this->hitFlags[i] = 0;\n        }\n        this->hitCount = 0;\n        this->timer = 30;\n    }\n\n    // Update background collision info\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 20.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n}\n\nconst ActorProfile EnCollMemory_Profile = {\n    /**/ ACTOR_EN_COLLMEMORY,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnCollMemory),\n    /**/ EnCollMemory_Init,\n    /**/ Actor_Destroy,\n    /**/ EnCollMemory_Update,\n    /**/ NULL\n};"}
{"instruction": "Create a debugging help system", "output": "{\n  \"instruction\": \"Create an advanced debugging help with multiple features with basic debugging support\",\n  \"input\": null,\n  \"output\": \"\n```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 debugState;\n    /* 0x014E */ s16 debugMode;\n    /* 0x0150 */ s16 debugTimer;\n    /* 0x0152 */ s16 debugValue;\n    /* 0x0154 */ Vec3f debugPos;\n    /* 0x0160 */ ColliderCylinder collider;\n} EnDebugger; // size = 0x1AC\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_NONE,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000000, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_NONE,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnDebugger_Init(Actor* thisx, PlayState* play) {\n    EnDebugger* this = (EnDebugger*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->debugState = 0;\n    this->debugMode = 0;\n    this->debugTimer = 0;\n    this->debugValue = 0;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnDebugger_Destroy(Actor* thisx, PlayState* play) {\n    EnDebugger* this = (EnDebugger*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnDebugger_Update(Actor* thisx, PlayState* play) {\n    EnDebugger* this = (EnDebugger*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->debugTimer++;\n    \n    // Basic position debugging\n    this->debugPos = this->actor.world.pos;\n    \n    // Track distance to player\n    f32 playerDist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    // Debug states\n    switch(this->debugMode) {\n        case 0: // Position tracking\n            osSyncPrintf(\\\"POS: %f %f %f\\\\n\\\", \n                this->actor.world.pos.x,\n                this->actor.world.pos.y, \n                this->actor.world.pos.z);\n            break;\n            \n        case 1: // Player distance\n            osSyncPrintf(\\\"PLAYER DIST: %f\\\\n\\\", playerDist);\n            break;\n            \n        case 2: // Timer tracking\n            osSyncPrintf(\\\"TIMER: %d\\\\n\\\", this->debugTimer);\n            break;\n    }\n    \n    // Cycle debug modes\n    if (this->debugTimer > 60) {\n        this->debugTimer = 0;\n        this->debugMode = (this->debugMode + 1) % 3;\n    }\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 20.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnDebugger_Draw(Actor* thisx, PlayState* play) {\n    EnDebugger* this = (EnDebugger*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 255, 255, 255, 255);\n    \n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, this->actor.scale.z, MTXMODE_APPLY);\n    \n    Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile EnDebugger_Profile = {\n    ACTOR_EN_DEBUGGER,\n    ACTORCAT_PROP,\n    FLAGS_0,\n    OBJECT_GAMEPLAY_KEEP,\n    sizeof(EnDebugger),\n    EnDebugger_Init,\n    EnDebugger_Destroy, \n    EnDebugger_Update,\n    EnDebugger_Draw\n};\n```\n\"}"}
{"instruction": "Create a actor creation system", "output": "{\n  \"instruction\": \"Build a temporal gate object that creates temporary bridges across gaps when activated with simple activation using advanced rendering techniques\",\n  \"input\": null,\n  \"output\": \"```c\n// Temporal Gate that creates temporary light bridges\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 bridgeState;\n    /* 0x0150 */ f32 bridgeLength;\n    /* 0x0154 */ f32 bridgeAlpha;\n    /* 0x158 */ Vec3f bridgeEnd;\n    /* 0x164 */ ColliderCylinder collider;\n    /* 0x1B0 */ SkelAnime skelAnime;\n    /* 0x1F4 */ Vec3s jointTable[10];\n    /* 0x21C */ Vec3s morphTable[10];\n} EnTimeGate;\n\nvoid EnTimeGate_Init(Actor* thisx, PlayState* play) {\n    EnTimeGate* this = (EnTimeGate*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->bridgeState = 0;\n    this->bridgeAlpha = 0.0f;\n    this->bridgeLength = 200.0f;\n    \n    // Setup activation collision\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    // Calculate bridge end point in front of gate\n    this->bridgeEnd.x = this->actor.world.pos.x + (Math_SinS(this->actor.world.rot.y) * this->bridgeLength);\n    this->bridgeEnd.y = this->actor.world.pos.y;\n    this->bridgeEnd.z = this->actor.world.pos.z + (Math_CosS(this->actor.world.rot.y) * this->bridgeLength);\n    \n    // Initialize skeleton animation for gate\n    SkelAnime_InitFlex(play, &this->skelAnime, &gTimeGateSkel, &gTimeGateIdleAnim, \n                       this->jointTable, this->morphTable, 10);\n}\n\nvoid EnTimeGate_Update(Actor* thisx, PlayState* play) {\n    EnTimeGate* this = (EnTimeGate*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Check if player is near gate\n    f32 playerDist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    switch(this->bridgeState) {\n        case 0: // Inactive\n            if (playerDist < 100.0f) {\n                this->bridgeState = 1;\n                this->timer = 300; // 5 seconds active\n            }\n            Math_SmoothStepToF(&this->bridgeAlpha, 0.0f, 0.1f, 10.0f, 0.0f);\n            break;\n            \n        case 1: // Active\n            Math_SmoothStepToF(&this->bridgeAlpha, 255.0f, 0.1f, 10.0f, 0.0f);\n            if (--this->timer <= 0) {\n                this->bridgeState = 0;\n            }\n            break;\n    }\n    \n    // Update gate animation\n    SkelAnime_Update(&this->skelAnime);\n}\n\nvoid EnTimeGate_Draw(Actor* thisx, PlayState* play) {\n    EnTimeGate* this = (EnTimeGate*)thisx;\n    \n    // Draw gate structure\n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    // Draw animated gate structure\n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                         this->skelAnime.dListCount, NULL, NULL, this);\n    \n    if (this->bridgeAlpha > 0.0f) {\n        // Draw light bridge\n        Gfx_SetupDL_25Xlu(play->state.gfxCtx);\n        \n        gDPSetPrimColor(POLY_XLU_DISP++, 0, 0, 150, 255, 255, (u8)this->bridgeAlpha);\n        gDPSetEnvColor(POLY_XLU_DISP++, 100, 150, 255, 128);\n        \n        Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, \n                        this->actor.world.pos.z, MTXMODE_NEW);\n        Matrix_RotateY(BINANG_TO_RAD(this->actor.world.rot.y), MTXMODE_APPLY);\n        \n        Matrix_Scale(this->bridgeLength/100.0f, 0.1f, 1.0f, MTXMODE_APPLY);\n        gSPMatrix(POLY_XLU_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n                  G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n        \n        gSPDisplayList(POLY_XLU_DISP++, gLightBridgeDL);\n    }\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_TimeGate_InitVars = {\n    /**/ ACTOR_EN_TIME_GATE,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_TIME_GATE,\n    /**/ sizeof(EnTimeGate),\n    /**/ EnTimeGate_Init,\n    /**/ EnTimeGate_Destroy,\n    /**/ EnTimeGate_Update,\n    /**/ EnTimeGate_Draw\n};\n```\"}"}
{"instruction": "Create a ai behavior system", "output": "{\n  \"instruction\": \"Create a Bow and arrow aiming and shooting system using advanced memory management\",\n  \"input\": null,\n  \"output\": \"```c\n// Authentic pattern from OoT decompilation\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 actionState;\n    /* 0x014E */ s16 timer;\n    /* 0x0150 */ Vec3f aimPos;\n    /* 0x015C */ f32 bowDrawAmount;\n    /* 0x0160 */ ColliderCylinder collider;\n} EnBowAim; // size = 0x1AC\n\nvoid EnBowAim_Init(Actor* thisx, PlayState* play) {\n    EnBowAim* this = (EnBowAim*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actionState = 0;\n    this->timer = 0;\n    this->bowDrawAmount = 0.0f;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnBowAim_Update(Actor* thisx, PlayState* play) {\n    EnBowAim* this = (EnBowAim*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    switch(this->actionState) {\n        case 0: // Idle\n            if (gSaveContext.inventory.items[SLOT_BOW] == ITEM_BOW) {\n                if (player->stateFlags1 & PLAYER_STATE1_11) { // Aiming\n                    this->actionState = 1;\n                }\n            }\n            break;\n            \n        case 1: // Aiming\n            // Get aim position based on player direction\n            this->aimPos.x = player->actor.world.pos.x + (Math_SinS(player->actor.world.rot.y) * 80.0f);\n            this->aimPos.z = player->actor.world.pos.z + (Math_CosS(player->actor.world.rot.y) * 80.0f);\n            this->aimPos.y = player->actor.world.pos.y + 50.0f;\n            \n            // Draw bow animation\n            Math_SmoothStepToF(&this->bowDrawAmount, 1.0f, 0.2f, 0.4f, 0.1f);\n            \n            if (!(player->stateFlags1 & PLAYER_STATE1_11)) { // Released aim\n                if (gSaveContext.inventory.items[SLOT_BOW] == ITEM_BOW &&\n                    gSaveContext.ammo[SLOT_BOW] > 0) {\n                    // Spawn arrow actor at aim position\n                    Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ARROW, \n                              this->aimPos.x, this->aimPos.y, this->aimPos.z,\n                              0, player->actor.world.rot.y, 0, 0);\n                    gSaveContext.ammo[SLOT_BOW]--;\n                }\n                this->actionState = 2;\n            }\n            break;\n            \n        case 2: // Release animation\n            Math_SmoothStepToF(&this->bowDrawAmount, 0.0f, 0.2f, 0.4f, 0.1f);\n            if (this->bowDrawAmount <= 0.01f) {\n                this->actionState = 0;\n            }\n            break;\n    }\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnBowAim_Draw(Actor* thisx, PlayState* play) {\n    EnBowAim* this = (EnBowAim*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Push();\n    Matrix_Scale(1.0f + (this->bowDrawAmount * 0.2f), \n                1.0f - (this->bowDrawAmount * 0.1f),\n                1.0f, MTXMODE_APPLY);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n    gSPDisplayList(POLY_OPA_DISP++, gBowDL);\n    Matrix_Pop();\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_BowAim_InitVars = {\n    /**/ ACTOR_EN_BOWAIM,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_BOW,\n    /**/ sizeof(EnBowAim),\n    /**/ EnBowAim_Init,\n    /**/ EnBowAim_Destroy,\n    /**/ EnBowAim_Update,\n    /**/ EnBowAim_Draw\n};\n```\"\n}"}
{"instruction": "Create a interaction system system", "output": "{\n  \"instruction\": \"Implement a reputation system that affects NPC interactions implementing common features\",\n  \"input\": null,\n  \"output\": \"```c\n// Reputation system using authentic OoT patterns\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 reputationValue;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ s16 talkTimer;\n    /* 0x0152 */ s16 textId;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnReputation;\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000080, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 40, 0, { 0, 0, 0 } },\n};\n\nvoid EnReputation_Init(Actor* thisx, PlayState* play) {\n    EnReputation* this = (EnReputation*)thisx;\n    \n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 20.0f);\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->reputationValue = 50; // Neutral starting reputation\n    this->actionState = 0;\n    this->talkTimer = 0;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnReputation_Destroy(Actor* thisx, PlayState* play) {\n    EnReputation* this = (EnReputation*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnReputation_Update(Actor* thisx, PlayState* play) {\n    EnReputation* this = (EnReputation*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Check interaction range\n    if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 100.0f) {\n        if (Actor_ProcessTalkRequest(&this->actor, play)) {\n            // Set message ID based on reputation\n            if (this->reputationValue >= 75) {\n                this->textId = 0x1000; // Friendly message\n            } else if (this->reputationValue >= 25) {\n                this->textId = 0x1001; // Neutral message\n            } else {\n                this->textId = 0x1002; // Hostile message\n            }\n            \n            // Update reputation based on player's items\n            if (gSaveContext.inventory.items[SLOT_OCARINA] == ITEM_OCARINA_TIME) {\n                this->reputationValue += 2;\n            }\n            \n            // Clamp reputation value\n            if (this->reputationValue > 100) {\n                this->reputationValue = 100;\n            } else if (this->reputationValue < 0) {\n                this->reputationValue = 0;\n            }\n            \n            this->actionState = 1;\n            this->talkTimer = 20;\n        }\n    }\n    \n    // Update talk state\n    if (this->talkTimer > 0) {\n        this->talkTimer--;\n        if (this->talkTimer == 0) {\n            this->actionState = 0;\n        }\n    }\n    \n    // Update actor position\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 50.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n}\n\nvoid EnReputation_Draw(Actor* thisx, PlayState* play) {\n    EnReputation* this = (EnReputation*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Reputation_InitVars = {\n    /**/ ACTOR_EN_REPUTATION,\n    /**/ ACTORCAT_NPC,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnReputation),\n    /**/ EnReputation_Init,\n    /**/ EnReputation_Destroy,\n    /**/ EnReputation_Update,\n    /**/ EnReputation_Draw\n};\n```\"\n}"}
{"instruction": "Create a debugging help system", "output": "{\n  \"instruction\": \"Create a debugging help system with proper OoT patterns using efficient algorithms\",\n  \"input\": null,\n  \"output\": \"```c\n// Debug helper actor that displays info when triggered\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 displayState;\n    /* 0x0150 */ f32 displayScale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnDbgHelper;\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000010, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 45, 0, { 0, 0, 0 } },\n};\n\nvoid EnDbgHelper_Init(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->displayState = 0;\n    this->displayScale = 0.01f;\n    Actor_SetScale(&this->actor, this->displayScale);\n}\n\nvoid EnDbgHelper_Destroy(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnDbgHelper_Update(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 100.0f) {\n        this->displayState = 1;\n        this->timer = 30;\n    }\n    \n    if (this->timer > 0) {\n        this->timer--;\n        if (this->timer == 0) {\n            this->displayState = 0;\n        }\n    }\n}\n\nvoid EnDbgHelper_Draw(Actor* thisx, PlayState* play) {\n    EnDbgHelper* this = (EnDbgHelper*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    if (this->displayState) {\n        Gfx_SetupDL_25Opa(play->state.gfxCtx);\n        gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 255, 255, 255, 255);\n        \n        Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y + 20.0f, \n                        this->actor.world.pos.z, MTXMODE_NEW);\n        Matrix_Scale(this->displayScale, this->displayScale, this->displayScale, MTXMODE_APPLY);\n        Matrix_RotateY(this->actor.world.rot.y * (M_PI / 32768.0f), MTXMODE_APPLY);\n        \n        gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n                  G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n    }\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_DbgHelper_InitVars = {\n    /**/ ACTOR_EN_DBG_HELPER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnDbgHelper),\n    /**/ EnDbgHelper_Init,\n    /**/ EnDbgHelper_Destroy,\n    /**/ EnDbgHelper_Update,\n    /**/ EnDbgHelper_Draw\n};\n```\"\n}"}
{"instruction": "Create a sound system system", "output": "{\n  \"instruction\": \"Create a voice acting system for NPC dialogue with complex interaction patterns\",\n  \"input\": null,\n  \"output\": \"// Voice system for NPC dialogue using authentic OoT patterns\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 talkTimer;\n    /* 0x014E */ s16 voiceState;\n    /* 0x0150 */ s16 nextVoiceLine;\n    /* 0x0152 */ s16 currentMessage;\n    /* 0x0154 */ f32 voiceRange;\n    /* 0x158 */ ColliderCylinder collider;\n    /* 0x1A4 */ SkelAnime skelAnime;\n    /* 0x1E8 */ Vec3s jointTable[25];\n    /* 0x24A */ Vec3s morphTable[25];\n} EnVoiceNpc;\n\nvoid EnVoiceNpc_Init(Actor* thisx, PlayState* play) {\n    EnVoiceNpc* this = (EnVoiceNpc*)thisx;\n    \n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 30.0f);\n    SkelAnime_InitFlex(play, &this->skelAnime, &gNpcSkel, &gNpcIdleAnim, \n                       this->jointTable, this->morphTable, 25);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->voiceRange = 100.0f;\n    this->talkTimer = 0;\n    this->voiceState = 0;\n    this->currentMessage = 0;\n}\n\nvoid EnVoiceNpc_Talk(EnVoiceNpc* this, PlayState* play) {\n    Player* player = GET_PLAYER(play);\n    \n    if (Actor_ProcessTalkRequest(&this->actor, play)) {\n        this->voiceState = 1;\n        this->talkTimer = 30;\n        \n        // Authentic message context pattern\n        Message_StartTextbox(play, this->currentMessage, &this->actor);\n        \n        // Play voice sfx based on current message\n        if (this->currentMessage == 0x1000) {\n            Audio_PlayActorSound2(&this->actor, NA_SE_VO_NA_HELLO);\n        } else if (this->currentMessage == 0x1001) {\n            Audio_PlayActorSound2(&this->actor, NA_SE_VO_NA_HELLO_2);\n        }\n    }\n}\n\nvoid EnVoiceNpc_Update(Actor* thisx, PlayState* play) {\n    EnVoiceNpc* this = (EnVoiceNpc*)thisx;\n    \n    if (this->talkTimer > 0) {\n        this->talkTimer--;\n    }\n    \n    // Update talking state\n    if (Actor_WorldDistXZToActor(&this->actor, &GET_PLAYER(play)->actor) < this->voiceRange) {\n        if (this->voiceState == 0) {\n            // Make NPC face player when in range\n            Actor_TrackPlayer(play, &this->actor, &this->skelAnime, 6, 4);\n            EnVoiceNpc_Talk(this, play);\n        }\n    } else {\n        this->voiceState = 0;\n    }\n    \n    // Update animation\n    SkelAnime_Update(&this->skelAnime);\n    \n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnVoiceNpc_Draw(Actor* thisx, PlayState* play) {\n    EnVoiceNpc* this = (EnVoiceNpc*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    // Draw NPC model with skeleton animation\n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                         this->skelAnime.dListCount, NULL, NULL, this);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile EnVoiceNpc_Profile = {\n    /**/ ACTOR_EN_VOICE_NPC,\n    /**/ ACTORCAT_NPC,\n    /**/ FLAGS,\n    /**/ OBJECT_NPC,\n    /**/ sizeof(EnVoiceNpc),\n    /**/ EnVoiceNpc_Init,\n    /**/ Actor_Destroy,\n    /**/ EnVoiceNpc_Update, \n    /**/ EnVoiceNpc_Draw\n};\"\n}"}
{"instruction": "Implement a procedural animation system for natural movement with basic error checking", "output": "typedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 animState;\n    /* 0x0150 */ f32 yOffset;\n    /* 0x0154 */ f32 bobPhase;\n    /* 0x0158 */ f32 moveSpeed;\n    /* 0x015C */ Vec3f targetPos;\n    /* 0x0168 */ ColliderCylinder collider;\n} EnFloater; // size = 0x1B4\n\nvoid EnFloater_Init(Actor* thisx, PlayState* play) {\n    EnFloater* this = (EnFloater*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->yOffset = 0.0f;\n    this->bobPhase = 0.0f;\n    this->moveSpeed = 2.0f;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->targetPos = this->actor.world.pos;\n}\n\nvoid EnFloater_Update(Actor* thisx, PlayState* play) {\n    EnFloater* this = (EnFloater*)thisx;\n    Player* player = GET_PLAYER(play);\n    f32 dx, dz;\n    \n    this->timer++;\n    this->bobPhase += 0.05f;\n    \n    // Smooth bobbing motion\n    this->yOffset = Math_SinS(this->bobPhase * 0x800) * 5.0f;\n    this->actor.world.pos.y = this->targetPos.y + this->yOffset;\n    \n    // Move toward target position\n    dx = this->targetPos.x - this->actor.world.pos.x;\n    dz = this->targetPos.z - this->actor.world.pos.z;\n    \n    if (fabsf(dx) > 1.0f || fabsf(dz) > 1.0f) {\n        Math_SmoothStepToF(&this->actor.world.pos.x, this->targetPos.x, 0.3f, this->moveSpeed, 0.0f);\n        Math_SmoothStepToF(&this->actor.world.pos.z, this->targetPos.z, 0.3f, this->moveSpeed, 0.0f);\n    }\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Face toward player\n    Math_SmoothStepToS(&this->actor.shape.rot.y, \n                       Math_Vec3f_Yaw(&this->actor.world.pos, &player->actor.world.pos),\n                       3, 0x400, 1);\n}\n\nconst ActorProfile En_Floater_InitVars = {\n    /**/ ACTOR_EN_FLOATER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnFloater),\n    /**/ EnFloater_Init,\n    /**/ EnFloater_Destroy,\n    /**/ EnFloater_Update,\n    /**/ NULL\n};"}
{"instruction": "Create a feature implementation system", "output": "{\n  \"instruction\": \"Create an advanced feature implementation with multiple features with extensive error handling and edge cases\",\n  \"input\": null,\n  \"output\": \"\n```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ s16 spawnCount;\n    /* 0x0152 */ s16 dropType;\n    /* 0x0154 */ f32 detectionRange;\n    /* 0x0158 */ f32 floatHeight;\n    /* 0x015C */ Vec3f effectPos;\n    /* 0x0168 */ SkelAnime skelAnime;\n    /* 0x01AC */ Vec3s jointTable[20];\n    /* 0x01FC */ Vec3s morphTable[20];\n    /* 0x024C */ ColliderCylinder collider;\n} EnTreasureChest; // size = 0x0298\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 30, 60, 0, { 0, 0, 0 } },\n};\n\nvoid EnTreasureChest_Init(Actor* thisx, PlayState* play) {\n    EnTreasureChest* this = (EnTreasureChest*)thisx;\n    s32 pad;\n\n    // Initialize collision\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n\n    // Initialize skeleton animation\n    SkelAnime_InitFlex(play, &this->skelAnime, &gChestSkel, &gChestOpenAnim, \n                       this->jointTable, this->morphTable, 20);\n\n    // Set initial properties\n    this->timer = 0;\n    this->actionState = 0;\n    this->spawnCount = 0;\n    this->detectionRange = 100.0f;\n    this->floatHeight = 0.0f;\n    \n    // Set actor properties\n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.flags |= ACTOR_FLAG_0;\n    this->actor.flags |= ACTOR_FLAG_4;\n    \n    // Set initial drop type based on params\n    this->dropType = (this->actor.params >> 8) & 0xFF;\n    if (this->dropType > 5) {\n        this->dropType = 0;\n    }\n}\n\nvoid EnTreasureChest_Update(Actor* thisx, PlayState* play) {\n    EnTreasureChest* this = (EnTreasureChest*)thisx;\n    Player* player = GET_PLAYER(play);\n    s32 pad;\n    f32 dx;\n    f32 dz;\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Update background collision\n    Actor_UpdateBgCheckInfo(play, &this->actor, 35.0f, 60.0f, 60.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n\n    // Calculate distance to player\n    dx = player->actor.world.pos.x - this->actor.world.pos.x;\n    dz = player->actor.world.pos.z - this->actor.world.pos.z;\n    f32 distToPlayer = sqrtf(SQ(dx) + SQ(dz));\n\n    switch (this->actionState) {\n        case 0: // Waiting\n            if (distToPlayer < this->detectionRange) {\n                this->actionState = 1;\n                this->timer = 30;\n            }\n            break;\n\n        case 1: // Opening\n            this->timer--;\n            Math_SmoothStepToF(&this->floatHeight, 20.0f, 0.3f, 5.0f, 0.1f);\n            \n            if (this->timer <= 0) {\n                // Spawn treasure\n                if (this->spawnCount == 0) {\n                    Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ITEM00,\n                              this->actor.world.pos.x,\n                              this->actor.world.pos.y + 40.0f,\n                              this->actor.world.pos.z,\n                              0, 0, 0, this->dropType);\n                    this->spawnCount++;\n                }\n                this->actionState = 2;\n            }\n            break;\n\n        case 2: // Opened\n            Math_SmoothStepToF(&this->floatHeight, 0.0f, 0.3f, 5.0f, 0.1f);\n            break;\n    }\n\n    // Update skeleton animation\n    SkelAnime_Update(&this->skelAnime);\n}\n\nvoid EnTreasureChest_Draw(Actor* thisx, PlayState* play) {\n    EnTreasureChest* this = (EnTreasureChest*)thisx;\n\n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Push();\n    Matrix_Translate(0.0f, this->floatHeight, 0.0f, MTXMODE_APPLY);\n    Matrix_RotateY(this->actor.shape.rot.y * (M_PI / 32768.0f), MTXMODE_APPLY);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, this->actor.scale.z, MTXMODE_APPLY);\n    \n    if (Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__)) {\n        SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                             this->skelAnime.dListCount, NULL, NULL, this);\n    }\n    \n    Matrix_Pop();\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_TreasureChest_InitVars = {\n    /**/ ACTOR_EN_TREASURE_CHEST,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnTreasureChest),\n    /**/ EnTreasureChest_Init,\n    /**/ EnTreasureChest_Destroy,\n    /**/ EnTreasureChest_Update,\n    /**/ EnTreasureChest_Draw\n};\n```\"\n}"}
{"instruction": "Create a animation system system", "output": "{\n  \"instruction\": \"Make a keyframe animation system for custom animations with appropriate documentation\",\n  \"input\": null,\n  \"output\": \"/**\n * Custom keyframe animation system following OoT patterns\n */\n\ntypedef struct {\n    /* 0x00 */ Vec3f translate;\n    /* 0x0C */ Vec3s rotate;\n    /* 0x12 */ f32 scale;\n} KeyFrame; // size = 0x16\n\ntypedef struct {\n    /* 0x00 */ s16 frameCount;\n    /* 0x02 */ s16 loop;\n    /* 0x04 */ KeyFrame* keyFrames;\n} Animation; // size = 0x8\n\ntypedef struct {\n    /* 0x000 */ Actor actor;\n    /* 0x14C */ s16 animFrame;\n    /* 0x14E */ s16 prevFrame;\n    /* 0x150 */ s16 totalFrames;\n    /* 0x152 */ s16 currentKeyFrame;\n    /* 0x154 */ f32 playbackSpeed;\n    /* 0x158 */ Animation* currentAnim;\n    /* 0x15C */ Vec3f currentPos;\n    /* 0x168 */ Vec3s currentRot;\n    /* 0x16E */ f32 currentScale;\n    /* 0x172 */ ColliderCylinder collider;\n} EnAnimated; // size = 0x1BE\n\nstatic Animation sIdleAnim = {\n    /* frameCount */ 20,\n    /* loop */ 1,\n    /* keyFrames */ {\n        // Frame 0\n        { { 0.0f, 0.0f, 0.0f }, { 0, 0, 0 }, 1.0f },\n        // Frame 10 \n        { { 0.0f, 10.0f, 0.0f }, { 0, 0x4000, 0 }, 1.2f },\n        // Frame 20\n        { { 0.0f, 0.0f, 0.0f }, { 0, 0x8000, 0 }, 1.0f }\n    }\n};\n\nvoid EnAnimated_Init(Actor* thisx, PlayState* play) {\n    EnAnimated* this = (EnAnimated*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->animFrame = 0;\n    this->prevFrame = 0;\n    this->currentKeyFrame = 0;\n    this->playbackSpeed = 1.0f;\n    this->currentAnim = &sIdleAnim;\n    this->totalFrames = this->currentAnim->frameCount;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnAnimated_UpdateAnimation(EnAnimated* this) {\n    KeyFrame* currKey;\n    KeyFrame* nextKey;\n    f32 frameDiff;\n    f32 frameProgress;\n    s16 currFrame;\n    s16 nextFrame;\n    \n    currKey = &this->currentAnim->keyFrames[this->currentKeyFrame];\n    nextKey = &this->currentAnim->keyFrames[this->currentKeyFrame + 1];\n    \n    currFrame = this->currentKeyFrame * 10;\n    nextFrame = (this->currentKeyFrame + 1) * 10;\n    \n    frameDiff = nextFrame - currFrame;\n    frameProgress = (this->animFrame - currFrame) / frameDiff;\n    \n    // Interpolate position\n    Math_SmoothStepToF(&this->currentPos.x, nextKey->translate.x, 0.1f, frameProgress, 0.01f);\n    Math_SmoothStepToF(&this->currentPos.y, nextKey->translate.y, 0.1f, frameProgress, 0.01f);\n    Math_SmoothStepToF(&this->currentPos.z, nextKey->translate.z, 0.1f, frameProgress, 0.01f);\n    \n    // Interpolate rotation\n    Math_SmoothStepToS(&this->currentRot.x, nextKey->rotate.x, 5, frameProgress * 0x4000, 0x10);\n    Math_SmoothStepToS(&this->currentRot.y, nextKey->rotate.y, 5, frameProgress * 0x4000, 0x10);\n    Math_SmoothStepToS(&this->currentRot.z, nextKey->rotate.z, 5, frameProgress * 0x4000, 0x10);\n    \n    // Interpolate scale\n    Math_SmoothStepToF(&this->currentScale, nextKey->scale, 0.1f, frameProgress, 0.01f);\n}\n\nvoid EnAnimated_Update(Actor* thisx, PlayState* play) {\n    EnAnimated* this = (EnAnimated*)thisx;\n    \n    this->prevFrame = this->animFrame;\n    this->animFrame += this->playbackSpeed;\n    \n    if (this->animFrame >= this->totalFrames) {\n        if (this->currentAnim->loop) {\n            this->animFrame = 0;\n            this->currentKeyFrame = 0;\n        } else {\n            this->animFrame = this->totalFrames - 1;\n        }\n    }\n    \n    if (this->animFrame >= (this->currentKeyFrame + 1) * 10) {\n        this->currentKeyFrame++;\n    }\n    \n    EnAnimated_UpdateAnimation(this);\n    \n    // Update actor transform\n    this->actor.world.pos.x += this->currentPos.x;\n    this->actor.world.pos.y += this->currentPos.y;\n    this->actor.world.pos.z += this->currentPos.z;\n    \n    this->actor.shape.rot.x = this->currentRot.x;\n    this->actor.shape.rot.y = this->currentRot.y;\n    this->actor.shape.rot.z = this->currentRot.z;\n    \n    Actor_SetScale(&this->actor, this->currentScale * 0.01f);\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile EnAnimated_Profile = {\n    /**/ ACTOR_EN_ANIMATED,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnAnimated),\n    /**/ EnAnimated_Init,\n    /**/ EnAnimated_Destroy,\n    /**/ EnAnimated_Update,\n    /**/ EnAnimated_Draw\n};\"\n}"}
{"instruction": "Create a combat system system", "output": "{\n  \"instruction\": \"Implement a Sword combat with different attack patterns with basic debugging support\",\n  \"input\": null,\n  \"output\": \"\n```c\n#include \\\"z_en_sword.h\\\"\n\ntypedef enum {\n    /* 0 */ SWORD_IDLE,\n    /* 1 */ SWORD_ATTACK_VERTICAL,\n    /* 2 */ SWORD_ATTACK_HORIZONTAL,\n    /* 3 */ SWORD_ATTACK_THRUST,\n    /* 4 */ SWORD_DAMAGED\n} SwordState;\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ Vec3s jointTable[20];\n    /* 0x01F0 */ Vec3s morphTable[20];\n    /* 0x0250 */ s16 actionState;\n    /* 0x0252 */ s16 attackTimer;\n    /* 0x0254 */ s16 damageTimer;\n    /* 0x0256 */ s16 comboCount;\n    /* 0x0258 */ f32 attackRange;\n    /* 0x025C */ ColliderCylinder collider;\n    /* 0x02A8 */ ColliderQuad swordQuad;\n} EnSword; // size = 0x0328\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_HIT0,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 25, 70, 0, { 0, 0, 0 } },\n};\n\nvoid EnSword_Init(Actor* thisx, PlayState* play) {\n    EnSword* this = (EnSword*)thisx;\n    \n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 30.0f);\n    SkelAnime_InitFlex(play, &this->skelAnime, &gStalfosSkel, &gStalfosIdleAnim, \n                       this->jointTable, this->morphTable, 20);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actionState = SWORD_IDLE;\n    this->attackTimer = 0;\n    this->damageTimer = 0;\n    this->comboCount = 0;\n    this->attackRange = 80.0f;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnSword_Destroy(Actor* thisx, PlayState* play) {\n    EnSword* this = (EnSword*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnSword_UpdateAttackPattern(EnSword* this, PlayState* play) {\n    Player* player = GET_PLAYER(play);\n    f32 distToPlayer = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    if (this->damageTimer > 0) {\n        this->actionState = SWORD_DAMAGED;\n        this->damageTimer--;\n        return;\n    }\n\n    switch(this->actionState) {\n        case SWORD_IDLE:\n            if (distToPlayer < this->attackRange) {\n                this->actionState = (s16)Rand_ZeroFloat(2.99f) + 1;\n                this->attackTimer = 20;\n            }\n            break;\n            \n        case SWORD_ATTACK_VERTICAL:\n        case SWORD_ATTACK_HORIZONTAL:\n        case SWORD_ATTACK_THRUST:\n            if (this->attackTimer > 0) {\n                this->attackTimer--;\n            } else {\n                this->actionState = SWORD_IDLE;\n                this->comboCount++;\n            }\n            break;\n    }\n}\n\nvoid EnSword_Update(Actor* thisx, PlayState* play) {\n    EnSword* this = (EnSword*)thisx;\n    \n    EnSword_UpdateAttackPattern(this, play);\n    \n    // Debug prints\n    #ifdef ENABLE_DEBUG\n    osSyncPrintf(\\\"SWORD: State %d Timer %d Combo %d\\\\n\\\", \n                 this->actionState, this->attackTimer, this->comboCount);\n    #endif\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 35.0f, 60.0f, 60.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n                           \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnSword_Draw(Actor* thisx, PlayState* play) {\n    EnSword* this = (EnSword*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                          this->skelAnime.dListCount, NULL, NULL, this);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Sword_InitVars = {\n    /**/ ACTOR_EN_SWORD,\n    /**/ ACTORCAT_ENEMY,\n    /**/ FLAGS,\n    /**/ OBJECT_STALFOS,\n    /**/ sizeof(EnSword),\n    /**/ EnSword_Init,\n    /**/ EnSword_Destroy,\n    /**/ EnSword_Update,\n    /**/ EnSword_Draw\n};\n```\n\"}"}
{"instruction": "Create a code explanation system", "output": "{\n  \"instruction\": \"Create a code explanation system with proper OoT patterns with reasonable performance\",\n  \"input\": null,\n  \"output\": `\n// Authentic pattern from OoT decompilation style\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState; \n    /* 0x0150 */ f32 floatTimer;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnExplainer; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000008, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 40, 0, { 0, 0, 0 } },\n};\n\nvoid EnExplainer_Init(Actor* thisx, PlayState* play) {\n    EnExplainer* this = (EnExplainer*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actionState = 0;\n    this->timer = 0;\n    this->floatTimer = 0.0f;\n    \n    // Set initial position slightly above ground\n    this->actor.world.pos.y += 20.0f;\n}\n\nvoid EnExplainer_Destroy(Actor* thisx, PlayState* play) {\n    EnExplainer* this = (EnExplainer*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnExplainer_Update(Actor* thisx, PlayState* play) {\n    EnExplainer* this = (EnExplainer*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    this->floatTimer += 0.1f;\n    \n    // Simple floating motion\n    this->actor.world.pos.y = this->actor.home.pos.y + (Math_SinS(this->timer * 0x800) * 5.0f);\n    \n    // Face player when nearby\n    if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 100.0f) {\n        Math_SmoothStepToS(&this->actor.shape.rot.y, \n            Actor_WorldYawTowardActor(&this->actor, &player->actor), 5, 2000, 0);\n    }\n    \n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 20.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n}\n\nvoid EnExplainer_Draw(Actor* thisx, PlayState* play) {\n    EnExplainer* this = (EnExplainer*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_RotateY(BINANG_TO_RAD(this->actor.shape.rot.y), MTXMODE_APPLY);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, this->actor.scale.z, MTXMODE_APPLY);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__), \n        G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Explainer_InitVars = {\n    /**/ ACTOR_EN_EXPLAINER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnExplainer),\n    /**/ EnExplainer_Init,\n    /**/ EnExplainer_Destroy,\n    /**/ EnExplainer_Update,\n    /**/ EnExplainer_Draw\n};`\n}"}
{"instruction": "Make a memory management that follows OoT decompilation standards using memory-safe practices", "output": "// Authentic memory management patterns from OoT decompilation\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 allocatedBlocks;\n    /* 0x014E */ s16 maxBlocks;\n    /* 0x0150 */ void* memBlock[16]; // Pre-allocated fixed array\n    /* 0x0190 */ ColliderCylinder collider;\n} EnMemMgr; // size = 0x1DC\n\nvoid EnMemMgr_Init(Actor* thisx, PlayState* play) {\n    EnMemMgr* this = (EnMemMgr*)thisx;\n    s32 i;\n\n    // Initialize memory tracking\n    this->allocatedBlocks = 0;\n    this->maxBlocks = 16;\n\n    // Clear memory block pointers\n    for (i = 0; i < this->maxBlocks; i++) {\n        this->memBlock[i] = NULL;\n    }\n\n    // Standard collision setup\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n\n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnMemMgr_Destroy(Actor* thisx, PlayState* play) {\n    EnMemMgr* this = (EnMemMgr*)thisx;\n    s32 i;\n\n    // Free any remaining allocated blocks\n    for (i = 0; i < this->maxBlocks; i++) {\n        if (this->memBlock[i] != NULL) {\n            ZeldaArena_Free(this->memBlock[i]);\n            this->memBlock[i] = NULL;\n            this->allocatedBlocks--;\n        }\n    }\n\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnMemMgr_Update(Actor* thisx, PlayState* play) {\n    EnMemMgr* this = (EnMemMgr*)thisx;\n\n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile En_MemMgr_InitVars = {\n    /**/ ACTOR_EN_MEMMGR,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnMemMgr),\n    /**/ EnMemMgr_Init,\n    /**/ EnMemMgr_Destroy, \n    /**/ EnMemMgr_Update,\n    /**/ NULL\n};"}
{"instruction": "Create a actor creation system", "output": "{\n  \"instruction\": \"Implement a Ganon's Castle tower and barrier system with complex mathematical calculations\",\n  \"input\": null,\n  \"output\": \"\n```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 barrierState;\n    /* 0x0150 */ f32 barrierAlpha;\n    /* 0x0154 */ f32 rotationAngle;\n    /* 0x0158 */ f32 pulseScale;\n    /* 0x015C */ Vec3f barrierPos[6];\n    /* 0x01A4 */ ColliderCylinder collider;\n} EnGanonBarrier; // size = 0x1F0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 80, 150, 0, { 0, 0, 0 } },\n};\n\nvoid EnGanonBarrier_Init(Actor* thisx, PlayState* play) {\n    EnGanonBarrier* this = (EnGanonBarrier*)thisx;\n    s32 i;\n    f32 angleStep = M_PI / 3;\n\n    Actor_SetScale(&this->actor, 0.1f);\n    this->barrierState = 0;\n    this->barrierAlpha = 255.0f;\n    this->rotationAngle = 0.0f;\n    this->pulseScale = 1.0f;\n\n    // Calculate barrier crystal positions in a hexagon\n    for (i = 0; i < 6; i++) {\n        f32 angle = i * angleStep;\n        this->barrierPos[i].x = Math_SinS(angle * 0x8000 / M_PI) * 150.0f;\n        this->barrierPos[i].y = 100.0f;\n        this->barrierPos[i].z = Math_CosS(angle * 0x8000 / M_PI) * 150.0f;\n    }\n\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n}\n\nvoid EnGanonBarrier_Destroy(Actor* thisx, PlayState* play) {\n    EnGanonBarrier* this = (EnGanonBarrier*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnGanonBarrier_Update(Actor* thisx, PlayState* play) {\n    EnGanonBarrier* this = (EnGanonBarrier*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    this->rotationAngle += 0.05f;\n    \n    // Pulse effect calculation\n    this->pulseScale = 1.0f + (Math_SinS(this->timer * 0x800) * 0.1f);\n\n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    // Check if player is near and has Light Arrows equipped\n    if (Actor_WorldDistXYZToActor(&player->actor, &this->actor) < 300.0f) {\n        if (gSaveContext.inventory.items[SLOT_BOW] == ITEM_BOW_LIGHT) {\n            this->barrierAlpha = Math_SmoothStepToF(&this->barrierAlpha, 128.0f, 0.3f, 10.0f, 0.1f);\n        }\n    } else {\n        this->barrierAlpha = Math_SmoothStepToF(&this->barrierAlpha, 255.0f, 0.3f, 10.0f, 0.1f);\n    }\n}\n\nvoid EnGanonBarrier_Draw(Actor* thisx, PlayState* play) {\n    EnGanonBarrier* this = (EnGanonBarrier*)thisx;\n    s32 i;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    // Setup for transparent barrier effect\n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gDPSetEnvColor(POLY_XLU_DISP++, 255, 0, 0, (s8)this->barrierAlpha);\n\n    // Draw rotating barrier crystals\n    for (i = 0; i < 6; i++) {\n        Matrix_Push();\n        Matrix_Translate(this->barrierPos[i].x, this->barrierPos[i].y, this->barrierPos[i].z, MTXMODE_NEW);\n        Matrix_RotateY(this->rotationAngle, MTXMODE_APPLY);\n        Matrix_Scale(this->pulseScale, this->pulseScale, this->pulseScale, MTXMODE_APPLY);\n        \n        gSPMatrix(POLY_XLU_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n                 G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n                 \n        Matrix_Pop();\n    }\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Ganon_Barrier_InitVars = {\n    /**/ ACTOR_EN_GANON_BARRIER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnGanonBarrier),\n    /**/ EnGanonBarrier_Init,\n    /**/ EnGanonBarrier_Destroy,\n    /**/ EnGanonBarrier_Update,\n    /**/ EnGanonBarrier_Draw\n};\n```\n\"}"}
{"instruction": "Create a debugging tools system", "output": "{\n  \"instruction\": \"Create a debugging tools system with proper OoT patterns with extensive error handling and edge cases\",\n  \"input\": null,\n  \"output\": \"```c\n// Debug actor that displays runtime information\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 displayMode;\n    /* 0x014E */ s16 timer;\n    /* 0x0150 */ Vec3f targetPos;\n    /* 0x015C */ s32 debugFlags;\n    /* 0x0160 */ ColliderCylinder collider;\n} EnDebugInfo; // size = 0x1AC\n\nvoid EnDebugInfo_Init(Actor* thisx, PlayState* play) {\n    EnDebugInfo* this = (EnDebugInfo*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->displayMode = 0;\n    this->debugFlags = 0;\n    this->timer = 0;\n    \n    // Initialize collision for debug visualization\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n}\n\nvoid EnDebugInfo_Destroy(Actor* thisx, PlayState* play) {\n    EnDebugInfo* this = (EnDebugInfo*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnDebugInfo_Update(Actor* thisx, PlayState* play) {\n    EnDebugInfo* this = (EnDebugInfo*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    // Update debug position to follow player\n    if (this->debugFlags & 1) {\n        Math_SmoothStepToF(&this->actor.world.pos.x, player->actor.world.pos.x, 0.3f, 50.0f, 0.0f);\n        Math_SmoothStepToF(&this->actor.world.pos.y, player->actor.world.pos.y + 100.0f, 0.3f, 50.0f, 0.0f);\n        Math_SmoothStepToF(&this->actor.world.pos.z, player->actor.world.pos.z, 0.3f, 50.0f, 0.0f);\n    }\n\n    // Update collision visualization\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 20.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Cycle display modes with B button\n    if (CHECK_BTN_ALL(input->press.button, BTN_B)) {\n        this->displayMode = (this->displayMode + 1) % 4;\n    }\n}\n\nvoid EnDebugInfo_Draw(Actor* thisx, PlayState* play) {\n    EnDebugInfo* this = (EnDebugInfo*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    // Set up graphics state\n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    // Draw debug information based on mode\n    switch (this->displayMode) {\n        case 0: // Player info\n            Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, \n                           this->actor.world.pos.z, MTXMODE_NEW);\n            Matrix_Scale(0.1f, 0.1f, 0.1f, MTXMODE_APPLY);\n            Matrix_RotateY(this->actor.world.rot.y * (M_PI / 32768.0f), MTXMODE_APPLY);\n            \n            gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 255, 255, 255, 255);\n            \n            Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__);\n            gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n                     G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n            break;\n            \n        case 1: // Room info\n            break;\n            \n        case 2: // Actor info\n            break;\n            \n        case 3: // Collision info\n            break;\n    }\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_DebugInfo_InitVars = {\n    /**/ ACTOR_EN_DEBUGINFO,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnDebugInfo),\n    /**/ EnDebugInfo_Init,\n    /**/ EnDebugInfo_Destroy,\n    /**/ EnDebugInfo_Update,\n    /**/ EnDebugInfo_Draw\n};\n```\"\n}"}
{"instruction": "Make a collision optimization system for performance with proper error handling", "output": "// Collision optimization system following OoT patterns\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 optimizationTimer;\n    /* 0x014E */ s16 lastCheckedFrame;\n    /* 0x0150 */ f32 checkRadius;\n    /* 0x0154 */ ColliderCylinder collider;\n    /* 0x01A0 */ Vec3f lastCheckedPos;\n    /* 0x01AC */ u8 collisionEnabled;\n} EnCollisionOpt; // size = 0x1B0\n\n#define COLLISION_CHECK_INTERVAL 4\n#define MIN_MOVEMENT_THRESHOLD 5.0f\n\nvoid EnCollisionOpt_Init(Actor* thisx, PlayState* play) {\n    EnCollisionOpt* this = (EnCollisionOpt*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->optimizationTimer = 0;\n    this->lastCheckedFrame = 0;\n    this->checkRadius = 100.0f;\n    this->collisionEnabled = true;\n    \n    this->lastCheckedPos = this->actor.world.pos;\n}\n\nvoid EnCollisionOpt_Update(Actor* thisx, PlayState* play) {\n    EnCollisionOpt* this = (EnCollisionOpt*)thisx;\n    Player* player = GET_PLAYER(play);\n    f32 distToPlayer;\n    \n    if (!this->collisionEnabled) {\n        return;\n    }\n\n    // Only check collision every N frames if not near player\n    if ((play->gameplayFrames & (COLLISION_CHECK_INTERVAL - 1)) == 0) {\n        distToPlayer = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n        \n        // Check if actor has moved significantly\n        Vec3f posDiff;\n        posDiff.x = this->actor.world.pos.x - this->lastCheckedPos.x;\n        posDiff.y = this->actor.world.pos.y - this->lastCheckedPos.y;\n        posDiff.z = this->actor.world.pos.z - this->lastCheckedPos.z;\n        \n        f32 movementDist = sqrtf(SQ(posDiff.x) + SQ(posDiff.y) + SQ(posDiff.z));\n        \n        // Only update collision if:\n        // 1. Actor is close to player OR\n        // 2. Actor has moved significantly since last check\n        if (distToPlayer < this->checkRadius || movementDist > MIN_MOVEMENT_THRESHOLD) {\n            Actor_UpdateBgCheckInfo(play, &this->actor, 26.0f, 10.0f, 0.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n            Collider_UpdateCylinder(&this->actor, &this->collider);\n            CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n            \n            // Store position where collision was last checked\n            this->lastCheckedPos = this->actor.world.pos;\n            this->lastCheckedFrame = play->gameplayFrames;\n        }\n    }\n    \n    Actor_MoveXZGravity(&this->actor);\n}\n\nconst ActorProfile EnCollisionOpt_Profile = {\n    /**/ ACTOR_EN_COLLISION_OPT,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnCollisionOpt),\n    /**/ EnCollisionOpt_Init,\n    /**/ Actor_Destroy,\n    /**/ EnCollisionOpt_Update,\n    /**/ NULL\n};"}
{"instruction": "Create a ai behavior system", "output": "{\n  \"instruction\": \"Create a Shield blocking and deflection mechanics with reasonable performance\",\n  \"input\": null,\n  \"output\": \"```c\n// Shield collision and deflection mechanics following OoT patterns\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 blockTimer;\n    /* 0x014E */ s16 blockState;\n    /* 0x0150 */ f32 blockAngle;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnShieldBlock;\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 40, 0, { 0, 0, 0 } },\n};\n\nvoid EnShieldBlock_Init(Actor* thisx, PlayState* play) {\n    EnShieldBlock* this = (EnShieldBlock*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->blockTimer = 0;\n    this->blockState = 0;\n    this->blockAngle = 0.0f;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnShieldBlock_Destroy(Actor* thisx, PlayState* play) {\n    EnShieldBlock* this = (EnShieldBlock*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnShieldBlock_Update(Actor* thisx, PlayState* play) {\n    EnShieldBlock* this = (EnShieldBlock*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    if (this->blockTimer > 0) {\n        this->blockTimer--;\n    }\n\n    // Check if player has shield equipped\n    if (gSaveContext.equips.buttonItems[1] != ITEM_NONE) {\n        Vec3f playerPos;\n        f32 dist;\n        \n        // Get distance to player\n        playerPos.x = player->actor.world.pos.x;\n        playerPos.y = player->actor.world.pos.y;\n        playerPos.z = player->actor.world.pos.z;\n        \n        dist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n\n        // Shield block check\n        if (dist < 80.0f && this->blockTimer == 0) {\n            f32 angleToPlayer = Math_Vec3f_Yaw(&this->actor.world.pos, &playerPos);\n            f32 playerFacing = player->actor.shape.rot.y;\n            f32 angleDiff = Math_SinS((s16)(angleToPlayer - playerFacing));\n            \n            // If player is facing attack with shield\n            if (fabsf(angleDiff) < 0.5f) {\n                this->blockTimer = 10;\n                this->blockState = 1;\n                \n                // Deflect projectile/attack\n                this->actor.speedXZ = -8.0f;\n                this->actor.world.rot.y = player->actor.shape.rot.y;\n            }\n        }\n    }\n\n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (this->blockState == 1) {\n        Actor_MoveXZGravity(&this->actor);\n    }\n}\n\nvoid EnShieldBlock_Draw(Actor* thisx, PlayState* play) {\n    EnShieldBlock* this = (EnShieldBlock*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n              \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile EnShieldBlock_Profile = {\n    /**/ ACTOR_EN_SHIELD_BLOCK,\n    /**/ ACTORCAT_ENEMY,\n    /**/ FLAGS_0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnShieldBlock),\n    /**/ EnShieldBlock_Init,\n    /**/ EnShieldBlock_Destroy, \n    /**/ EnShieldBlock_Update,\n    /**/ EnShieldBlock_Draw\n};\n```\"\n}"}
{"instruction": "Implement an inventory system with item management using established conventions", "output": "// Authentic item management system based on z_en_item00.c patterns\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 collectTimer;\n    /* 0x014E */ s16 delayTimer;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnItemManage;\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000010, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 12, 15, 0, { 0, 0, 0 } }\n};\n\nvoid EnItemManage_Init(Actor* thisx, PlayState* play) {\n    EnItemManage* this = (EnItemManage*)thisx;\n\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.25f);\n    this->collectTimer = 0;\n    this->delayTimer = 0;\n    this->scale = 0.25f;\n    \n    // Set initial position slightly above ground\n    this->actor.world.pos.y += 15.0f;\n}\n\nvoid EnItemManage_Collect(EnItemManage* this, PlayState* play) {\n    Player* player = GET_PLAYER(play);\n    \n    if (this->delayTimer == 0) {\n        switch (this->actor.params & 0xFF) {\n            case 0: // Rupee\n                if (gSaveContext.rupees < 999) {\n                    gSaveContext.rupees += 1;\n                    Audio_PlaySfxGeneral(NA_SE_SY_GET_RUPY, &gSfxDefaultPos, 4, \n                                        &gSfxDefaultFreqAndVolScale, &gSfxDefaultFreqAndVolScale,\n                                        &gSfxDefaultReverb);\n                }\n                break;\n                \n            case 1: // Recovery Heart\n                if (gSaveContext.health < gSaveContext.healthCapacity) {\n                    gSaveContext.health += 0x10;\n                    Audio_PlaySfxGeneral(NA_SE_SY_HP_RECOVER, &gSfxDefaultPos, 4,\n                                        &gSfxDefaultFreqAndVolScale, &gSfxDefaultFreqAndVolScale, \n                                        &gSfxDefaultReverb);\n                }\n                break;\n        }\n        Actor_Kill(&this->actor);\n    }\n}\n\nvoid EnItemManage_Update(Actor* thisx, PlayState* play) {\n    EnItemManage* this = (EnItemManage*)thisx;\n    \n    if (this->delayTimer > 0) {\n        this->delayTimer--;\n    }\n\n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    // Check if player is nearby\n    Player* player = GET_PLAYER(play);\n    f32 dx = player->actor.world.pos.x - this->actor.world.pos.x;\n    f32 dz = player->actor.world.pos.z - this->actor.world.pos.z;\n    f32 dist = sqrtf(SQ(dx) + SQ(dz));\n\n    if (dist < 20.0f) {\n        EnItemManage_Collect(this, play);\n    }\n\n    Actor_UpdateBgCheckInfo(play, &this->actor, 15.0f, 20.0f, 0.0f, UPDBGCHECKINFO_FLAG_0);\n}\n\nconst ActorProfile En_Item_Manage_InitVars = {\n    /**/ ACTOR_EN_ITEM_MANAGE,\n    /**/ ACTORCAT_MISC,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnItemManage),\n    /**/ EnItemManage_Init,\n    /**/ EnItemManage_Destroy,\n    /**/ EnItemManage_Update,\n    /**/ NULL\n};"}
{"instruction": "Create a interaction system system", "output": "{\n  \"instruction\": \"Create a faction system with different groups and allegiances implementing standard patterns\",\n  \"input\": null,\n  \"output\": \"```c\n// Authentic faction flags using existing OoT patterns\n#define FACTION_FLAG_NONE      0x00000000\n#define FACTION_FLAG_FRIENDLY  0x00000001 \n#define FACTION_FLAG_NEUTRAL   0x00000002\n#define FACTION_FLAG_HOSTILE   0x00000004\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState; \n    /* 0x0150 */ u32 factionFlags;\n    /* 0x0154 */ s16 health;\n    /* 0x0156 */ s16 targetTimer;\n    /* 0x0158 */ Actor* targetActor;\n    /* 0x015C */ ColliderCylinder collider;\n} EnFaction; // size = 0x1A8\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_HIT5,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 40, 0, { 0, 0, 0 } },\n};\n\nvoid EnFaction_Init(Actor* thisx, PlayState* play) {\n    EnFaction* this = (EnFaction*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->health = 4;\n    this->timer = 0;\n    this->actionState = 0;\n    this->targetTimer = 0;\n    this->targetActor = NULL;\n    \n    // Set initial faction based on params\n    switch(this->actor.params & 0xFF) {\n        case 0:\n            this->factionFlags = FACTION_FLAG_FRIENDLY;\n            break;\n        case 1:\n            this->factionFlags = FACTION_FLAG_NEUTRAL;\n            break;\n        case 2:\n            this->factionFlags = FACTION_FLAG_HOSTILE;\n            break;\n        default:\n            this->factionFlags = FACTION_FLAG_NONE;\n            break;\n    }\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnFaction_Destroy(Actor* thisx, PlayState* play) {\n    EnFaction* this = (EnFaction*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnFaction_Update(Actor* thisx, PlayState* play) {\n    EnFaction* this = (EnFaction*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (this->factionFlags & FACTION_FLAG_HOSTILE) {\n        CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    }\n    \n    // Basic ground physics\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 50.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    \n    // Target player if hostile\n    if (this->factionFlags & FACTION_FLAG_HOSTILE) {\n        if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 200.0f) {\n            Math_SmoothStepToS(&this->actor.world.rot.y, \n                Actor_WorldYawTowardActor(&this->actor, &player->actor), 10, 2000, 0);\n        }\n    }\n    \n    // Move based on rotation\n    this->actor.world.pos.x += Math_SinS(this->actor.world.rot.y) * 2.0f;\n    this->actor.world.pos.z += Math_CosS(this->actor.world.rot.y) * 2.0f;\n}\n\nvoid EnFaction_Draw(Actor* thisx, PlayState* play) {\n    EnFaction* this = (EnFaction*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n              \n    // Draw actor model here\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Faction_InitVars = {\n    /**/ ACTOR_EN_FACTION,\n    /**/ ACTORCAT_NPC,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnFaction),\n    /**/ EnFaction_Init,\n    /**/ EnFaction_Destroy, \n    /**/ EnFaction_Update,\n    /**/ EnFaction_Draw\n};\n```\"\n}"}
{"instruction": "Create a effect system system", "output": "{\n  \"instruction\": \"Make a Zelda's Lullaby effect that opens doors using established conventions\",\n  \"input\": null,\n  \"output\": \"```c\n// Zelda's Lullaby effect actor\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 alpha;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ Vec3f effectPos[3];\n    /* 0x0178 */ s16 effectTimer[3];\n} EnZeldaEffect; // size = 0x180\n\nvoid EnZeldaEffect_Init(Actor* thisx, PlayState* play) {\n    EnZeldaEffect* this = (EnZeldaEffect*)thisx;\n    s32 i;\n\n    Actor_SetScale(&this->actor, 0.0f);\n    this->timer = 0;\n    this->alpha = 255;\n    this->scale = 0.0f;\n\n    for (i = 0; i < 3; i++) {\n        this->effectPos[i] = this->actor.world.pos;\n        this->effectTimer[i] = i * 8;\n    }\n}\n\nvoid EnZeldaEffect_Destroy(Actor* thisx, PlayState* play) {\n}\n\nvoid EnZeldaEffect_Update(Actor* thisx, PlayState* play) {\n    EnZeldaEffect* this = (EnZeldaEffect*)thisx;\n    s32 i;\n\n    this->timer++;\n\n    if (this->timer >= 60) {\n        Actor_Kill(&this->actor);\n        return;\n    }\n\n    Math_SmoothStepToF(&this->scale, 0.2f, 0.5f, 0.02f, 0.001f);\n\n    for (i = 0; i < 3; i++) {\n        this->effectTimer[i]++;\n        if (this->effectTimer[i] >= 20) {\n            this->effectTimer[i] = 0;\n            this->effectPos[i].y += 15.0f;\n        }\n    }\n\n    if (this->timer >= 45) {\n        this->alpha -= 17;\n        if (this->alpha < 0) {\n            this->alpha = 0;\n        }\n    }\n}\n\nvoid EnZeldaEffect_Draw(Actor* thisx, PlayState* play) {\n    EnZeldaEffect* this = (EnZeldaEffect*)thisx;\n    s32 i;\n    Vec3f pos;\n\n    OPEN_DISPS(play->state.gfxCtx);\n\n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n\n    for (i = 0; i < 3; i++) {\n        pos = this->effectPos[i];\n        pos.y += Math_SinS(this->effectTimer[i] * 0x800) * 5.0f;\n\n        Matrix_Translate(pos.x, pos.y, pos.z, MTXMODE_NEW);\n        Matrix_Scale(this->scale, this->scale, this->scale, MTXMODE_APPLY);\n        Matrix_RotateY(M_PI * 0.5f, MTXMODE_APPLY);\n\n        gDPSetPrimColor(POLY_XLU_DISP++, 0, 0, 100, 200, 255, this->alpha);\n        gDPPipeSync(POLY_XLU_DISP++);\n\n        Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__);\n        gSPMatrix(POLY_XLU_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__), \n                 G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n        gSPDisplayList(POLY_XLU_DISP++, gEffTriangleDL);\n    }\n\n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_ZeldaEffect_InitVars = {\n    /**/ ACTOR_EN_ZELDA_EFFECT,\n    /**/ ACTORCAT_MISC,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnZeldaEffect),\n    /**/ EnZeldaEffect_Init,\n    /**/ EnZeldaEffect_Destroy,\n    /**/ EnZeldaEffect_Update,\n    /**/ EnZeldaEffect_Draw\n};\n```\"\n}"}
{"instruction": "Create a environmental system", "output": "{\n  \"instruction\": \"Create a Spirit Temple sand flow and time mechanics using advanced rendering techniques\",\n  \"input\": null,\n  \"output\": \"\n```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 sandFlowState;\n    /* 0x0150 */ f32 sandAlpha;\n    /* 0x0154 */ f32 sandSpeed;\n    /* 0x0158 */ Vec3f sandPos[16];\n    /* 0x01F8 */ ColliderCylinder collider;\n} EnSandFlow; // size = 0x244\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 30, 60, 0, { 0, 0, 0 } },\n};\n\nvoid EnSandFlow_Init(Actor* thisx, PlayState* play) {\n    EnSandFlow* this = (EnSandFlow*)thisx;\n    s32 i;\n\n    Actor_SetScale(&this->actor, 0.1f);\n    \n    this->sandFlowState = 0;\n    this->sandAlpha = 255.0f;\n    this->sandSpeed = 2.0f;\n    \n    for (i = 0; i < 16; i++) {\n        this->sandPos[i].x = this->actor.world.pos.x;\n        this->sandPos[i].y = this->actor.world.pos.y - (i * 20.0f);\n        this->sandPos[i].z = this->actor.world.pos.z;\n    }\n\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n}\n\nvoid EnSandFlow_Destroy(Actor* thisx, PlayState* play) {\n    EnSandFlow* this = (EnSandFlow*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnSandFlow_Update(Actor* thisx, PlayState* play) {\n    EnSandFlow* this = (EnSandFlow*)thisx;\n    s32 i;\n    Player* player = GET_PLAYER(play);\n\n    this->timer++;\n\n    // Update sand particle positions\n    for (i = 0; i < 16; i++) {\n        this->sandPos[i].y -= this->sandSpeed;\n        if (this->sandPos[i].y < (this->actor.world.pos.y - 300.0f)) {\n            this->sandPos[i].y = this->actor.world.pos.y;\n        }\n    }\n\n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    // Check if player is nearby\n    if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 100.0f) {\n        this->sandAlpha = 255.0f;\n        this->sandSpeed = 4.0f;\n    } else {\n        this->sandAlpha = 200.0f;\n        this->sandSpeed = 2.0f;\n    }\n}\n\nvoid EnSandFlow_Draw(Actor* thisx, PlayState* play) {\n    EnSandFlow* this = (EnSandFlow*)thisx;\n    s32 i;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    gDPSetPrimColor(POLY_XLU_DISP++, 0, 0, 255, 240, 180, (u8)this->sandAlpha);\n    \n    Matrix_Push();\n    \n    for (i = 0; i < 16; i++) {\n        Matrix_Translate(this->sandPos[i].x, this->sandPos[i].y, this->sandPos[i].z, MTXMODE_NEW);\n        Matrix_Scale(0.5f, 0.5f, 0.5f, MTXMODE_APPLY);\n        Matrix_RotateY(this->timer * 0.02f, MTXMODE_APPLY);\n        \n        gSPMatrix(POLY_XLU_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n                 G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n                 \n        gSPDisplayList(POLY_XLU_DISP++, gEffSparklesDL);\n    }\n    \n    Matrix_Pop();\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_SandFlow_InitVars = {\n    /**/ ACTOR_EN_SANDFLOW,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnSandFlow),\n    /**/ EnSandFlow_Init,\n    /**/ EnSandFlow_Destroy,\n    /**/ EnSandFlow_Update,\n    /**/ EnSandFlow_Draw\n};\n```\n\"}"}
{"instruction": "Implement code explanation functionality using authentic code implementing common features", "output": "// Authentic sign actor implementation following OoT patterns\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 messageState;\n    /* 0x014E */ s16 timer;\n    /* 0x0150 */ ColliderCylinder collider;\n} EnSignpost; // size = 0x19C\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_NONE,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000000, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_NONE,\n        OCELEM_ON,\n    },\n    { 20, 50, 0, { 0, 0, 0 } }\n};\n\nvoid EnSignpost_Init(Actor* thisx, PlayState* play) {\n    EnSignpost* this = (EnSignpost*)thisx;\n\n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.focus.pos = this->actor.world.pos;\n    this->actor.focus.pos.y += 30.0f;\n\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n\n    this->messageState = 0;\n    this->timer = 0;\n}\n\nvoid EnSignpost_Update(Actor* thisx, PlayState* play) {\n    EnSignpost* this = (EnSignpost*)thisx;\n    Player* player = GET_PLAYER(play);\n\n    this->collider.dim.pos.x = this->actor.world.pos.x;\n    this->collider.dim.pos.y = this->actor.world.pos.y;\n    this->collider.dim.pos.z = this->actor.world.pos.z;\n\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    if (this->messageState == 0) {\n        if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 100.0f) {\n            // Show \"Check (A)\" text when player is near\n            Message_StartTextbox(play, this->actor.params, NULL);\n            this->messageState = 1;\n        }\n    } else if (this->messageState == 1) {\n        if (Actor_WorldDistXZToActor(&this->actor, &player->actor) >= 100.0f) {\n            this->messageState = 0;\n        }\n    }\n}\n\nconst ActorProfile En_Signpost_InitVars = {\n    /**/ ACTOR_EN_SIGNPOST,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnSignpost),\n    /**/ EnSignpost_Init,\n    /**/ Actor_Destroy,\n    /**/ EnSignpost_Update,\n    /**/ NULL\n};"}
{"instruction": "Create a combat system system", "output": "{\n  \"instruction\": \"Implement a Sword combat with different attack patterns implementing core requirements\",\n  \"input\": null,\n  \"output\": \"\n```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 attackTimer;\n    /* 0x014E */ s16 attackState;\n    /* 0x0150 */ f32 attackRange;\n    /* 0x0154 */ ColliderCylinder collider;\n    /* 0x01A0 */ SkelAnime skelAnime;\n    /* 0x01E4 */ Vec3s jointTable[20];\n    /* 0x024C */ Vec3s morphTable[20];\n} EnSwordEnemy;\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_HIT0,\n        AT_ON | AT_TYPE_ENEMY,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0xFFCFFFFF, 0x00, 0x08 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_ON | TOUCH_SFX_NORMAL,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 25, 65, 0, { 0, 0, 0 } },\n};\n\nvoid EnSwordEnemy_Init(Actor* thisx, PlayState* play) {\n    EnSwordEnemy* this = (EnSwordEnemy*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    SkelAnime_InitFlex(play, &this->skelAnime, &gEnemySkel, &gEnemyIdleAnim, \n                       this->jointTable, this->morphTable, 20);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->attackTimer = 0;\n    this->attackState = 0;\n    this->attackRange = 100.0f;\n}\n\nvoid EnSwordEnemy_Update(Actor* thisx, PlayState* play) {\n    EnSwordEnemy* this = (EnSwordEnemy*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 35.0f, 60.0f, 60.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    \n    f32 distToPlayer = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    switch(this->attackState) {\n        case 0: // Idle\n            if (distToPlayer < this->attackRange) {\n                this->attackState = 1;\n                this->attackTimer = 20;\n            }\n            break;\n            \n        case 1: // Attack windup\n            this->attackTimer--;\n            if (this->attackTimer <= 0) {\n                this->attackState = 2;\n                this->attackTimer = 10;\n            }\n            break;\n            \n        case 2: // Attack\n            this->attackTimer--;\n            if (this->attackTimer <= 0) {\n                this->attackState = 0;\n            }\n            break;\n    }\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (this->attackState == 2) {\n        CollisionCheck_SetAT(play, &play->colChkCtx, &this->collider.base);\n    }\n}\n\nvoid EnSwordEnemy_Draw(Actor* thisx, PlayState* play) {\n    EnSwordEnemy* this = (EnSwordEnemy*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                          this->skelAnime.dListCount, NULL, NULL, this);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_SwordEnemy_InitVars = {\n    /**/ ACTOR_EN_SWORD_ENEMY,\n    /**/ ACTORCAT_ENEMY,\n    /**/ FLAGS,\n    /**/ OBJECT_ENEMY,\n    /**/ sizeof(EnSwordEnemy),\n    /**/ EnSwordEnemy_Init,\n    /**/ EnSwordEnemy_Destroy,\n    /**/ EnSwordEnemy_Update,\n    /**/ EnSwordEnemy_Draw\n};\n```\"\n}"}
{"instruction": "Create a collision system system", "output": "{\n  \"instruction\": \"Implement a collision response system with realistic physics using standard approaches\",\n  \"input\": null,\n  \"output\": \"typedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 bounceVelocity;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnBouncer; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000004, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnBouncer_Init(Actor* thisx, PlayState* play) {\n    EnBouncer* this = (EnBouncer*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.gravity = -1.0f;\n    this->bounceVelocity = 8.0f;\n    this->actionState = 0;\n}\n\nvoid EnBouncer_Update(Actor* thisx, PlayState* play) {\n    EnBouncer* this = (EnBouncer*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 20.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    \n    if (this->actor.bgCheckFlags & UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2) {\n        this->actor.velocity.y = this->bounceVelocity;\n        this->bounceVelocity *= 0.8f;\n        \n        if (this->bounceVelocity < 0.5f) {\n            this->bounceVelocity = 0.0f;\n            this->actor.velocity.y = 0.0f;\n        }\n    }\n    \n    if (this->collider.base.acFlags & AC_HIT) {\n        this->actor.velocity.x = Math_SinS(player->actor.world.rot.y) * 8.0f;\n        this->actor.velocity.z = Math_CosS(player->actor.world.rot.y) * 8.0f;\n        this->bounceVelocity = 8.0f;\n    }\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    Actor_MoveXZGravity(&this->actor);\n}\n\nconst ActorProfile En_Bouncer_InitVars = {\n    /**/ ACTOR_EN_BOUNCER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnBouncer),\n    /**/ EnBouncer_Init,\n    /**/ Actor_Destroy,\n    /**/ EnBouncer_Update,\n    /**/ NULL\n};\"\n}"}
{"instruction": "Create a environmental system", "output": "{\n  \"instruction\": \"Implement a Deku Tree web and platform system using memory-safe practices\",\n  \"input\": null,\n  \"output\": \"\n```c\n#include \\\"z_en_deku_web.h\\\"\n\ntypedef enum {\n    /* 0 */ DEKU_WEB_IDLE,\n    /* 1 */ DEKU_WEB_SWING,\n    /* 2 */ DEKU_WEB_BREAK\n} DekuWebState;\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ ColliderCylinder collider;\n    /* 0x0198 */ s16 oscillation;\n    /* 0x019A */ s16 swingTimer;\n    /* 0x019C */ f32 swingAngle;\n    /* 0x01A0 */ Vec3f originalPos;\n    /* 0x01AC */ SkelAnime skelAnime;\n    /* 0x01F0 */ Vec3s jointTable[10];\n    /* 0x0218 */ Vec3s morphTable[10];\n} EnDekuWeb; // size = 0x0240\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000010, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 25, 45, 0, { 0, 0, 0 } },\n};\n\nvoid EnDekuWeb_Init(Actor* thisx, PlayState* play) {\n    EnDekuWeb* this = (EnDekuWeb*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.colChkInfo.mass = 0;\n    this->swingTimer = 0;\n    this->oscillation = 0;\n    this->swingAngle = 0.0f;\n    \n    this->originalPos = this->actor.world.pos;\n    \n    // Setup skelAnime if needed for web mesh\n    SkelAnime_InitFlex(play, &this->skelAnime, &gDekuWebSkel, &gDekuWebIdleAnim, \n                       this->jointTable, this->morphTable, 10);\n}\n\nvoid EnDekuWeb_Destroy(Actor* thisx, PlayState* play) {\n    EnDekuWeb* this = (EnDekuWeb*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnDekuWeb_Update(Actor* thisx, PlayState* play) {\n    EnDekuWeb* this = (EnDekuWeb*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->oscillation += 0x200;\n    this->swingTimer++;\n    \n    // Natural web movement\n    this->swingAngle = sinf(this->oscillation * (M_PI / 0x8000)) * 0.05f;\n    \n    // Update position with swing\n    this->actor.world.pos.x = this->originalPos.x + (sinf(this->swingAngle) * 30.0f);\n    this->actor.world.pos.z = this->originalPos.z + (cosf(this->swingAngle) * 30.0f);\n    \n    // Collision checks\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Break web if hit with sword\n    if (this->collider.base.acFlags & AC_HIT) {\n        Actor_Kill(&this->actor);\n    }\n    \n    // Update skeleton animation\n    SkelAnime_Update(&this->skelAnime);\n}\n\nvoid EnDekuWeb_Draw(Actor* thisx, PlayState* play) {\n    EnDekuWeb* this = (EnDekuWeb*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Push();\n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, \n                    this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_RotateY(this->actor.world.rot.y * (M_PI / 0x8000), MTXMODE_APPLY);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, \n                this->actor.scale.z, MTXMODE_APPLY);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n              \n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                          this->skelAnime.dListCount, NULL, NULL, this);\n    \n    Matrix_Pop();\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Deku_Web_InitVars = {\n    /**/ ACTOR_EN_DEKU_WEB,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_DEKUBABA,\n    /**/ sizeof(EnDekuWeb),\n    /**/ EnDekuWeb_Init,\n    /**/ EnDekuWeb_Destroy,\n    /**/ EnDekuWeb_Update,\n    /**/ EnDekuWeb_Draw\n};\n```\n\"}"}
{"instruction": "Create a actor creation system", "output": "{\n  \"instruction\": \"Build a shadow assassin that uses hit-and-run tactics to avoid damage when the player approaches using advanced pathfinding for boss battles implementing sophisticated AI behaviors\",\n  \"input\": null,\n  \"output\": \"```c\n// Shadow Assassin actor using authentic OoT patterns\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ Vec3s jointTable[25];\n    /* 0x01F4 */ Vec3s morphTable[25];\n    /* 0x0258 */ s16 actionState;\n    /* 0x025A */ s16 attackTimer;\n    /* 0x025C */ s16 approachTimer;\n    /* 0x025E */ s16 damageTimer;\n    /* 0x0260 */ f32 targetDist;\n    /* 0x0264 */ Vec3f retreatPos;\n    /* 0x0270 */ ColliderCylinder collider;\n} EnShadowAssassin;\n\nvoid EnShadowAssassin_Init(Actor* thisx, PlayState* play) {\n    EnShadowAssassin* this = (EnShadowAssassin*)thisx;\n    \n    SkelAnime_InitFlex(play, &this->skelAnime, &gShadowAssassinSkel, &gShadowAssassinIdleAnim, \n                       this->jointTable, this->morphTable, 25);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.015f);\n    this->actor.colChkInfo.mass = 120;\n    this->actor.colChkInfo.health = 8;\n    this->actionState = 0;\n    this->attackTimer = 0;\n}\n\nvoid EnShadowAssassin_Destroy(Actor* thisx, PlayState* play) {\n    EnShadowAssassin* this = (EnShadowAssassin*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnShadowAssassin_CirclePlayer(EnShadowAssassin* this, PlayState* play) {\n    Player* player = GET_PLAYER(play);\n    f32 dx = player->actor.world.pos.x - this->actor.world.pos.x;\n    f32 dz = player->actor.world.pos.z - this->actor.world.pos.z;\n    \n    this->targetDist = sqrtf(SQ(dx) + SQ(dz));\n    \n    if (this->targetDist < 200.0f) {\n        f32 angle = Math_Atan2F(dz, dx);\n        this->actor.world.pos.x += Math_SinF(angle) * 5.0f;\n        this->actor.world.pos.z -= Math_CosF(angle) * 5.0f;\n    }\n}\n\nvoid EnShadowAssassin_Update(Actor* thisx, PlayState* play) {\n    EnShadowAssassin* this = (EnShadowAssassin*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    SkelAnime_Update(&this->skelAnime);\n    \n    switch(this->actionState) {\n        case 0: // Circling\n            EnShadowAssassin_CirclePlayer(this, play);\n            if (this->targetDist < 150.0f && this->attackTimer == 0) {\n                this->actionState = 1;\n                this->attackTimer = 20;\n            }\n            break;\n            \n        case 1: // Attack\n            if (this->attackTimer > 0) {\n                this->attackTimer--;\n                Math_SmoothStepToF(&this->actor.speedXZ, 12.0f, 0.5f, 5.0f, 0.0f);\n                Actor_MoveXZGravity(&this->actor);\n            } else {\n                this->actionState = 2;\n                this->retreatPos.x = this->actor.world.pos.x + (Rand_ZeroOne() - 0.5f) * 400.0f;\n                this->retreatPos.z = this->actor.world.pos.z + (Rand_ZeroOne() - 0.5f) * 400.0f;\n            }\n            break;\n            \n        case 2: // Retreat\n            Math_SmoothStepToF(&this->actor.world.pos.x, this->retreatPos.x, 0.3f, 8.0f, 0.0f);\n            Math_SmoothStepToF(&this->actor.world.pos.z, this->retreatPos.z, 0.3f, 8.0f, 0.0f);\n            \n            if (Actor_WorldDistXZToPoint(&this->actor, &this->retreatPos) < 50.0f) {\n                this->actionState = 0;\n            }\n            break;\n    }\n    \n    if (this->damageTimer > 0) {\n        this->damageTimer--;\n    }\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 30.0f, 30.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n                           \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (!(this->damageTimer > 0)) {\n        CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    }\n}\n\nvoid EnShadowAssassin_Draw(Actor* thisx, PlayState* play) {\n    EnShadowAssassin* this = (EnShadowAssassin*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n              \n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                          this->skelAnime.dListCount, NULL, NULL, this);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_ShadowAssassin_InitVars = {\n    /**/ ACTOR_EN_SHADOW_ASSASSIN,\n    /**/ ACTORCAT_ENEMY,\n    /**/ FLAGS,\n    /**/ OBJECT_SHADOW_ASSASSIN,\n    /**/ sizeof(EnShadowAssassin),\n    /**/ EnShadowAssassin_Init,\n    /**/ EnShadowAssassin_Destroy,\n    /**/ EnShadowAssassin_Update,\n    /**/ EnShadowAssassin_Draw\n};\n```\"\n}"}
{"instruction": "Create a memory management system with proper OoT patterns with complex interaction patterns", "output": "// Authentic OoT memory management patterns from the decompilation\n\n#include \"global.h\"\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 memBlockCount;\n    /* 0x014E */ s16 activeBlocks;\n    /* 0x0150 */ f32 allocatedSize;\n    /* 0x0154 */ Vec3f blockPositions[16];\n    /* 0x01F4 */ ColliderCylinder collider;\n} EnMemMgr; // size = 0x240\n\ntypedef struct {\n    /* 0x00 */ u32 size;\n    /* 0x04 */ u32 maxSize;\n    /* 0x08 */ void* ptr;\n} MemBlock;\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000010, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnMemMgr_Init(Actor* thisx, PlayState* play) {\n    EnMemMgr* this = (EnMemMgr*)thisx;\n\n    Actor_SetScale(&this->actor, 0.01f);\n    this->memBlockCount = 0;\n    this->activeBlocks = 0;\n    this->allocatedSize = 0.0f;\n\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n\n    Actor_UpdateBgCheckInfo(play, &this->actor, 25.0f, 30.0f, 30.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n}\n\nvoid EnMemMgr_Destroy(Actor* thisx, PlayState* play) {\n    EnMemMgr* this = (EnMemMgr*)thisx;\n    \n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnMemMgr_Update(Actor* thisx, PlayState* play) {\n    EnMemMgr* this = (EnMemMgr*)thisx;\n    Player* player = GET_PLAYER(play);\n    Vec3f pos;\n\n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    // Handle memory block visualization\n    if (this->memBlockCount > 0) {\n        f32 targetY = this->actor.world.pos.y + (this->allocatedSize * 0.1f);\n        Math_SmoothStepToF(&this->actor.world.pos.y, targetY, 0.3f, 3.0f, 0.0f);\n    }\n\n    // Interact with player proximity\n    if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 100.0f) {\n        if (this->activeBlocks < 16) {\n            this->blockPositions[this->activeBlocks].x = this->actor.world.pos.x;\n            this->blockPositions[this->activeBlocks].y = this->actor.world.pos.y;\n            this->blockPositions[this->activeBlocks].z = this->actor.world.pos.z;\n            this->activeBlocks++;\n        }\n    }\n}\n\nvoid EnMemMgr_Draw(Actor* thisx, PlayState* play) {\n    EnMemMgr* this = (EnMemMgr*)thisx;\n    s32 i;\n\n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 255, 255, 255, 255);\n\n    Matrix_Push();\n    Matrix_Scale(0.01f, 0.01f, 0.01f, MTXMODE_APPLY);\n    Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__);\n    Matrix_Pop();\n\n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile EnMemMgr_Profile = {\n    /**/ ACTOR_EN_MEMMGR,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnMemMgr),\n    /**/ EnMemMgr_Init,\n    /**/ EnMemMgr_Destroy,\n    /**/ EnMemMgr_Update,\n    /**/ EnMemMgr_Draw\n};"}
{"instruction": "Implement ui system functionality using authentic code using advanced rendering techniques", "output": "// Authentic UI system implementation following OoT patterns\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 displayTimer;\n    /* 0x014E */ s16 alpha;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ char displayText[32];\n} EnUiElement; // size = 0x174\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_NONE,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000000, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_NONE,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnUiElement_Init(Actor* thisx, PlayState* play) {\n    EnUiElement* this = (EnUiElement*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->displayTimer = 60;\n    this->alpha = 255;\n    this->scale = 1.0f;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n}\n\nvoid EnUiElement_Draw(Actor* thisx, PlayState* play) {\n    EnUiElement* this = (EnUiElement*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    // Setup display list\n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    // Position matrix\n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_Scale(this->scale, this->scale, this->scale, MTXMODE_APPLY);\n    Matrix_RotateY(this->actor.world.rot.y * (M_PI / 32768.0f), MTXMODE_APPLY);\n    \n    // Create new matrix\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__), \n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n              \n    // Draw UI elements\n    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 255, 255, 255, this->alpha);\n    gSPDisplayList(POLY_OPA_DISP++, gUiElementDL);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nvoid EnUiElement_Update(Actor* thisx, PlayState* play) {\n    EnUiElement* this = (EnUiElement*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    if (this->displayTimer > 0) {\n        this->displayTimer--;\n        \n        if (this->displayTimer < 10) {\n            this->alpha = (this->displayTimer * 25);\n        }\n        \n        // Update position relative to player\n        Math_SmoothStepToF(&this->actor.world.pos.x, player->actor.world.pos.x, 0.3f, 5.0f, 0.0f);\n        Math_SmoothStepToF(&this->actor.world.pos.y, player->actor.world.pos.y + 50.0f, 0.3f, 5.0f, 0.0f);\n    } else {\n        Actor_Kill(&this->actor);\n    }\n}\n\nconst ActorProfile En_UiElement_InitVars = {\n    /**/ ACTOR_EN_UI_ELEMENT,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnUiElement),\n    /**/ EnUiElement_Init,\n    /**/ EnUiElement_Destroy,\n    /**/ EnUiElement_Update,\n    /**/ EnUiElement_Draw\n};"}
{"instruction": "Create a debugging help system", "output": "{\n  \"instruction\": \"Make a debugging help that follows OoT decompilation standards with complex interaction patterns\",\n  \"input\": null,\n  \"output\": \"\n```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 debugState;\n    /* 0x014E */ s16 debugTimer;\n    /* 0x0150 */ f32 displayRange;\n    /* 0x0154 */ Vec3f lastPos;\n    /* 0x0160 */ ColliderCylinder collider;\n} EnDebugHelper;\n\nvoid EnDebugHelper_Init(Actor* thisx, PlayState* play) {\n    EnDebugHelper* this = (EnDebugHelper*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->displayRange = 200.0f;\n    this->debugState = 0;\n    this->debugTimer = 0;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->lastPos = this->actor.world.pos;\n}\n\nvoid EnDebugHelper_Update(Actor* thisx, PlayState* play) {\n    EnDebugHelper* this = (EnDebugHelper*)thisx;\n    Player* player = GET_PLAYER(play);\n    f32 dist;\n    \n    this->debugTimer++;\n    \n    // Check distance to player\n    dist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    if (dist < this->displayRange) {\n        // Print debug info when in range\n        osSyncPrintf(\\\"Player Distance: %f\\\\n\\\", dist);\n        osSyncPrintf(\\\"Actor Pos: %f, %f, %f\\\\n\\\", \n            this->actor.world.pos.x,\n            this->actor.world.pos.y, \n            this->actor.world.pos.z);\n            \n        // Track movement delta\n        if (this->debugTimer % 30 == 0) {\n            f32 deltaX = this->actor.world.pos.x - this->lastPos.x;\n            f32 deltaY = this->actor.world.pos.y - this->lastPos.y;\n            f32 deltaZ = this->actor.world.pos.z - this->lastPos.z;\n            \n            osSyncPrintf(\\\"Movement Delta: %f, %f, %f\\\\n\\\", deltaX, deltaY, deltaZ);\n            this->lastPos = this->actor.world.pos;\n        }\n        \n        // Check ground properties\n        if (this->actor.bgCheckFlags & UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2) {\n            osSyncPrintf(\\\"Ground Type: %d\\\\n\\\", this->actor.bgCheckFlags);\n            osSyncPrintf(\\\"Ground Y: %f\\\\n\\\", this->actor.floorHeight);\n        }\n        \n        // Print collision state\n        if (this->collider.base.acFlags & AC_HIT) {\n            osSyncPrintf(\\\"Collision Detected!\\\\n\\\");\n        }\n    }\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 20.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n                           \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnDebugHelper_Draw(Actor* thisx, PlayState* play) {\n    EnDebugHelper* this = (EnDebugHelper*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 255, 255, 0, 255);\n    \n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, \n                    this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, \n                this->actor.scale.z, MTXMODE_APPLY);\n    \n    Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_DebugHelper_InitVars = {\n    /**/ ACTOR_EN_DEBUG_HELPER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnDebugHelper),\n    /**/ EnDebugHelper_Init,\n    /**/ EnDebugHelper_Destroy,\n    /**/ EnDebugHelper_Update,\n    /**/ EnDebugHelper_Draw\n};\n```\"\n}"}
{"instruction": "Create a debugging tools system", "output": "{\n  \"instruction\": \"Make a debugging tools that follows OoT decompilation standards with complex mathematical calculations\",\n  \"input\": null,\n  \"output\": \"```c\n// Debug math visualization actor\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 mode;\n    /* 0x0150 */ f32 radius;\n    /* 0x0154 */ f32 angle;\n    /* 0x0158 */ Vec3f points[16];\n    /* 0x01F8 */ ColliderCylinder collider;\n} EnDbgMath; // size = 0x244\n\nvoid EnDbgMath_Init(Actor* thisx, PlayState* play) {\n    EnDbgMath* this = (EnDbgMath*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->timer = 0;\n    this->mode = 0;\n    this->radius = 50.0f;\n    this->angle = 0.0f;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n}\n\nvoid EnDbgMath_Destroy(Actor* thisx, PlayState* play) {\n    EnDbgMath* this = (EnDbgMath*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnDbgMath_CalcSineWave(EnDbgMath* this) {\n    s32 i;\n    f32 step = (2.0f * M_PI) / 16.0f;\n    \n    for (i = 0; i < 16; i++) {\n        this->points[i].x = Math_SinS(this->angle + (i * step) * (0x4000 / M_PI)) * this->radius;\n        this->points[i].y = Math_CosS(this->angle * 2) * 20.0f;\n        this->points[i].z = Math_CosS(this->angle + (i * step) * (0x4000 / M_PI)) * this->radius;\n    }\n}\n\nvoid EnDbgMath_CalcLissajous(EnDbgMath* this) {\n    s32 i;\n    f32 step = (2.0f * M_PI) / 16.0f;\n    \n    for (i = 0; i < 16; i++) {\n        f32 t = i * step;\n        this->points[i].x = Math_SinS((this->angle + t * 2) * (0x4000 / M_PI)) * this->radius;\n        this->points[i].y = Math_CosS((this->angle + t * 3) * (0x4000 / M_PI)) * 30.0f;\n        this->points[i].z = Math_SinS((this->angle + t * 4) * (0x4000 / M_PI)) * this->radius;\n    }\n}\n\nvoid EnDbgMath_Update(Actor* thisx, PlayState* play) {\n    EnDbgMath* this = (EnDbgMath*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    this->angle += 0x0200;\n    \n    if (sqrtf(SQ(dx) + SQ(dz))(&this->actor.world.pos, &player->actor.world.pos) < 100.0f) {\n        if (CHECK_BTN_ALL(input->press.button, BTN_A)) {\n            this->mode ^= 1;\n        }\n    }\n    \n    if (this->mode == 0) {\n        EnDbgMath_CalcSineWave(this);\n    } else {\n        EnDbgMath_CalcLissajous(this);\n    }\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 20.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n}\n\nvoid EnDbgMath_Draw(Actor* thisx, PlayState* play) {\n    EnDbgMath* this = (EnDbgMath*)thisx;\n    s32 i;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 255, 128, 0, 255);\n    \n    for (i = 0; i < 16; i++) {\n        Matrix_Translate(this->points[i].x, this->points[i].y, this->points[i].z, MTXMODE_NEW);\n        Matrix_Scale(0.2f, 0.2f, 0.2f, MTXMODE_APPLY);\n        \n        Matrix_Push();\n        Matrix_ReplaceRotation(&play->billboardMtxF);\n        gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__), \n                  G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n        gSPDisplayList(POLY_OPA_DISP++, gDebugPointDL);\n        Matrix_Pop();\n    }\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Dbg_Math_InitVars = {\n    /**/ ACTOR_EN_DBG_MATH,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnDbgMath),\n    /**/ EnDbgMath_Init,\n    /**/ EnDbgMath_Destroy,\n    /**/ EnDbgMath_Update,\n    /**/ EnDbgMath_Draw\n};\n```\"\n}"}
{"instruction": "Create a actor creation system", "output": "{\n  \"instruction\": \"Explain how to build a shadow assassin with the ability to coordinate attacks with other enemies using simple mechanics in tight corridor spaces with basic functionality\",\n  \"input\": null,\n  \"output\": \"```c\n// Shadow assassin that coordinates with nearby enemies in corridors\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 targetDist;\n    /* 0x0154 */ Vec3f initPos;\n    /* 0x0160 */ ColliderCylinder collider;\n    /* 0x01AC */ Actor* targetActor;\n} EnShadowNinja; // size = 0x1B0\n\nvoid EnShadowNinja_Init(Actor* thisx, PlayState* play) {\n    EnShadowNinja* this = (EnShadowNinja*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.colChkInfo.mass = 0;\n    this->actor.colChkInfo.health = 4;\n    Actor_SetScale(&this->actor, 0.01f);\n    \n    this->actionState = 0;\n    this->timer = 0;\n    this->targetDist = 0.0f;\n    \n    // Store initial position for return point\n    this->initPos = this->actor.world.pos;\n}\n\nvoid EnShadowNinja_Update(Actor* thisx, PlayState* play) {\n    EnShadowNinja* this = (EnShadowNinja*)thisx;\n    Player* player = GET_PLAYER(play);\n    s32 pad;\n    \n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Basic state machine\n    switch(this->actionState) {\n        case 0: // Search state\n            this->targetDist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n            \n            // Look for nearby enemies to coordinate with\n            Actor* nearEnemy = play->actorCtx.actorLists[ACTORCAT_ENEMY].head;\n            while (nearEnemy != NULL) {\n                if (nearEnemy != &this->actor && \n                    Actor_WorldDistXZToActor(&this->actor, nearEnemy) < 200.0f) {\n                    this->targetActor = nearEnemy;\n                    this->actionState = 1;\n                    break;\n                }\n                nearEnemy = nearEnemy->next;\n            }\n            \n            // If player is close, prepare to attack\n            if (this->targetDist < 150.0f) {\n                this->actionState = 2;\n                this->timer = 30;\n            }\n            break;\n            \n        case 1: // Coordinate with other enemy\n            if (this->targetActor == NULL || this->targetActor->update == NULL) {\n                this->actionState = 0;\n                break;\n            }\n            \n            // Move to flank position relative to coordinating enemy\n            Vec3f targetPos;\n            targetPos.x = this->targetActor->world.pos.x + 80.0f;\n            targetPos.y = this->targetActor->world.pos.y;\n            targetPos.z = this->targetActor->world.pos.z + 80.0f;\n            \n            Math_SmoothStepToF(&this->actor.world.pos.x, targetPos.x, 0.3f, 5.0f, 0.0f);\n            Math_SmoothStepToF(&this->actor.world.pos.z, targetPos.z, 0.3f, 5.0f, 0.0f);\n            \n            if (this->targetDist < 100.0f) {\n                this->actionState = 2;\n                this->timer = 20;\n            }\n            break;\n            \n        case 2: // Attack state\n            if (this->timer > 0) {\n                this->timer--;\n            } else {\n                // Quick lunge attack toward player\n                f32 dx = player->actor.world.pos.x - this->actor.world.pos.x;\n                f32 dz = player->actor.world.pos.z - this->actor.world.pos.z;\n                f32 dist = sqrtf(SQ(dx) + SQ(dz));\n                \n                if (dist > 1.0f) {\n                    this->actor.world.pos.x += (dx / dist) * 8.0f;\n                    this->actor.world.pos.z += (dz / dist) * 8.0f;\n                }\n                \n                if (this->targetDist > 200.0f) {\n                    this->actionState = 0;\n                }\n            }\n            break;\n    }\n    \n    // Update background collision\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 0.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n}\n\nconst ActorProfile En_ShadowNinja_InitVars = {\n    /**/ ACTOR_EN_SHADOW_NINJA,\n    /**/ ACTORCAT_ENEMY,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnShadowNinja),\n    /**/ EnShadowNinja_Init,\n    /**/ EnShadowNinja_Destroy,\n    /**/ EnShadowNinja_Update,\n    /**/ NULL\n};\n```\"\n}"}
{"instruction": "Create a optimization system", "output": "{\n  \"instruction\": \"Create a optimization system with proper OoT patterns implementing standard patterns\",\n  \"input\": null,\n  \"output\": \"```c\n// Authentic pattern following z_en_item00.c style\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState; \n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n    /* 0x01A0 */ Vec3f effectPos;\n} EnOptimize; // size = 0x1AC\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000010, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnOptimize_Init(Actor* thisx, PlayState* play) {\n    EnOptimize* this = (EnOptimize*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->timer = 0;\n    this->actionState = 0;\n    this->scale = 1.0f;\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 35.0f, 60.0f, 60.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n}\n\nvoid EnOptimize_Destroy(Actor* thisx, PlayState* play) {\n    EnOptimize* this = (EnOptimize*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnOptimize_Update(Actor* thisx, PlayState* play) {\n    EnOptimize* this = (EnOptimize*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 100.0f) {\n        Math_SmoothStepToF(&this->scale, 1.5f, 0.1f, 0.5f, 0.01f);\n    } else {\n        Math_SmoothStepToF(&this->scale, 1.0f, 0.1f, 0.5f, 0.01f);\n    }\n    \n    Actor_SetScale(&this->actor, this->scale * 0.01f);\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 35.0f, 60.0f, 60.0f,\n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n}\n\nvoid EnOptimize_Draw(Actor* thisx, PlayState* play) {\n    EnOptimize* this = (EnOptimize*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Push();\n    Matrix_Scale(this->scale, this->scale, this->scale, MTXMODE_APPLY);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n    Matrix_Pop();\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Optimize_InitVars = {\n    /**/ ACTOR_EN_OPTIMIZE,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnOptimize),\n    /**/ EnOptimize_Init,\n    /**/ EnOptimize_Destroy,\n    /**/ EnOptimize_Update,\n    /**/ EnOptimize_Draw\n};\n```\"\n}"}
{"instruction": "Create a environmental system", "output": "{\n  \"instruction\": \"Implement a Fire Temple lava flow mechanics with minimal features\",\n  \"input\": null,\n  \"output\": \"\n```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 flowState;\n    /* 0x0150 */ f32 flowSpeed;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnFireFlow; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_ON | AT_TYPE_ENEMY,\n        AC_NONE,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x20000000, 0x01, 0x04 },\n        { 0x00000000, 0x00, 0x00 },\n        TOUCH_ON | TOUCH_SFX_NONE,\n        BUMP_NONE,\n        OCELEM_ON,\n    },\n    { 30, 45, 0, { 0, 0, 0 } },\n};\n\nvoid EnFireFlow_Init(Actor* thisx, PlayState* play) {\n    EnFireFlow* this = (EnFireFlow*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.flags |= ACTOR_FLAG_4;\n    Actor_SetScale(&this->actor, 0.1f);\n    \n    this->flowSpeed = 2.0f;\n    this->flowState = 0;\n    this->timer = 0;\n}\n\nvoid EnFireFlow_Destroy(Actor* thisx, PlayState* play) {\n    EnFireFlow* this = (EnFireFlow*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnFireFlow_Update(Actor* thisx, PlayState* play) {\n    EnFireFlow* this = (EnFireFlow*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    // Move along Z axis\n    this->actor.world.pos.z += this->flowSpeed;\n    \n    // Reset position after flowing certain distance\n    if (this->actor.world.pos.z > (this->actor.home.pos.z + 300.0f)) {\n        this->actor.world.pos.z = this->actor.home.pos.z;\n    }\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAT(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Damage player on contact\n    if (this->collider.base.atFlags & AT_HIT) {\n        this->collider.base.atFlags &= ~AT_HIT;\n        gSaveContext.health -= 4;\n    }\n}\n\nvoid EnFireFlow_Draw(Actor* thisx, PlayState* play) {\n    EnFireFlow* this = (EnFireFlow*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 255, 50, 0, 255);\n    \n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, this->actor.scale.z, MTXMODE_APPLY);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__), \n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n              \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_FireFlow_InitVars = {\n    /**/ ACTOR_EN_FIRE_FLOW,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnFireFlow),\n    /**/ EnFireFlow_Init,\n    /**/ EnFireFlow_Destroy,\n    /**/ EnFireFlow_Update,\n    /**/ EnFireFlow_Draw\n};\n```\n\"}"}
{"instruction": "Create a actor creation system", "output": "{\n  \"instruction\": \"How would you implement a innkeeper that character customization options? with inventory management for a temporary event with simple documentation\",\n  \"input\": null,\n  \"output\": \"```c\n// En_Innkeeper - Simple innkeeper NPC with customization options\n// Based on authentic OoT NPC patterns\n\n#include \\\"z_en_innkeeper.h\\\"\n#include \\\"assets/objects/object_innkeeper/object_innkeeper.h\\\"\n\ntypedef enum {\n    /* 0 */ INNKEEPER_IDLE,\n    /* 1 */ INNKEEPER_TALK,\n    /* 2 */ INNKEEPER_CUSTOMIZE\n} InnkeeperState;\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ Vec3s jointTable[20];\n    /* 0x01F4 */ Vec3s morphTable[20];\n    /* 0x0258 */ s16 actionState;\n    /* 0x025A */ s16 dialogState;\n    /* 0x025C */ s16 blinkTimer;\n    /* 0x025E */ s16 eyeState;\n    /* 0x0260 */ ColliderCylinder collider;\n} EnInnkeeper; // size = 0x02AC\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_NONE,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000000, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_NONE,\n        OCELEM_ON,\n    },\n    { 20, 60, 0, { 0, 0, 0 } },\n};\n\nvoid EnInnkeeper_Init(Actor* thisx, PlayState* play) {\n    EnInnkeeper* this = (EnInnkeeper*)thisx;\n    \n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 36.0f);\n    SkelAnime_InitFlex(play, &this->skelAnime, &gInnkeeperSkel, &gInnkeeperIdleAnim, \n                       this->jointTable, this->morphTable, 20);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.targetMode = 6;\n    Actor_SetScale(&this->actor, 0.01f);\n    \n    this->actionState = INNKEEPER_IDLE;\n    this->dialogState = 0;\n    this->blinkTimer = 20;\n    this->eyeState = 0;\n}\n\nvoid EnInnkeeper_Destroy(Actor* thisx, PlayState* play) {\n    EnInnkeeper* this = (EnInnkeeper*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnInnkeeper_Update(Actor* thisx, PlayState* play) {\n    EnInnkeeper* this = (EnInnkeeper*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Handle blinking\n    if (this->blinkTimer > 0) {\n        this->blinkTimer--;\n    } else {\n        this->blinkTimer = (s16)Rand_ZeroFloat(60.0f) + 20;\n        this->eyeState = 2;  // Blink state\n    }\n    \n    // Basic interaction distance check\n    if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 100.0f) {\n        if (Actor_ProcessTalkRequest(&this->actor, play)) {\n            this->actionState = INNKEEPER_TALK;\n        }\n    }\n    \n    // Update animation\n    SkelAnime_Update(&this->skelAnime);\n}\n\nvoid EnInnkeeper_Draw(Actor* thisx, PlayState* play) {\n    EnInnkeeper* this = (EnInnkeeper*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    // Draw character model with current customization\n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                          this->skelAnime.dListCount, NULL, NULL, this);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Innkeeper_InitVars = {\n    /**/ ACTOR_EN_INNKEEPER,\n    /**/ ACTORCAT_NPC,\n    /**/ FLAGS,\n    /**/ OBJECT_INNKEEPER,\n    /**/ sizeof(EnInnkeeper),\n    /**/ EnInnkeeper_Init,\n    /**/ EnInnkeeper_Destroy,\n    /**/ EnInnkeeper_Update,\n    /**/ EnInnkeeper_Draw\n};\n```\"\n}"}
{"instruction": "Create a actor creation system", "output": "{\n  \"instruction\": \"Explain how to build a earth titan with the ability to mirror the player's equipped weapon and abilities with complex state management with complex interaction patterns\",\n  \"input\": null,\n  \"output\": \"```c\n// EnEarthTitan.h\ntypedef enum {\n    /* 0x00 */ ETITAN_STATE_IDLE,\n    /* 0x01 */ ETITAN_STATE_RISE,\n    /* 0x02 */ ETITAN_STATE_COMBAT,\n    /* 0x03 */ ETITAN_STATE_DAMAGED,\n    /* 0x04 */ ETITAN_STATE_DEATH\n} EarthTitanState;\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ Vec3s jointTable[25];\n    /* 0x01F4 */ Vec3s morphTable[25];\n    /* 0x0258 */ s16 actionTimer;\n    /* 0x025A */ s16 actionState;\n    /* 0x025C */ s16 attackTimer;\n    /* 0x025E */ s16 mirroredWeapon;\n    /* 0x0260 */ f32 attackRange;\n    /* 0x0264 */ ColliderCylinder bodyCollider;\n    /* 0x02B0 */ ColliderQuad weaponCollider;\n} EnEarthTitan;\n\n// EnEarthTitan.c\n#include \\\"z_en_earth_titan.h\\\"\n#include \\\"assets/objects/object_titan/object_titan.h\\\"\n\n#define TITAN_HEALTH 16\n#define TITAN_DAMAGE 4\n#define TITAN_SCALE 0.015f\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_HIT0,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 30, 100, 0, { 0, 0, 0 } },\n};\n\nvoid EnEarthTitan_Init(Actor* thisx, PlayState* play) {\n    EnEarthTitan* this = (EnEarthTitan*)thisx;\n    \n    Actor_SetScale(&this->actor, TITAN_SCALE);\n    \n    SkelAnime_InitFlex(play, &this->skelAnime, &gTitanSkel, &gTitanIdleAnim, \n                       this->jointTable, this->morphTable, 25);\n    \n    Collider_InitCylinder(play, &this->bodyCollider);\n    Collider_SetCylinder(play, &this->bodyCollider, &this->actor, &sCylinderInit);\n    \n    this->actor.colChkInfo.health = TITAN_HEALTH;\n    this->actionState = ETITAN_STATE_RISE;\n    this->attackRange = 150.0f;\n    \n    Actor_SetFocus(&this->actor, 60.0f);\n}\n\nvoid EnEarthTitan_UpdateWeaponState(EnEarthTitan* this, PlayState* play) {\n    Player* player = GET_PLAYER(play);\n    \n    // Mirror player's equipped sword\n    if (gSaveContext.equips.buttonItems[0] != this->mirroredWeapon) {\n        this->mirroredWeapon = gSaveContext.equips.buttonItems[0];\n        // Update titan's weapon collision properties based on mirrored weapon\n    }\n}\n\nvoid EnEarthTitan_Combat(EnEarthTitan* this, PlayState* play) {\n    Player* player = GET_PLAYER(play);\n    f32 distToPlayer = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    if (distToPlayer < this->attackRange) {\n        if (this->attackTimer <= 0) {\n            // Mirror player's attack pattern\n            if (gSaveContext.equips.buttonItems[0] == ITEM_SWORD_MASTER) {\n                // Execute master sword attack pattern\n                this->attackTimer = 20;\n            } else if (gSaveContext.equips.buttonItems[0] == ITEM_SWORD_KOKIRI) {\n                // Execute kokiri sword attack pattern\n                this->attackTimer = 15;\n            }\n        }\n    }\n    \n    if (this->attackTimer > 0) {\n        this->attackTimer--;\n    }\n}\n\nvoid EnEarthTitan_Update(Actor* thisx, PlayState* play) {\n    EnEarthTitan* this = (EnEarthTitan*)thisx;\n    \n    EnEarthTitan_UpdateWeaponState(this, play);\n    \n    switch (this->actionState) {\n        case ETITAN_STATE_RISE:\n            if (this->actionTimer++ > 30) {\n                this->actionState = ETITAN_STATE_COMBAT;\n            }\n            break;\n            \n        case ETITAN_STATE_COMBAT:\n            EnEarthTitan_Combat(this, play);\n            break;\n            \n        case ETITAN_STATE_DAMAGED:\n            if (this->actionTimer-- <= 0) {\n                this->actionState = ETITAN_STATE_COMBAT;\n            }\n            break;\n    }\n    \n    // Update collisions\n    Collider_UpdateCylinder(&this->actor, &this->bodyCollider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->bodyCollider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->bodyCollider.base);\n    \n    // Update animations\n    SkelAnime_Update(&this->skelAnime);\n    \n    // Update ground physics\n    Actor_UpdateBgCheckInfo(play, &this->actor, 35.0f, 60.0f, 60.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n}\n\nconst ActorProfile En_EarthTitan_InitVars = {\n    /**/ ACTOR_EN_EARTH_TITAN,\n    /**/ ACTORCAT_ENEMY,\n    /**/ FLAGS,\n    /**/ OBJECT_TITAN,\n    /**/ sizeof(EnEarthTitan),\n    /**/ EnEarthTitan_Init,\n    /**/ EnEarthTitan_Destroy,\n    /**/ EnEarthTitan_Update,\n    /**/ EnEarthTitan_Draw\n};\n```\"\n}"}
{"instruction": "Create a collision system system", "output": "{\n  \"instruction\": \"Create a collision filtering system for different object types implementing sophisticated AI behaviors\",\n  \"input\": null,\n  \"output\": \"\n```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 behaviorState;\n    /* 0x0150 */ f32 detectionRange;\n    /* 0x0154 */ Vec3f lastPos;\n    /* 0x0160 */ Vec3f targetPos;\n    /* 0x016C */ ColliderCylinder collider;\n    /* 0x01B8 */ ColliderJntSph colliderSph;\n    /* 0x01D8 */ ColliderJntSphElement elements[1];\n} EnSensor; // size = 0x0218\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 25, 60, 0, { 0, 0, 0 } },\n};\n\nstatic ColliderJntSphElementInit sJntSphElementsInit[1] = {\n    {\n        {\n            ELEMTYPE_UNK0,\n            { 0x00000000, 0x00, 0x00 },\n            { 0xFFCFFFFF, 0x00, 0x00 },\n            TOUCH_NONE,\n            BUMP_ON,\n            OCELEM_ON,\n        },\n        { 0, { { 0, 0, 0 }, 20 }, 100 },\n    },\n};\n\nstatic ColliderJntSphInit sJntSphInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_JNTSPH,\n    },\n    1,\n    sJntSphElementsInit,\n};\n\nvoid EnSensor_Init(Actor* thisx, PlayState* play) {\n    EnSensor* this = (EnSensor*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Collider_InitJntSph(play, &this->colliderSph);\n    Collider_SetJntSph(play, &this->colliderSph, &this->actor, &sJntSphInit, this->elements);\n    \n    this->detectionRange = 200.0f;\n    this->behaviorState = 0;\n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnSensor_FilterCollisions(EnSensor* this, PlayState* play) {\n    Player* player = GET_PLAYER(play);\n    f32 dx = player->actor.world.pos.x - this->actor.world.pos.x;\n    f32 dz = player->actor.world.pos.z - this->actor.world.pos.z;\n    f32 dist = sqrtf(SQ(dx) + SQ(dz));\n    \n    if (dist < this->detectionRange) {\n        if (this->collider.base.acFlags & AC_HIT) {\n            this->behaviorState = 1;\n            this->targetPos = player->actor.world.pos;\n        }\n        \n        if (this->colliderSph.base.ocFlags1 & OC1_HIT) {\n            this->behaviorState = 2;\n            this->lastPos = this->actor.world.pos;\n        }\n    }\n}\n\nvoid EnSensor_Update(Actor* thisx, PlayState* play) {\n    EnSensor* this = (EnSensor*)thisx;\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 50.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->colliderSph.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->colliderSph.base);\n    \n    EnSensor_FilterCollisions(this, play);\n    \n    switch (this->behaviorState) {\n        case 0:\n            Math_SmoothStepToF(&this->actor.speedXZ, 2.0f, 0.3f, 1.0f, 0.0f);\n            break;\n        case 1:\n            Math_SmoothStepToF(&this->actor.world.pos.x, this->targetPos.x, 0.3f, 5.0f, 0.0f);\n            Math_SmoothStepToF(&this->actor.world.pos.z, this->targetPos.z, 0.3f, 5.0f, 0.0f);\n            break;\n        case 2:\n            Math_SmoothStepToF(&this->actor.world.pos.x, this->lastPos.x, 0.5f, 8.0f, 0.0f);\n            Math_SmoothStepToF(&this->actor.world.pos.z, this->lastPos.z, 0.5f, 8.0f, 0.0f);\n            break;\n    }\n}\n\nconst ActorProfile En_Sensor_InitVars = {\n    /**/ ACTOR_EN_SENSOR,\n    /**/ ACTORCAT_ENEMY,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnSensor),\n    /**/ EnSensor_Init,\n    /**/ EnSensor_Destroy,\n    /**/ EnSensor_Update,\n    /**/ NULL\n};\n```\n\"}"}
{"instruction": "Create a actor creation system", "output": "{\n  \"instruction\": \"Build a temporal gate object that synchronizes with other mechanisms when activated using interconnected systems for platforming challenges using established conventions\",\n  \"input\": null,\n  \"output\": \"\n```c\n#include \\\"z_en_time_gate.h\\\"\n\n#define FLAGS (ACTOR_FLAG_0 | ACTOR_FLAG_4)\n\ntypedef enum {\n    /* 0 */ TIME_GATE_WAIT,\n    /* 1 */ TIME_GATE_OPEN,\n    /* 2 */ TIME_GATE_ACTIVE\n} TimeGateState;\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ ColliderCylinder collider;\n    /* 0x0198 */ SkelAnime skelAnime;\n    /* 0x01DC */ Vec3s jointTable[10];\n    /* 0x0204 */ Vec3s morphTable[10];\n    /* 0x022C */ s16 timer;\n    /* 0x022E */ s16 actionState;\n    /* 0x0230 */ f32 openAmount;\n    /* 0x0234 */ s16 switchFlag;\n} EnTimeGate; // size = 0x0238\n\nvoid EnTimeGate_Init(Actor* thisx, PlayState* play) {\n    EnTimeGate* this = (EnTimeGate*)thisx;\n    s32 pad;\n\n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 30.0f);\n    SkelAnime_InitFlex(play, &this->skelAnime, &gTimeGateSkel, &gTimeGateIdleAnim, \n                       this->jointTable, this->morphTable, 10);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\n    Actor_SetScale(&this->actor, 0.1f);\n    \n    this->actionState = TIME_GATE_WAIT;\n    this->openAmount = 0.0f;\n    this->timer = 0;\n    this->switchFlag = (this->actor.params >> 8) & 0x3F;\n}\n\nvoid EnTimeGate_Destroy(Actor* thisx, PlayState* play) {\n    EnTimeGate* this = (EnTimeGate*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnTimeGate_Update(Actor* thisx, PlayState* play) {\n    EnTimeGate* this = (EnTimeGate*)thisx;\n    s32 pad;\n\n    if (this->timer > 0) {\n        this->timer--;\n    }\n\n    switch (this->actionState) {\n        case TIME_GATE_WAIT:\n            if (Flags_GetSwitch(play, this->switchFlag)) {\n                this->actionState = TIME_GATE_OPEN;\n                this->timer = 30;\n            }\n            break;\n\n        case TIME_GATE_OPEN:\n            Math_SmoothStepToF(&this->openAmount, 1.0f, 0.2f, 0.4f, 0.01f);\n            if (this->timer == 0) {\n                this->actionState = TIME_GATE_ACTIVE;\n            }\n            break;\n\n        case TIME_GATE_ACTIVE:\n            if (!Flags_GetSwitch(play, this->switchFlag)) {\n                Math_SmoothStepToF(&this->openAmount, 0.0f, 0.2f, 0.4f, 0.01f);\n                if (this->openAmount < 0.01f) {\n                    this->actionState = TIME_GATE_WAIT;\n                }\n            }\n            break;\n    }\n\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnTimeGate_Draw(Actor* thisx, PlayState* play) {\n    EnTimeGate* this = (EnTimeGate*)thisx;\n    s32 pad;\n\n    OPEN_DISPS(play->state.gfxCtx);\n\n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Push();\n    Matrix_Translate(0.0f, this->openAmount * 50.0f, 0.0f, MTXMODE_APPLY);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n    \n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                          this->skelAnime.dListCount, NULL, NULL, this);\n    Matrix_Pop();\n\n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_TimeGate_InitVars = {\n    /**/ ACTOR_EN_TIME_GATE,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_TIME_GATE,\n    /**/ sizeof(EnTimeGate),\n    /**/ EnTimeGate_Init,\n    /**/ EnTimeGate_Destroy,\n    /**/ EnTimeGate_Update,\n    /**/ EnTimeGate_Draw\n};\n```\n\"}"}
{"instruction": "Create a ai behavior system", "output": "{\n  \"instruction\": \"Create a Hookshot targeting and grappling system with complex mathematical calculations\",\n  \"input\": null,\n  \"output\": \"// Authentic grappling point actor pattern\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ ColliderCylinder collider;\n    /* 0x0198 */ f32 hookshotRange;\n    /* 0x019C */ s16 targetTimer;\n    /* 0x019E */ s16 actionState;\n} EnHookPoint; // size = 0x01A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 12, 60, 0, { 0, 0, 0 } },\n};\n\nvoid EnHookPoint_Init(Actor* thisx, PlayState* play) {\n    EnHookPoint* this = (EnHookPoint*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->hookshotRange = 320.0f;\n    this->targetTimer = 0;\n    this->actionState = 0;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnHookPoint_Destroy(Actor* thisx, PlayState* play) {\n    EnHookPoint* this = (EnHookPoint*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnHookPoint_Update(Actor* thisx, PlayState* play) {\n    EnHookPoint* this = (EnHookPoint*)thisx;\n    Player* player = GET_PLAYER(play);\n    Vec3f targetDir;\n    f32 targetDist;\n    \n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Calculate distance and direction to player\n    targetDir.x = this->actor.world.pos.x - player->actor.world.pos.x;\n    targetDir.y = this->actor.world.pos.y - player->actor.world.pos.y;\n    targetDir.z = this->actor.world.pos.z - player->actor.world.pos.z;\n    targetDist = sqrtf(SQ(targetDir.x) + SQ(targetDir.y) + SQ(targetDir.z));\n    \n    // Check if player has hookshot equipped and is in range\n    if (gSaveContext.inventory.items[SLOT_HOOKSHOT] != ITEM_NONE && \n        targetDist < this->hookshotRange) {\n        \n        // Calculate angle between player and target\n        s16 yawToTarget = Math_Vec3f_Yaw(&player->actor.world.pos, &this->actor.world.pos);\n        s16 pitchToTarget = Math_Vec3f_Pitch(&player->actor.world.pos, &this->actor.world.pos);\n        \n        // Check if player is facing target within angle threshold\n        if (ABS((s16)(yawToTarget - player->actor.world.rot.y)) < 0x2000 &&\n            ABS((s16)(pitchToTarget - player->actor.world.rot.x)) < 0x2000) {\n            \n            this->targetTimer++;\n            if (this->targetTimer > 3) {\n                this->actionState = 1;\n            }\n        } else {\n            this->targetTimer = 0;\n            this->actionState = 0;\n        }\n    } else {\n        this->targetTimer = 0;\n        this->actionState = 0;\n    }\n}\n\nvoid EnHookPoint_Draw(Actor* thisx, PlayState* play) {\n    EnHookPoint* this = (EnHookPoint*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 255, 255, 255, 255);\n    \n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, \n                    this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, \n                this->actor.scale.z, MTXMODE_APPLY);\n    \n    Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_HookPoint_InitVars = {\n    /**/ ACTOR_EN_HOOK_POINT,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnHookPoint),\n    /**/ EnHookPoint_Init,\n    /**/ EnHookPoint_Destroy,\n    /**/ EnHookPoint_Update,\n    /**/ EnHookPoint_Draw\n};\"\n}"}
{"instruction": "Create a effect system system", "output": "{\n  \"instruction\": \"Create a Saria's Song effect that calls for help with complex interaction patterns\",\n  \"input\": null,\n  \"output\": \"```c\n// Saria's Song effect actor that creates a magical effect when played\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 scale;\n    /* 0x0152 */ s16 alpha;\n    /* 0x0154 */ Vec3f effectPos[3];\n    /* 0x0178 */ ColliderCylinder collider;\n} EnSariaEffect; // size = 0x1C4\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_NONE,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000000, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_NONE,\n        OCELEM_ON,\n    },\n    { 25, 40, 0, { 0, 0, 0 } },\n};\n\nvoid EnSariaEffect_Init(Actor* thisx, PlayState* play) {\n    EnSariaEffect* this = (EnSariaEffect*)thisx;\n    s32 i;\n\n    Actor_SetScale(&this->actor, 0.01f);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->timer = 0;\n    this->actionState = 0;\n    this->alpha = 255;\n    \n    for (i = 0; i < 3; i++) {\n        this->effectPos[i] = this->actor.world.pos;\n    }\n}\n\nvoid EnSariaEffect_Destroy(Actor* thisx, PlayState* play) {\n    EnSariaEffect* this = (EnSariaEffect*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnSariaEffect_Update(Actor* thisx, PlayState* play) {\n    EnSariaEffect* this = (EnSariaEffect*)thisx;\n    Player* player = GET_PLAYER(play);\n    s32 i;\n    \n    this->timer++;\n    \n    switch (this->actionState) {\n        case 0:\n            if (this->timer > 30) {\n                this->actionState = 1;\n                this->timer = 0;\n            }\n            break;\n            \n        case 1:\n            // Spiral effect movement\n            for (i = 0; i < 3; i++) {\n                f32 angle = (this->timer * 0.2f) + (i * (M_PI * 2.0f / 3.0f));\n                this->effectPos[i].x = this->actor.world.pos.x + (sinf(angle) * 30.0f);\n                this->effectPos[i].y = this->actor.world.pos.y + (this->timer * 0.5f);\n                this->effectPos[i].z = this->actor.world.pos.z + (cosf(angle) * 30.0f);\n            }\n            \n            // Check if Saria's Song was played\n            if (player->stateFlags2 & 0x80) {\n                this->actionState = 2;\n                this->timer = 0;\n            }\n            \n            if (this->timer > 100) {\n                Actor_Kill(&this->actor);\n            }\n            break;\n            \n        case 2:\n            this->alpha -= 5;\n            if (this->alpha <= 0) {\n                Actor_Kill(&this->actor);\n            }\n            break;\n    }\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnSariaEffect_Draw(Actor* thisx, PlayState* play) {\n    EnSariaEffect* this = (EnSariaEffect*)thisx;\n    s32 i;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    // Draw sparkle effects at each position\n    for (i = 0; i < 3; i++) {\n        Matrix_Push();\n        Matrix_Translate(this->effectPos[i].x, this->effectPos[i].y, this->effectPos[i].z, MTXMODE_NEW);\n        Matrix_Scale(0.2f, 0.2f, 0.2f, MTXMODE_APPLY);\n        Matrix_RotateY(this->timer * 0.1f, MTXMODE_APPLY);\n        \n        gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 100, 255, 100, this->alpha);\n        gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n                 G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n        gSPDisplayList(POLY_OPA_DISP++, gEffSparklesDL);\n        \n        Matrix_Pop();\n    }\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_SariaEffect_InitVars = {\n    /**/ ACTOR_EN_SARIA_EFFECT,\n    /**/ ACTORCAT_MISC,\n    /**/ FLAGS_0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnSariaEffect),\n    /**/ EnSariaEffect_Init,\n    /**/ EnSariaEffect_Destroy,\n    /**/ EnSariaEffect_Update,\n    /**/ EnSariaEffect_Draw\n};\n```\"\n}"}
{"instruction": "Create a interaction system system", "output": "{\n  \"instruction\": \"Make a skill system that improves with use with straightforward logic\",\n  \"input\": null,\n  \"output\": \"```c\n// In SaveContext struct (z_save.h)\nu16 swordSkillPoints;  // Added to existing SaveContext\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 skillTimer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnSkillTracker;\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000080, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnSkillTracker_Init(Actor* thisx, PlayState* play) {\n    EnSkillTracker* this = (EnSkillTracker*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->skillTimer = 0;\n    this->actionState = 0;\n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnSkillTracker_Destroy(Actor* thisx, PlayState* play) {\n    EnSkillTracker* this = (EnSkillTracker*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnSkillTracker_Update(Actor* thisx, PlayState* play) {\n    EnSkillTracker* this = (EnSkillTracker*)thisx;\n    Player* player = GET_PLAYER(play);\n\n    // Only track when player has sword equipped\n    if (gSaveContext.equips.buttonItems[0] >= ITEM_SWORD_KOKIRI &&\n        gSaveContext.equips.buttonItems[0] <= ITEM_SWORD_BIGGORON) {\n\n        // Check if player is swinging sword\n        if (player->swordAnimation >= 0x18 && player->swordAnimation <= 0x1D) {\n            this->skillTimer++;\n            \n            // Every 100 swings, increase skill points\n            if (this->skillTimer >= 100) {\n                this->skillTimer = 0;\n                if (gSaveContext.swordSkillPoints < 1000) {\n                    gSaveContext.swordSkillPoints++;\n                }\n            }\n        }\n    }\n\n    // Apply skill bonus to sword damage\n    if (gSaveContext.swordSkillPoints > 0) {\n        // Authentic damage modifier pattern\n        if (this->collider.base.acFlags & AC_HIT) {\n            this->collider.base.acFlags &= ~AC_HIT;\n            if (this->collider.base.ac->category == ACTORCAT_ENEMY) {\n                // Add 1 damage per 100 skill points\n                this->collider.info.toucher.damage += (gSaveContext.swordSkillPoints / 100);\n            }\n        }\n    }\n\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnSkillTracker_Draw(Actor* thisx, PlayState* play) {\n    // Invisible actor, no draw function needed\n}\n\nconst ActorProfile EnSkillTracker_Profile = {\n    /**/ ACTOR_EN_SKILL_TRACKER,\n    /**/ ACTORCAT_MISC,\n    /**/ FLAGS_UPDATE_WHILE_CULLED,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnSkillTracker),\n    /**/ EnSkillTracker_Init,\n    /**/ EnSkillTracker_Destroy, \n    /**/ EnSkillTracker_Update,\n    /**/ EnSkillTracker_Draw\n};\n```\"\n}"}
{"instruction": "Create a puzzle system system", "output": "{\n  \"instruction\": \"I need a crystal mechanism that can controls water levels and flow with multiple states for platforming challenges using efficient algorithms\",\n  \"input\": null,\n  \"output\": \"```c\n// Crystal switch that controls water levels through room settings\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 switchState;\n    /* 0x0150 */ f32 crystalScale;\n    /* 0x0154 */ ColliderCylinder collider;\n    /* 0x01A0 */ s16 roomData[4]; // Store original room water settings\n} EnWaterCrystal;\n\nvoid EnWaterCrystal_Init(Actor* thisx, PlayState* play) {\n    EnWaterCrystal* this = (EnWaterCrystal*)thisx;\n    s32 pad;\n\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->crystalScale = 1.0f;\n    this->switchState = 0;\n    \n    // Store initial room water settings\n    for (s32 i = 0; i < 4; i++) {\n        this->roomData[i] = play->roomCtx.curRoom.waterBoxes[i].ySurface;\n    }\n    \n    Actor_SetScale(&this->actor, 0.1f);\n}\n\nvoid EnWaterCrystal_Destroy(Actor* thisx, PlayState* play) {\n    EnWaterCrystal* this = (EnWaterCrystal*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnWaterCrystal_Update(Actor* thisx, PlayState* play) {\n    EnWaterCrystal* this = (EnWaterCrystal*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (this->timer > 0) {\n        this->timer--;\n    }\n    \n    // Check for sword hit or other weapon collision\n    if ((this->collider.base.acFlags & AC_HIT) && (this->timer == 0)) {\n        this->switchState = (this->switchState + 1) % 4;\n        this->timer = 20;\n        \n        // Update room water levels based on state\n        for (s32 i = 0; i < 4; i++) {\n            s16 heightOffset = (i == this->switchState) ? 200 : 0;\n            play->roomCtx.curRoom.waterBoxes[i].ySurface = \n                this->roomData[i] + heightOffset;\n        }\n        \n        Actor_PlaySfx(&this->actor, NA_SE_EV_WATER_LEVEL_DOWN);\n    }\n    \n    // Visual feedback\n    Math_ApproachF(&this->crystalScale, (this->timer > 0) ? 1.2f : 1.0f, 0.2f, 0.1f);\n    Actor_SetScale(&this->actor, 0.1f * this->crystalScale);\n}\n\nvoid EnWaterCrystal_Draw(Actor* thisx, PlayState* play) {\n    EnWaterCrystal* this = (EnWaterCrystal*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n              \n    gSPDisplayList(POLY_OPA_DISP++, gCrystalSwitchDL);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_WaterCrystal_InitVars = {\n    /**/ ACTOR_EN_WATER_CRYSTAL,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnWaterCrystal),\n    /**/ EnWaterCrystal_Init,\n    /**/ EnWaterCrystal_Destroy,\n    /**/ EnWaterCrystal_Update,\n    /**/ EnWaterCrystal_Draw\n};\n```\"\n}"}
{"instruction": "Implement a Boomerang throwing and returning mechanics using memory-safe practices", "output": "// Authentic boomerang actor implementation following OoT patterns\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 returnTimer;\n    /* 0x0150 */ f32 yawTarget;\n    /* 0x0154 */ f32 speedXZ;\n    /* 0x0158 */ Vec3f initPos;\n    /* 0x0164 */ ColliderCylinder collider;\n} EnBoomerang; // size = 0x1B0\n\nvoid EnBoomerang_Init(Actor* thisx, PlayState* play) {\n    EnBoomerang* this = (EnBoomerang*)thisx;\n    Player* player = GET_PLAYER(play);\n\n    Actor_SetScale(&this->actor, 0.01f);\n    this->timer = 0;\n    this->returnTimer = 0;\n    this->speedXZ = 8.0f;\n\n    // Store initial position for return path\n    this->initPos.x = this->actor.world.pos.x;\n    this->initPos.y = this->actor.world.pos.y;\n    this->initPos.z = this->actor.world.pos.z;\n\n    // Initialize collision\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n\n    // Set initial rotation toward throw direction\n    this->actor.world.rot.y = player->actor.world.rot.y;\n    this->yawTarget = player->actor.world.rot.y;\n}\n\nvoid EnBoomerang_Update(Actor* thisx, PlayState* play) {\n    EnBoomerang* this = (EnBoomerang*)thisx;\n    Player* player = GET_PLAYER(play);\n    Vec3f velocity;\n\n    this->timer++;\n\n    if (this->timer >= 30) {\n        // Start return phase\n        this->returnTimer++;\n        \n        // Calculate angle to player\n        this->yawTarget = Math_Atan2S(player->actor.world.pos.z - this->actor.world.pos.z,\n                                     player->actor.world.pos.x - this->actor.world.pos.x);\n\n        // Smoothly rotate toward player\n        Math_SmoothStepToS(&this->actor.world.rot.y, this->yawTarget, 5, 2000, 0);\n    }\n\n    // Calculate velocity based on current rotation\n    velocity.x = Math_SinS(this->actor.world.rot.y) * this->speedXZ;\n    velocity.z = Math_CosS(this->actor.world.rot.y) * this->speedXZ;\n    velocity.y = 0.0f;\n\n    // Update position\n    this->actor.world.pos.x += velocity.x;\n    this->actor.world.pos.z += velocity.z;\n\n    // Check if boomerang returned to player\n    if (this->returnTimer > 0) {\n        if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 20.0f) {\n            Actor_Kill(&this->actor);\n            return;\n        }\n    }\n\n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnBoomerang_Draw(Actor* thisx, PlayState* play) {\n    EnBoomerang* this = (EnBoomerang*)thisx;\n\n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n    gSPDisplayList(POLY_OPA_DISP++, gBoomerangDL);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Boomerang_InitVars = {\n    /**/ ACTOR_EN_BOOMERANG,\n    /**/ ACTORCAT_MISC,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnBoomerang),\n    /**/ EnBoomerang_Init,\n    /**/ Actor_Destroy,\n    /**/ EnBoomerang_Update, \n    /**/ EnBoomerang_Draw\n};"}
{"instruction": "Create a combat system system", "output": "{\n  \"instruction\": \"Make a Bomb throwing and explosion mechanics implementing essential features\",\n  \"input\": null,\n  \"output\": \"\n```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 explosionState;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnBomb; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_ON | AT_TYPE_EXPLOSIVE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x20000000, 0x01, 0x04 },\n        { 0x00000008, 0x00, 0x00 },\n        TOUCH_ON | TOUCH_SFX_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 12, 25, 0, { 0, 0, 0 } }\n};\n\nvoid EnBomb_Init(Actor* thisx, PlayState* play) {\n    EnBomb* this = (EnBomb*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.gravity = -1.0f;\n    this->timer = 70;\n    this->explosionState = 0;\n    this->scale = 1.0f;\n    \n    this->actor.velocity.y = 6.0f;\n    this->actor.velocity.z = 8.0f;\n}\n\nvoid EnBomb_Destroy(Actor* thisx, PlayState* play) {\n    EnBomb* this = (EnBomb*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnBomb_Update(Actor* thisx, PlayState* play) {\n    EnBomb* this = (EnBomb*)thisx;\n    \n    if (this->explosionState == 0) {\n        // Normal bomb state\n        Actor_MoveXZGravity(&this->actor);\n        Actor_UpdateBgCheckInfo(play, &this->actor, 12.0f, 20.0f, 0.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n        \n        if (this->actor.bgCheckFlags & UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2) {\n            this->actor.velocity.x = 0.0f;\n            this->actor.velocity.z = 0.0f;\n        }\n        \n        if (--this->timer <= 0) {\n            this->explosionState = 1;\n            this->timer = 10;\n            this->actor.velocity.x = 0.0f;\n            this->actor.velocity.y = 0.0f;\n            this->actor.velocity.z = 0.0f;\n        }\n        \n        Collider_UpdateCylinder(&this->actor, &this->collider);\n        CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n        \n    } else if (this->explosionState == 1) {\n        // Explosion state\n        if (--this->timer <= 0) {\n            Actor_Kill(&this->actor);\n            return;\n        }\n        \n        this->scale += 0.3f;\n        Actor_SetScale(&this->actor, this->scale * 0.01f);\n        \n        CollisionCheck_SetAT(play, &play->colChkCtx, &this->collider.base);\n    }\n}\n\nvoid EnBomb_Draw(Actor* thisx, PlayState* play) {\n    EnBomb* this = (EnBomb*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n              \n    // Draw bomb model here using gSPDisplayList()\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Bomb_InitVars = {\n    /**/ ACTOR_EN_BOMB,\n    /**/ ACTORCAT_EXPLOSIVE,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnBomb),\n    /**/ EnBomb_Init,\n    /**/ EnBomb_Destroy,\n    /**/ EnBomb_Update,\n    /**/ EnBomb_Draw\n};\n```\n\"}"}
{"instruction": "Create a debugging tools system", "output": "{\n  \"instruction\": \"Create an advanced debugging tools with multiple features using simple patterns\",\n  \"input\": null,\n  \"output\": \"\n```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 mode;\n    /* 0x014E */ s16 timer;\n    /* 0x0150 */ f32 displayScale;\n    /* 0x0154 */ Vec3f targetPos;\n    /* 0x0160 */ ColliderCylinder collider;\n} EnDbgTools; // size = 0x1AC\n\nvoid EnDbgTools_Init(Actor* thisx, PlayState* play) {\n    EnDbgTools* this = (EnDbgTools*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->mode = 0;\n    this->timer = 0;\n    this->displayScale = 1.0f;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n}\n\nvoid EnDbgTools_Destroy(Actor* thisx, PlayState* play) {\n    EnDbgTools* this = (EnDbgTools*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnDbgTools_Update(Actor* thisx, PlayState* play) {\n    EnDbgTools* this = (EnDbgTools*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    // Mode cycling with B button\n    if (CHECK_BTN_ALL(input->press.button, BTN_B)) {\n        this->mode = (this->mode + 1) % 3;\n    }\n    \n    switch(this->mode) {\n        case 0: // Position display\n            this->targetPos = player->actor.world.pos;\n            break;\n            \n        case 1: // Health display\n            if (CHECK_BTN_ALL(input->press.button, BTN_A)) {\n                gSaveContext.health += 16;\n                if (gSaveContext.health > gSaveContext.healthCapacity) {\n                    gSaveContext.health = gSaveContext.healthCapacity;\n                }\n            }\n            break;\n            \n        case 2: // Rupee display/modify\n            if (CHECK_BTN_ALL(input->press.button, BTN_A)) {\n                gSaveContext.rupees += 100;\n                if (gSaveContext.rupees > 999) {\n                    gSaveContext.rupees = 999;\n                }\n            }\n            break;\n    }\n}\n\nvoid EnDbgTools_Draw(Actor* thisx, PlayState* play) {\n    EnDbgTools* this = (EnDbgTools*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    // Draw debug info based on mode\n    switch(this->mode) {\n        case 0:\n            Matrix_Translate(this->targetPos.x, this->targetPos.y, this->targetPos.z, MTXMODE_NEW);\n            Matrix_Scale(0.1f, 0.1f, 0.1f, MTXMODE_APPLY);\n            Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__);\n            gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n                     G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n            gSPDisplayList(POLY_OPA_DISP++, gDebugMarkerDL);\n            break;\n    }\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Dbg_Tools_InitVars = {\n    /**/ ACTOR_EN_DBG_TOOLS,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnDbgTools),\n    /**/ EnDbgTools_Init,\n    /**/ EnDbgTools_Destroy, \n    /**/ EnDbgTools_Update,\n    /**/ EnDbgTools_Draw\n};\n```\"\n}"}
{"instruction": "Implement optimization functionality using authentic code with multiple states and transitions", "output": "// Authentic state pattern from OoT decompilation style\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 targetY;\n    /* 0x0154 */ f32 oscillation;\n    /* 0x0158 */ f32 moveSpeed;\n    /* 0x015C */ ColliderCylinder collider;\n} EnOptimizer; // size = 0x1A8\n\nenum OptimizerState {\n    /* 0 */ OPTIMIZER_IDLE,\n    /* 1 */ OPTIMIZER_RISE,\n    /* 2 */ OPTIMIZER_ACTIVE,\n    /* 3 */ OPTIMIZER_RETURN\n};\n\nvoid EnOptimizer_Init(Actor* thisx, PlayState* play) {\n    EnOptimizer* this = (EnOptimizer*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.gravity = -1.0f;\n    this->actor.flags |= ACTOR_FLAG_0;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actionState = OPTIMIZER_IDLE;\n    this->timer = 0;\n    this->moveSpeed = 2.0f;\n    this->targetY = this->actor.world.pos.y + 100.0f;\n}\n\nvoid EnOptimizer_Update(Actor* thisx, PlayState* play) {\n    EnOptimizer* this = (EnOptimizer*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    switch(this->actionState) {\n        case OPTIMIZER_IDLE:\n            if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 100.0f) {\n                this->actionState = OPTIMIZER_RISE;\n                this->timer = 0;\n            }\n            break;\n            \n        case OPTIMIZER_RISE:\n            Math_SmoothStepToF(&this->actor.world.pos.y, this->targetY, 0.3f, this->moveSpeed, 0.1f);\n            this->oscillation = Math_SinS(this->timer * 0x800) * 3.0f;\n            \n            if (this->timer > 40) {\n                this->actionState = OPTIMIZER_ACTIVE;\n                this->timer = 0;\n            }\n            break;\n            \n        case OPTIMIZER_ACTIVE:\n            this->oscillation = Math_SinS(this->timer * 0x800) * 5.0f;\n            this->actor.world.pos.x += Math_SinS(this->timer * 0x400) * 2.0f;\n            \n            if (this->timer > 100) {\n                this->actionState = OPTIMIZER_RETURN;\n                this->timer = 0;\n            }\n            break;\n            \n        case OPTIMIZER_RETURN:\n            Math_SmoothStepToF(&this->actor.world.pos.y, this->actor.home.pos.y, 0.1f, 3.0f, 0.1f);\n            \n            if (fabsf(this->actor.world.pos.y - this->actor.home.pos.y) < 1.0f) {\n                this->actionState = OPTIMIZER_IDLE;\n                this->timer = 0;\n            }\n            break;\n    }\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 20.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile En_Optimizer_InitVars = {\n    /**/ ACTOR_EN_OPTIMIZER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnOptimizer),\n    /**/ EnOptimizer_Init,\n    /**/ EnOptimizer_Destroy,\n    /**/ EnOptimizer_Update,\n    /**/ NULL\n};"}
{"instruction": "Create a interaction system system", "output": "{\n  \"instruction\": \"Create a relationship system between NPCs and the player implementing common features\",\n  \"input\": null,\n  \"output\": \"```c\n// Authentic pattern following z_actor.h structures\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 friendshipLevel;\n    /* 0x014E */ s16 interactionCount;\n    /* 0x0150 */ s16 timer;\n    /* 0x0152 */ s16 actionState;\n    /* 0x0154 */ ColliderCylinder collider;\n    /* 0x01A0 */ SkelAnime skelAnime;\n    /* 0x01E4 */ Vec3s jointTable[20];\n    /* 0x024C */ Vec3s morphTable[20];\n} EnNpcFriend;\n\nvoid EnNpcFriend_Init(Actor* thisx, PlayState* play) {\n    EnNpcFriend* this = (EnNpcFriend*)thisx;\n    \n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 30.0f);\n    SkelAnime_InitFlex(play, &this->skelAnime, &gNpcSkel, &gNpcIdleAnim, this->jointTable, \n                       this->morphTable, 20);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->friendshipLevel = 0;\n    this->interactionCount = 0;\n    this->timer = 0;\n    this->actionState = 0;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnNpcFriend_Destroy(Actor* thisx, PlayState* play) {\n    EnNpcFriend* this = (EnNpcFriend*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnNpcFriend_Update(Actor* thisx, PlayState* play) {\n    EnNpcFriend* this = (EnNpcFriend*)thisx;\n    Player* player = GET_PLAYER(play);\n    s16 yawTowardsPlayer;\n    \n    this->timer++;\n    \n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Check distance to player\n    f32 playerDist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    if (playerDist < 100.0f) {\n        // Face towards player when nearby\n        yawTowardsPlayer = Actor_WorldYawTowardActor(&this->actor, &player->actor);\n        Math_SmoothStepToS(&this->actor.world.rot.y, yawTowardsPlayer, 6, 2000, 1);\n        \n        // Interaction check when player is close and presses B\n        if (Actor_ProcessTalkRequest(&this->actor, play)) {\n            this->interactionCount++;\n            if (this->interactionCount >= 5 && this->friendshipLevel < 100) {\n                this->friendshipLevel += 10;\n                // Cap friendship level\n                if (this->friendshipLevel > 100) {\n                    this->friendshipLevel = 100;\n                }\n            }\n        }\n    }\n    \n    // Make talkable when player is close\n    if (playerDist < 100.0f) {\n        this->actor.textId = 0x1234; // Example text ID\n        func_8002F2CC(&this->actor, play, 100.0f);\n    }\n    \n    // Update animation\n    SkelAnime_Update(&this->skelAnime);\n}\n\nvoid EnNpcFriend_Draw(Actor* thisx, PlayState* play) {\n    EnNpcFriend* this = (EnNpcFriend*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    // Draw character model with proper animation\n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                         this->skelAnime.dListCount, NULL, NULL, this);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_NpcFriend_InitVars = {\n    /**/ ACTOR_EN_NPC_FRIEND,\n    /**/ ACTORCAT_NPC,\n    /**/ FLAGS,\n    /**/ OBJECT_NPC,\n    /**/ sizeof(EnNpcFriend),\n    /**/ EnNpcFriend_Init,\n    /**/ EnNpcFriend_Destroy,\n    /**/ EnNpcFriend_Update,\n    /**/ EnNpcFriend_Draw\n};\n```\"\n}"}
{"instruction": "Create a combat system system", "output": "{\n  \"instruction\": \"Make a Ocarina playing and song system with extensive error handling and edge cases\",\n  \"input\": null,\n  \"output\": \"```c\n// Authentic pattern from OoT decompilation\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ u8 songNotes[8];\n    /* 0x0154 */ u8 noteIndex;\n    /* 0x0155 */ u8 songState;\n    /* 0x0156 */ s16 timer;\n    /* 0x0158 */ s16 songResult;\n    /* 0x015A */ s16 actionState;\n    /* 0x015C */ f32 radius;\n    /* 0x0160 */ ColliderCylinder collider;\n} EnSongCheck; // size = 0x1AC\n\nvoid EnSongCheck_Init(Actor* thisx, PlayState* play) {\n    EnSongCheck* this = (EnSongCheck*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->radius = 100.0f;\n    this->noteIndex = 0;\n    this->songState = 0;\n    this->timer = 0;\n    this->actionState = 0;\n    this->songResult = -1;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnSongCheck_CheckSong(EnSongCheck* this) {\n    if (this->noteIndex >= 8) {\n        // Song too long - fail\n        this->songState = 2;\n        this->songResult = 0;\n        return;\n    }\n\n    // Compare against known song patterns\n    if (this->noteIndex >= 5) {\n        // Check Zelda's Lullaby\n        if (this->songNotes[0] == 0x4 && \n            this->songNotes[1] == 0x2 &&\n            this->songNotes[2] == 0x3 && \n            this->songNotes[3] == 0x4 && \n            this->songNotes[4] == 0x2) {\n            this->songState = 2;\n            this->songResult = 1; // Success\n            return;\n        }\n    }\n}\n\nvoid EnSongCheck_Update(Actor* thisx, PlayState* play) {\n    EnSongCheck* this = (EnSongCheck*)thisx;\n    Player* player = GET_PLAYER(play);\n\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 20.0f, UPDBGCHECKINFO_FLAG_0);\n    \n    if (Actor_WorldDistXZToActor(&this->actor, &player->actor) > this->radius) {\n        return;\n    }\n\n    switch (this->songState) {\n        case 0: // Waiting for song\n            if (play->msgCtx.ocarinaMode == OCARINA_MODE_01) {\n                this->songState = 1;\n                this->noteIndex = 0;\n                this->timer = 30;\n            }\n            break;\n\n        case 1: // Recording song\n            if (this->timer > 0) {\n                this->timer--;\n            }\n            \n            if (play->msgCtx.ocarinaMode == OCARINA_MODE_04) {\n                // Note played\n                if (this->noteIndex < 8) {\n                    this->songNotes[this->noteIndex++] = play->msgCtx.lastPlayedSong;\n                }\n                this->timer = 30;\n                EnSongCheck_CheckSong(this);\n            } else if (this->timer == 0) {\n                // Timeout\n                this->songState = 2;\n                this->songResult = 0;\n            }\n            break;\n\n        case 2: // Song complete\n            if (this->songResult == 1) {\n                // Success effects/logic\n                Actor_PlaySfx(&this->actor, NA_SE_EV_SMALL_DOG_BARK);\n                this->songState = 0;\n            } else {\n                // Failure effects/logic  \n                Actor_PlaySfx(&this->actor, NA_SE_SY_ERROR);\n                this->songState = 0;\n            }\n            break;\n    }\n\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnSongCheck_Draw(Actor* thisx, PlayState* play) {\n    EnSongCheck* this = (EnSongCheck*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n    gSPDisplayList(POLY_OPA_DISP++, gSongCheckDL);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_SongCheck_InitVars = {\n    /**/ ACTOR_EN_SONG_CHECK,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnSongCheck),\n    /**/ EnSongCheck_Init,\n    /**/ EnSongCheck_Destroy,\n    /**/ EnSongCheck_Update,\n    /**/ EnSongCheck_Draw\n};\n```\"\n}"}
{"instruction": "Implement a collision caching system for repeated checks with straightforward logic", "output": "typedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 lastCheckHeight;\n    /* 0x0154 */ Vec3f lastCheckPos;\n    /* 0x0160 */ s16 lastGroundY;\n    /* 0x162 */ s16 bgCheckFlags;\n    /* 0x164 */ ColliderCylinder collider;\n} EnCollCache; // size = 0x1B0\n\nvoid EnCollCache_Init(Actor* thisx, PlayState* play) {\n    EnCollCache* this = (EnCollCache*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->lastCheckHeight = 0.0f;\n    this->lastGroundY = this->actor.world.pos.y;\n    this->bgCheckFlags = 0;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnCollCache_Update(Actor* thisx, PlayState* play) {\n    EnCollCache* this = (EnCollCache*)thisx;\n    f32 checkHeight = 35.0f;\n    \n    // Only perform full bg check if moved more than 5 units or height changed\n    if ((Math_Vec3f_DistXYZ(&this->lastCheckPos, &this->actor.world.pos) > 5.0f) ||\n        (this->lastCheckHeight != checkHeight)) {\n        \n        Actor_UpdateBgCheckInfo(play, &this->actor, checkHeight, 60.0f, 60.0f, \n            UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n            \n        this->lastCheckPos = this->actor.world.pos;\n        this->lastCheckHeight = checkHeight;\n        this->lastGroundY = this->actor.floorHeight;\n        this->bgCheckFlags = this->actor.bgCheckFlags;\n    } else {\n        // Use cached values\n        this->actor.floorHeight = this->lastGroundY;\n        this->actor.bgCheckFlags = this->bgCheckFlags;\n    }\n    \n    // Always update cylinder collider\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile EnCollCache_Profile = {\n    /**/ ACTOR_EN_COLLCACHE,\n    /**/ ACTORCAT_PROP,\n    /**/ 0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnCollCache),\n    /**/ EnCollCache_Init,\n    /**/ Actor_Destroy,\n    /**/ EnCollCache_Update,\n    /**/ NULL\n};"}
{"instruction": "Create a ai behavior system", "output": "{\n  \"instruction\": \"Create a Bow and arrow aiming and shooting system implementing standard patterns\",\n  \"input\": null,\n  \"output\": \"```c\n// Authentic pattern following z_actor.h structure\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 aimState;\n    /* 0x0150 */ f32 bowPull;\n    /* 0x0154 */ Vec3f aimDir;\n    /* 0x0160 */ ColliderCylinder collider;\n} EnBowAim;\n\nvoid EnBowAim_Init(Actor* thisx, PlayState* play) {\n    EnBowAim* this = (EnBowAim*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->aimState = 0;\n    this->bowPull = 0.0f;\n    this->actor.flags |= ACTOR_FLAG_0;\n}\n\nvoid EnBowAim_Update(Actor* thisx, PlayState* play) {\n    EnBowAim* this = (EnBowAim*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    // Only allow aiming if player has bow\n    if (gSaveContext.inventory.items[SLOT_BOW] == ITEM_NONE) {\n        Actor_Kill(&this->actor);\n        return;\n    }\n\n    switch (this->aimState) {\n        case 0: // Start aiming\n            if (gSaveContext.inventory.items[SLOT_BOW] == ITEM_BOW) {\n                this->aimState = 1;\n                this->timer = 20;\n            }\n            break;\n\n        case 1: // Pulling bow\n            Math_SmoothStepToF(&this->bowPull, 1.0f, 0.2f, 0.4f, 0.1f);\n            \n            // Get aim direction from player rotation\n            this->aimDir.x = Math_SinS(player->actor.world.rot.y);\n            this->aimDir.z = Math_CosS(player->actor.world.rot.y);\n            this->aimDir.y = Math_SinS(-player->actor.world.rot.x);\n            \n            // Check for arrow shot\n            if (--this->timer <= 0) {\n                Actor* arrow = Actor_SpawnAsChild(&play->actorCtx, &this->actor, play,\n                    ACTOR_EN_ARROW, this->actor.world.pos.x, \n                    this->actor.world.pos.y + 30.0f,\n                    this->actor.world.pos.z, 0, 0, 0, 0);\n                    \n                if (arrow != NULL) {\n                    arrow->world.rot = player->actor.world.rot;\n                    arrow->speedXZ = 12.0f * this->bowPull;\n                }\n                \n                this->aimState = 0;\n                this->bowPull = 0.0f;\n            }\n            break;\n    }\n\n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnBowAim_Draw(Actor* thisx, PlayState* play) {\n    EnBowAim* this = (EnBowAim*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, \n                    this->actor.world.pos.z, MTXMODE_NEW);\n                    \n    Matrix_Scale(0.01f, 0.01f, 0.01f, MTXMODE_APPLY);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n              \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_BowAim_InitVars = {\n    /**/ ACTOR_EN_BOW_AIM,\n    /**/ ACTORCAT_MISC,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnBowAim),\n    /**/ EnBowAim_Init,\n    /**/ EnBowAim_Destroy,\n    /**/ EnBowAim_Update, \n    /**/ EnBowAim_Draw\n};\n```\"\n}"}
{"instruction": "Create a collision system system", "output": "{\n  \"instruction\": \"Create a dynamic collision detection system for moving objects with basic debugging support\",\n  \"input\": null,\n  \"output\": \"// Dynamic collision actor with debug visualization\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 debugMode;\n    /* 0x0150 */ f32 detectionRadius;\n    /* 0x0154 */ ColliderCylinder collider;\n    /* 0x01A0 */ Vec3f lastPos;\n} EnCollision; // size = 0x1AC\n\nvoid EnCollision_Init(Actor* thisx, PlayState* play) {\n    EnCollision* this = (EnCollision*)thisx;\n    \n    this->detectionRadius = 100.0f;\n    this->debugMode = 0;\n    \n    // Initialize collision cylinder using authentic pattern\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    // Set initial position\n    this->lastPos = this->actor.world.pos;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnCollision_Update(Actor* thisx, PlayState* play) {\n    EnCollision* this = (EnCollision*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    // Update collision detection\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 0.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Check distance to player using authentic pattern\n    f32 playerDist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    if (playerDist < this->detectionRadius) {\n        this->actor.world.pos.y += Math_SinS(this->timer * 0x800) * 2.0f;\n        this->timer++;\n    }\n    \n    // Store last position for movement tracking\n    this->lastPos = this->actor.world.pos;\n}\n\nvoid EnCollision_Draw(Actor* thisx, PlayState* play) {\n    EnCollision* this = (EnCollision*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    // Basic shape rendering\n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 255, 255, 255, 255);\n    \n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, this->actor.scale.z, MTXMODE_APPLY);\n    \n    Matrix_Push();\n    Matrix_RotateY(BINANG_TO_RAD(this->actor.world.rot.y), MTXMODE_APPLY);\n    \n    // Only draw debug visuals if debug mode enabled\n    if (this->debugMode) {\n        gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__), \n                 G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n        gSPDisplayList(POLY_OPA_DISP++, gCubeEdgesDL);\n    }\n    \n    Matrix_Pop();\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Collision_InitVars = {\n    /**/ ACTOR_EN_COLLISION,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS_0,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnCollision),\n    /**/ EnCollision_Init,\n    /**/ EnCollision_Destroy,\n    /**/ EnCollision_Update,\n    /**/ EnCollision_Draw\n};\"\n}"}
{"instruction": "Implement a physics-based animation system for cloth and hair using efficient algorithms", "output": "// Physics-based cloth/hair system using authentic OoT patterns\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 segments;\n    /* 0x0150 */ Vec3f segmentPos[8];    // Pre-allocated segment positions\n    /* 0x01A0 */ Vec3f segmentVel[8];    // Pre-allocated segment velocities\n    /* 0x01F0 */ Vec3f segmentPrevPos[8]; // Previous positions for verlet integration\n    /* 0x0240 */ f32 segmentLength;\n    /* 0x0244 */ ColliderCylinder collider;\n} EnCloth; // size = 0x290\n\nvoid EnCloth_Init(Actor* thisx, PlayState* play) {\n    EnCloth* this = (EnCloth*)thisx;\n    s32 i;\n    \n    this->segments = 8;\n    this->segmentLength = 10.0f;\n    \n    // Initialize segment positions in a chain\n    for (i = 0; i < this->segments; i++) {\n        this->segmentPos[i] = this->actor.world.pos;\n        this->segmentPos[i].y -= (i * this->segmentLength);\n        this->segmentPrevPos[i] = this->segmentPos[i];\n        this->segmentVel[i].x = this->segmentVel[i].y = this->segmentVel[i].z = 0.0f;\n    }\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnCloth_Update(Actor* thisx, PlayState* play) {\n    EnCloth* this = (EnCloth*)thisx;\n    s32 i;\n    Vec3f gravity = { 0.0f, -1.0f, 0.0f };\n    f32 damping = 0.98f;\n    Vec3f tempPos;\n    \n    // Update physics using Verlet integration\n    for (i = 1; i < this->segments; i++) {\n        // Store current position\n        tempPos = this->segmentPos[i];\n        \n        // Verlet integration\n        this->segmentPos[i].x = this->segmentPos[i].x * 2.0f - this->segmentPrevPos[i].x + gravity.x;\n        this->segmentPos[i].y = this->segmentPos[i].y * 2.0f - this->segmentPrevPos[i].y + gravity.y;\n        this->segmentPos[i].z = this->segmentPos[i].z * 2.0f - this->segmentPrevPos[i].z + gravity.z;\n        \n        // Apply damping\n        this->segmentPos[i].x *= damping;\n        this->segmentPos[i].y *= damping;\n        this->segmentPos[i].z *= damping;\n        \n        // Store previous position\n        this->segmentPrevPos[i] = tempPos;\n    }\n    \n    // Constrain segment distances\n    for (i = 1; i < this->segments; i++) {\n        Vec3f diff;\n        f32 dist;\n        \n        diff.x = this->segmentPos[i].x - this->segmentPos[i-1].x;\n        diff.y = this->segmentPos[i].y - this->segmentPos[i-1].y;\n        diff.z = this->segmentPos[i].z - this->segmentPos[i-1].z;\n        \n        dist = sqrtf(SQ(diff.x) + SQ(diff.y) + SQ(diff.z));\n        \n        if (dist > 0.0f) {\n            f32 correction = (dist - this->segmentLength) / dist;\n            \n            // Move current segment towards previous\n            this->segmentPos[i].x -= diff.x * correction * 0.5f;\n            this->segmentPos[i].y -= diff.y * correction * 0.5f;\n            this->segmentPos[i].z -= diff.z * correction * 0.5f;\n        }\n    }\n    \n    // Update collision\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 20.0f, UPDBGCHECKINFO_FLAG_0);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nconst ActorProfile EnCloth_Profile = {\n    /**/ ACTOR_EN_CLOTH,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnCloth),\n    /**/ EnCloth_Init,\n    /**/ EnCloth_Destroy,\n    /**/ EnCloth_Update,\n    /**/ EnCloth_Draw\n};"}
{"instruction": "Create a puzzle system system", "output": "{\n  \"instruction\": \"Design a energy conduit mechanism that activates when multiple conditions are met using interconnected systems using efficient algorithms\",\n  \"input\": null,\n  \"output\": \"\n```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 activeNodes;\n    /* 0x0150 */ s16 requiredNodes;\n    /* 0x0152 */ s16 state;\n    /* 0x0154 */ f32 energyLevel;\n    /* 0x0158 */ Vec3f nodePositions[4];\n    /* 0x0188 */ ColliderCylinder collider;\n} EnEnergyConduit;\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000080, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 25, 80, 0, { 0, 0, 0 } },\n};\n\nvoid EnEnergyConduit_Init(Actor* thisx, PlayState* play) {\n    EnEnergyConduit* this = (EnEnergyConduit*)thisx;\n    s32 i;\n\n    Actor_SetScale(&this->actor, 0.01f);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->timer = 0;\n    this->activeNodes = 0;\n    this->requiredNodes = 4;\n    this->state = 0;\n    this->energyLevel = 0.0f;\n    \n    // Initialize node positions in a square pattern\n    for (i = 0; i < 4; i++) {\n        this->nodePositions[i].x = Math_SinS(i * 0x4000) * 100.0f;\n        this->nodePositions[i].y = 0.0f;\n        this->nodePositions[i].z = Math_CosS(i * 0x4000) * 100.0f;\n    }\n}\n\nvoid EnEnergyConduit_Destroy(Actor* thisx, PlayState* play) {\n    EnEnergyConduit* this = (EnEnergyConduit*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnEnergyConduit_Update(Actor* thisx, PlayState* play) {\n    EnEnergyConduit* this = (EnEnergyConduit*)thisx;\n    Player* player = GET_PLAYER(play);\n    s32 i;\n    \n    this->timer++;\n    \n    // Check node activation based on player proximity\n    this->activeNodes = 0;\n    for (i = 0; i < 4; i++) {\n        Vec3f nodeWorldPos;\n        \n        nodeWorldPos.x = this->actor.world.pos.x + this->nodePositions[i].x;\n        nodeWorldPos.y = this->actor.world.pos.y + this->nodePositions[i].y;\n        nodeWorldPos.z = this->actor.world.pos.z + this->nodePositions[i].z;\n        \n        if (Math_Vec3f_DistXYZ(&player->actor.world.pos, &nodeWorldPos) < 50.0f) {\n            this->activeNodes++;\n        }\n    }\n\n    // Update energy level based on active nodes\n    if (this->activeNodes >= this->requiredNodes) {\n        Math_SmoothStepToF(&this->energyLevel, 1.0f, 0.1f, 0.05f, 0.01f);\n        if (this->energyLevel > 0.95f && this->state == 0) {\n            this->state = 1;\n            // Spawn effect or trigger event when fully charged\n            Actor_SpawnAsChild(&play->actorCtx, &this->actor, play, ACTOR_EN_ELF, \n                             this->actor.world.pos.x, this->actor.world.pos.y + 80.0f,\n                             this->actor.world.pos.z, 0, 0, 0, 3);\n        }\n    } else {\n        Math_SmoothStepToF(&this->energyLevel, 0.0f, 0.1f, 0.05f, 0.01f);\n        this->state = 0;\n    }\n\n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnEnergyConduit_Draw(Actor* thisx, PlayState* play) {\n    EnEnergyConduit* this = (EnEnergyConduit*)thisx;\n    s32 i;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    // Draw main conduit\n    Matrix_Push();\n    Matrix_Scale(1.0f, 1.0f + (this->energyLevel * 0.5f), 1.0f, MTXMODE_APPLY);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n    gSPDisplayList(POLY_OPA_DISP++, gCubeEdgesDL);\n    Matrix_Pop();\n    \n    // Draw nodes\n    for (i = 0; i < 4; i++) {\n        Matrix_Push();\n        Matrix_Translate(this->nodePositions[i].x, this->nodePositions[i].y,\n                        this->nodePositions[i].z, MTXMODE_APPLY);\n        Matrix_Scale(0.5f, 0.5f, 0.5f, MTXMODE_APPLY);\n        gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n                  G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n        gSPDisplayList(POLY_OPA_DISP++, gSphereDL);\n        Matrix_Pop();\n    }\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_EnergyConduit_InitVars = {\n    /**/ ACTOR_EN_ENERGY_CONDUIT,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnEnergyConduit),\n    /**/ EnEnergyConduit_Init,\n    /**/ EnEnergyConduit_Destroy,\n    /**/ EnEnergyConduit_Update, \n    /**/ EnEnergyConduit_Draw\n};\n```\n\"}"}
{"instruction": "Create a feature implementation system", "output": "{\n  \"instruction\": \"Create an advanced feature implementation with multiple features with extensive debugging capabilities\",\n  \"input\": null,\n  \"output\": \"\n```c\n#include \\\"z_debug.h\\\"\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 debugState;\n    /* 0x014E */ s16 debugTimer;\n    /* 0x0150 */ f32 debugFloats[8];\n    /* 0x0170 */ s32 debugFlags;\n    /* 0x0174 */ Vec3f debugPos;\n    /* 0x0180 */ ColliderCylinder collider;\n} EnDebugger;\n\nvoid EnDebugger_Init(Actor* thisx, PlayState* play) {\n    EnDebugger* this = (EnDebugger*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->debugState = 0;\n    this->debugTimer = 0;\n    this->debugFlags = 0;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnDebugger_PrintDebugInfo(EnDebugger* this, PlayState* play) {\n    Gfx* gfx = play->state.gfxCtx->overlay.p;\n    \n    // Print debug values using authentic OoT debug print system\n    if (gSaveContext.debugState) {\n        PRINTF(\\\"\\\\nDBG: State %d Timer %d\\\\n\\\", this->debugState, this->debugTimer);\n        PRINTF(\\\"DBG: Pos %f %f %f\\\\n\\\", this->actor.world.pos.x,\n               this->actor.world.pos.y, this->actor.world.pos.z);\n        \n        for (s32 i = 0; i < 8; i++) {\n            PRINTF(\\\"DBG: Float[%d] = %f\\\\n\\\", i, this->debugFloats[i]);\n        }\n    }\n}\n\nvoid EnDebugger_Update(Actor* thisx, PlayState* play) {\n    EnDebugger* this = (EnDebugger*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->debugTimer++;\n    \n    // Collision and physics updates\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 50.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    \n    // Debug state machine\n    switch(this->debugState) {\n        case 0:\n            if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 100.0f) {\n                this->debugState = 1;\n                this->debugTimer = 0;\n            }\n            break;\n            \n        case 1:\n            Math_SmoothStepToF(&this->debugFloats[0], 1.0f, 0.1f, 0.5f, 0.01f);\n            if (this->debugTimer > 60) {\n                this->debugState = 2;\n            }\n            break;\n            \n        case 2:\n            if (!Actor_HasParent(&this->actor, play)) {\n                // Authentic item giving pattern\n                Actor_OfferGetItem(&this->actor, play, GI_RUPEE_GREEN, 100.0f, 50.0f);\n            } else {\n                this->debugState = 0;\n                Actor_Kill(&this->actor);\n            }\n            break;\n    }\n    \n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    EnDebugger_PrintDebugInfo(this, play);\n}\n\nvoid EnDebugger_Draw(Actor* thisx, PlayState* play) {\n    EnDebugger* this = (EnDebugger*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Push();\n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, \n                    this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, \n                this->actor.scale.z, MTXMODE_APPLY);\n    Matrix_RotateY(this->actor.world.rot.y * (M_PI / 32768.0f), MTXMODE_APPLY);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_MODELVIEW | G_MTX_LOAD);\n              \n    Matrix_Pop();\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Debugger_InitVars = {\n    /**/ ACTOR_EN_DEBUGGER,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnDebugger),\n    /**/ EnDebugger_Init,\n    /**/ EnDebugger_Destroy,\n    /**/ EnDebugger_Update,\n    /**/ EnDebugger_Draw\n};\n```\"\n}"}
