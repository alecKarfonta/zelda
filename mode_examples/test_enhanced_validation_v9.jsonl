{"instruction": "Create a interaction system system", "output": "{\n  \"instruction\": \"Implement a reputation system that affects NPC interactions with multiple states and transitions\",\n  \"input\": null,\n  \"output\": \"```c\n// Reputation system that affects NPC interactions\n// Uses authentic OoT patterns from z_actor.c\n\ntypedef enum {\n    /* 0x00 */ REPUTATION_NEUTRAL,\n    /* 0x01 */ REPUTATION_FRIENDLY,\n    /* 0x02 */ REPUTATION_HOSTILE,\n    /* 0x03 */ REPUTATION_MAX\n} ReputationState;\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 reputationTimer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ s16 reputationValue;\n    /* 0x0152 */ s16 talkState;\n    /* 0x0154 */ ReputationState reputationState;\n    /* 0x0158 */ f32 interactRange;\n    /* 0x015C */ ColliderCylinder collider;\n} EnReputation;\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000004, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 40, 0, { 0, 0, 0 } },\n};\n\nvoid EnReputation_Init(Actor* thisx, PlayState* play) {\n    EnReputation* this = (EnReputation*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    \n    this->reputationTimer = 0;\n    this->reputationValue = 50; // Start neutral\n    this->reputationState = REPUTATION_NEUTRAL;\n    this->interactRange = 100.0f;\n    this->actionState = 0;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.targetMode = 6;\n    this->actor.flags |= ACTOR_FLAG_0;\n}\n\nvoid EnReputation_UpdateState(EnReputation* this) {\n    if (this->reputationValue >= 75) {\n        this->reputationState = REPUTATION_FRIENDLY;\n    } else if (this->reputationValue <= 25) {\n        this->reputationState = REPUTATION_HOSTILE;\n    } else {\n        this->reputationState = REPUTATION_NEUTRAL;\n    }\n}\n\nvoid EnReputation_Talk(EnReputation* this, PlayState* play) {\n    switch(this->reputationState) {\n        case REPUTATION_FRIENDLY:\n            Message_StartTextbox(play, 0x1000, &this->actor); // Friendly dialog\n            break;\n        case REPUTATION_HOSTILE:\n            Message_StartTextbox(play, 0x1001, &this->actor); // Hostile dialog\n            break;\n        default:\n            Message_StartTextbox(play, 0x1002, &this->actor); // Neutral dialog\n            break;\n    }\n}\n\nvoid EnReputation_Update(Actor* thisx, PlayState* play) {\n    EnReputation* this = (EnReputation*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->reputationTimer++;\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 26.0f, 10.0f, 0.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    \n    // Update reputation based on player distance and interaction\n    f32 playerDist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    if (playerDist < this->interactRange) {\n        if (Actor_ProcessTalkRequest(&this->actor, play)) {\n            EnReputation_Talk(this, play);\n            \n            // Reputation changes based on current state\n            if (this->reputationState == REPUTATION_FRIENDLY) {\n                this->reputationValue += 2;\n            } else if (this->reputationState == REPUTATION_HOSTILE) {\n                this->reputationValue -= 1;\n            }\n            \n            this->reputationValue = CLAMP(this->reputationValue, 0, 100);\n            EnReputation_UpdateState(this);\n        } else if (this->actor.flags & ACTOR_FLAG_0) {\n            func_8002F2CC(&this->actor, play, this->interactRange);\n        }\n    }\n}\n\nvoid EnReputation_Draw(Actor* thisx, PlayState* play) {\n    EnReputation* this = (EnReputation*)thisx;\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    // Draw actor model here\n}\n\nconst ActorProfile En_Reputation_InitVars = {\n    /**/ ACTOR_EN_REPUTATION,\n    /**/ ACTORCAT_NPC,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnReputation),\n    /**/ EnReputation_Init,\n    /**/ Actor_Destroy,\n    /**/ EnReputation_Update,\n    /**/ EnReputation_Draw\n};\n```\"\n}"}
{"instruction": "Create a actor creation system", "output": "{\n  \"instruction\": \"I want to implement a puzzle key that amplifies the player's magical abilities with simple effects for puzzle solving using memory-safe practices\",\n  \"input\": null,\n  \"output\": \"```c\n// EnMagicKey implements a puzzle key that creates magical effects\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ ColliderCylinder collider;\n    /* 0x0198 */ s16 effectTimer;\n    /* 0x019A */ s16 actionState;\n    /* 0x019C */ f32 floatY;\n    /* 0x01A0 */ f32 floatVel;\n} EnMagicKey; // size = 0x01A4\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000010, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 15, 25, 0, { 0, 0, 0 } },\n};\n\nvoid EnMagicKey_Init(Actor* thisx, PlayState* play) {\n    EnMagicKey* this = (EnMagicKey*)thisx;\n\n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.gravity = -1.0f;\n    this->actor.minVelocityY = -10.0f;\n    \n    // Initialize collision\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actionState = 0;\n    this->effectTimer = 0;\n    this->floatY = this->actor.world.pos.y;\n    this->floatVel = 0.0f;\n    \n    Actor_SetFocus(&this->actor, 20.0f);\n}\n\nvoid EnMagicKey_Destroy(Actor* thisx, PlayState* play) {\n    EnMagicKey* this = (EnMagicKey*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnMagicKey_Update(Actor* thisx, PlayState* play) {\n    EnMagicKey* this = (EnMagicKey*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->effectTimer++;\n    \n    // Floating animation\n    this->floatVel += Math_SinS(this->effectTimer * 0x800) * 0.13f;\n    this->actor.world.pos.y = this->floatY + (Math_SinS(this->effectTimer * 0x400) * 3.0f);\n    \n    if (this->actionState == 0) {\n        // Check if player is nearby with magic available\n        if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 100.0f &&\n            gSaveContext.magic > 0) {\n            \n            // Create sparkle effects\n            if ((this->effectTimer & 0xF) == 0) {\n                EffectSsKiraKira_SpawnSmall(play, &this->actor.world.pos,\n                    &(Vec3f){0.0f, 0.0f, 0.0f}, &(Vec3f){0.0f, 0.0f, 0.0f},\n                    &(Color_RGBA8){255, 255, 100, 255}, 2000);\n            }\n        }\n    }\n    \n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Handle ground collision\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 50.0f, \n        UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n}\n\nvoid EnMagicKey_Draw(Actor* thisx, PlayState* play) {\n    EnMagicKey* this = (EnMagicKey*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, \n        this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_RotateY(this->actor.world.rot.y * (M_PI / 32768.0f), MTXMODE_APPLY);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, \n        this->actor.scale.z, MTXMODE_APPLY);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n        G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n    gSPDisplayList(POLY_OPA_DISP++, gMagicKeyDL);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_MagicKey_InitVars = {\n    /**/ ACTOR_EN_MAGIC_KEY,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnMagicKey),\n    /**/ EnMagicKey_Init,\n    /**/ EnMagicKey_Destroy,\n    /**/ EnMagicKey_Update,\n    /**/ EnMagicKey_Draw\n};\n```\"\n}"}
{"instruction": "Create a animation system system", "output": "{\n\"instruction\": \"Create a skeletal animation system for character movement implementing multiple subsystems\",\n\"input\": null,\n\"output\": \"\n```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ Vec3s jointTable[25];\n    /* 0x01F4 */ Vec3s morphTable[25];\n    /* 0x0258 */ s16 actionState;\n    /* 0x025A */ s16 animTimer;\n    /* 0x025C */ f32 moveSpeed;\n    /* 0x0260 */ ColliderCylinder collider;\n} EnSkeleton; // size = 0x02AC\n\nstatic AnimationHeader* sAnimations[] = {\n    &gSkeletonIdleAnim,\n    &gSkeletonWalkAnim, \n    &gSkeletonRunAnim,\n    &gSkeletonJumpAnim\n};\n\nvoid EnSkeleton_Init(Actor* thisx, PlayState* play) {\n    EnSkeleton* this = (EnSkeleton*)thisx;\n    \n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 30.0f);\n    SkelAnime_InitFlex(play, &this->skelAnime, &gSkeletonSkel, NULL, this->jointTable, \n                       this->morphTable, 25);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actionState = 0;\n    this->animTimer = 0;\n    this->moveSpeed = 0.0f;\n    \n    Animation_Change(&this->skelAnime, sAnimations[0], 1.0f, 0.0f,\n                    Animation_GetLastFrame(sAnimations[0]), ANIMMODE_LOOP, 0.0f);\n}\n\nvoid EnSkeleton_UpdateAnimation(EnSkeleton* this) {\n    f32 frameCount;\n    \n    switch (this->actionState) {\n        case 0: // Idle\n            if (this->moveSpeed > 0.1f) {\n                this->actionState = 1;\n                frameCount = Animation_GetLastFrame(sAnimations[1]);\n                Animation_Change(&this->skelAnime, sAnimations[1], 1.0f, 0.0f,\n                               frameCount, ANIMMODE_LOOP, 5.0f);\n            }\n            break;\n            \n        case 1: // Walk\n            if (this->moveSpeed > 6.0f) {\n                this->actionState = 2;\n                frameCount = Animation_GetLastFrame(sAnimations[2]);\n                Animation_Change(&this->skelAnime, sAnimations[2], 1.0f, 0.0f,\n                               frameCount, ANIMMODE_LOOP, 5.0f);\n            } else if (this->moveSpeed < 0.1f) {\n                this->actionState = 0;\n                frameCount = Animation_GetLastFrame(sAnimations[0]);\n                Animation_Change(&this->skelAnime, sAnimations[0], 1.0f, 0.0f,\n                               frameCount, ANIMMODE_LOOP, 5.0f);\n            }\n            break;\n            \n        case 2: // Run\n            if (this->moveSpeed < 6.0f) {\n                this->actionState = 1;\n                frameCount = Animation_GetLastFrame(sAnimations[1]);\n                Animation_Change(&this->skelAnime, sAnimations[1], 1.0f, 0.0f,\n                               frameCount, ANIMMODE_LOOP, 5.0f);\n            }\n            break;\n    }\n}\n\nvoid EnSkeleton_Update(Actor* thisx, PlayState* play) {\n    EnSkeleton* this = (EnSkeleton*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    SkelAnime_Update(&this->skelAnime);\n    \n    if (this->animTimer > 0) {\n        this->animTimer--;\n    }\n    \n    // Update movement speed based on distance to player\n    this->moveSpeed = Actor_WorldDistXZToActor(&this->actor, &player->actor) * 0.1f;\n    \n    EnSkeleton_UpdateAnimation(this);\n    \n    // Update physics and collision\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 50.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnSkeleton_Draw(Actor* thisx, PlayState* play) {\n    EnSkeleton* this = (EnSkeleton*)thisx;\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                          this->skelAnime.dListCount, NULL, NULL, this);\n}\n\nconst ActorProfile En_Skeleton_InitVars = {\n    /**/ ACTOR_EN_SKELETON,\n    /**/ ACTORCAT_ENEMY,\n    /**/ FLAGS,\n    /**/ OBJECT_SKELETON,\n    /**/ sizeof(EnSkeleton),\n    /**/ EnSkeleton_Init,\n    /**/ EnSkeleton_Destroy,\n    /**/ EnSkeleton_Update,\n    /**/ EnSkeleton_Draw\n};\n```\n\"}"}
{"instruction": "Create a combat system system", "output": "{\n  \"instruction\": \"Make a Ocarina playing and song system with complex mathematical calculations\",\n  \"input\": null,\n  \"output\": \"// Authentic pattern following z_actor.h and z_en_ocarina_effect.c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState; \n    /* 0x0150 */ f32 noteFrequency;\n    /* 0x0154 */ f32 noteAmplitude;\n    /* 0x0158 */ f32 notePhase;\n    /* 0x015C */ f32 radius;\n    /* 0x0160 */ Vec3f notePos[8];\n    /* 0x01C0 */ f32 noteAngles[8];\n    /* 0x01E0 */ ColliderCylinder collider;\n} EnOcarinaEffect; // size = 0x22C\n\nvoid EnOcarinaEffect_Init(Actor* thisx, PlayState* play) {\n    EnOcarinaEffect* this = (EnOcarinaEffect*)thisx;\n    s32 i;\n\n    Actor_SetScale(&this->actor, 0.01f);\n    \n    this->noteFrequency = 0.0f;\n    this->noteAmplitude = 50.0f;\n    this->notePhase = 0.0f;\n    this->radius = 30.0f;\n    \n    // Initialize note positions in a circle\n    for (i = 0; i < 8; i++) {\n        this->noteAngles[i] = (i * M_PI) / 4.0f;\n        this->notePos[i].x = Math_SinS(this->noteAngles[i] * 0x8000 / M_PI) * this->radius;\n        this->notePos[i].y = 0.0f;\n        this->notePos[i].z = Math_CosS(this->noteAngles[i] * 0x8000 / M_PI) * this->radius;\n    }\n\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n}\n\nvoid EnOcarinaEffect_Destroy(Actor* thisx, PlayState* play) {\n    EnOcarinaEffect* this = (EnOcarinaEffect*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnOcarinaEffect_Update(Actor* thisx, PlayState* play) {\n    EnOcarinaEffect* this = (EnOcarinaEffect*)thisx;\n    Player* player = GET_PLAYER(play);\n    s32 i;\n    f32 deltaTime = 1.0f / 60.0f;\n\n    // Update note positions using wave equations\n    this->noteFrequency += 0.1f * deltaTime;\n    this->notePhase += deltaTime;\n\n    for (i = 0; i < 8; i++) {\n        this->noteAngles[i] += deltaTime;\n        \n        // Complex wave motion\n        f32 wave = Math_SinS(this->noteFrequency * 0x8000) * this->noteAmplitude;\n        f32 spiral = this->notePhase * 0.5f;\n        \n        this->notePos[i].x = Math_SinS(this->noteAngles[i] * 0x8000 / M_PI) * (this->radius + wave);\n        this->notePos[i].y = Math_CosS((this->noteAngles[i] + spiral) * 0x8000 / M_PI) * 20.0f;\n        this->notePos[i].z = Math_CosS(this->noteAngles[i] * 0x8000 / M_PI) * (this->radius + wave);\n    }\n\n    // Update collision\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n\n    // Check if player is playing ocarina\n    if (player->stateFlags2 & PLAYER_STATE2_OCARINA_PLAYING) {\n        this->noteAmplitude = Math_SmoothStepToF(&this->noteAmplitude, 80.0f, 0.3f, 5.0f, 0.1f);\n    } else {\n        this->noteAmplitude = Math_SmoothStepToF(&this->noteAmplitude, 50.0f, 0.3f, 5.0f, 0.1f);\n    }\n}\n\nvoid EnOcarinaEffect_Draw(Actor* thisx, PlayState* play) {\n    EnOcarinaEffect* this = (EnOcarinaEffect*)thisx;\n    s32 i;\n\n    OPEN_DISPS(play->state.gfxCtx);\n    \n    // Set up display list for drawing\n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    // Draw each note\n    for (i = 0; i < 8; i++) {\n        Matrix_Push();\n        Matrix_Translate(this->notePos[i].x, this->notePos[i].y, this->notePos[i].z, MTXMODE_NEW);\n        Matrix_Scale(0.2f, 0.2f, 0.2f, MTXMODE_APPLY);\n        Matrix_RotateY(this->noteAngles[i], MTXMODE_APPLY);\n        gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__), \n                  G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n        gSPDisplayList(POLY_OPA_DISP++, gEffNoteDL);\n        Matrix_Pop();\n    }\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Ocarina_Effect_InitVars = {\n    /**/ ACTOR_EN_OCARINA_EFFECT,\n    /**/ ACTORCAT_MISC,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnOcarinaEffect),\n    /**/ EnOcarinaEffect_Init,\n    /**/ EnOcarinaEffect_Destroy,\n    /**/ EnOcarinaEffect_Update,\n    /**/ EnOcarinaEffect_Draw\n};\"\n}"}
{"instruction": "Implement debugging tools functionality using authentic code implementing core requirements", "output": "// Authentic debug actor implementation following OoT patterns\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 displayMode;\n    /* 0x0150 */ f32 displayScale;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnDebugInfo; // size = 0x1A0\n\nvoid EnDebugInfo_Init(Actor* thisx, PlayState* play) {\n    EnDebugInfo* this = (EnDebugInfo*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->displayMode = 0;\n    this->displayScale = 1.0f;\n    this->timer = 0;\n    \n    // Authentic collision setup\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n}\n\nvoid EnDebugInfo_Destroy(Actor* thisx, PlayState* play) {\n    EnDebugInfo* this = (EnDebugInfo*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnDebugInfo_Update(Actor* thisx, PlayState* play) {\n    EnDebugInfo* this = (EnDebugInfo*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    // Update collision detection\n    Actor_UpdateBgCheckInfo(play, &this->actor, 35.0f, 60.0f, 60.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    \n    // Toggle display modes with B button\n    if (CHECK_BTN_ALL(input->press.button, BTN_B)) {\n        this->displayMode = (this->displayMode + 1) % 3;\n    }\n    \n    // Follow player position\n    Math_SmoothStepToF(&this->actor.world.pos.x, player->actor.world.pos.x, 0.3f, 50.0f, 0.0f);\n    Math_SmoothStepToF(&this->actor.world.pos.z, player->actor.world.pos.z, 0.3f, 50.0f, 0.0f);\n}\n\nvoid EnDebugInfo_Draw(Actor* thisx, PlayState* play) {\n    EnDebugInfo* this = (EnDebugInfo*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    // Set up display list\n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    // Draw debug info based on mode\n    switch(this->displayMode) {\n        case 0:\n            // Draw FPS counter\n            break;\n        case 1:\n            // Draw memory usage\n            break;\n        case 2:\n            // Draw actor count\n            break;\n    }\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_DebugInfo_InitVars = {\n    /**/ ACTOR_EN_DEBUG_INFO,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnDebugInfo),\n    /**/ EnDebugInfo_Init,\n    /**/ EnDebugInfo_Destroy,\n    /**/ EnDebugInfo_Update,\n    /**/ EnDebugInfo_Draw\n};\n"}
