{"instruction": "Create a ai behavior system", "output": "{\n  \"instruction\": \"Create a Magic spell casting and mana system using memory-safe practices\",\n  \"input\": null,\n  \"output\": \"```c\n// Magic spell actor\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 actionState;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n    /* 0x01A0 */ Vec3f effectPos[3];\n    /* 0x01C4 */ s16 effectTimer;\n} EnMagicSpell; // size = 0x1C8\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_ON | AT_TYPE_PLAYER,\n        AC_NONE,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000002, 0x00, 0x01 },\n        { 0x00000000, 0x00, 0x00 },\n        TOUCH_ON | TOUCH_SFX_NONE,\n        BUMP_NONE,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnMagicSpell_Init(Actor* thisx, PlayState* play) {\n    EnMagicSpell* this = (EnMagicSpell*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->timer = 0;\n    this->actionState = 0;\n    this->effectTimer = 0;\n}\n\nvoid EnMagicSpell_Destroy(Actor* thisx, PlayState* play) {\n    EnMagicSpell* this = (EnMagicSpell*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnMagicSpell_Update(Actor* thisx, PlayState* play) {\n    EnMagicSpell* this = (EnMagicSpell*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    // Only allow casting if player has enough magic\n    if (gSaveContext.magic >= 4) {\n        switch(this->actionState) {\n            case 0:\n                if (this->timer > 10) {\n                    this->actionState = 1;\n                    gSaveContext.magic -= 4; // Consume magic\n                }\n                break;\n                \n            case 1:\n                Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 20.0f, UPDBGCHECKINFO_FLAG_0);\n                \n                // Update effect positions\n                for (s32 i = 0; i < 3; i++) {\n                    this->effectPos[i].x = this->actor.world.pos.x + Math_SinS(this->timer * 0x1000) * 30.0f;\n                    this->effectPos[i].y = this->actor.world.pos.y + (i * 20.0f);\n                    this->effectPos[i].z = this->actor.world.pos.z + Math_CosS(this->timer * 0x1000) * 30.0f;\n                }\n                \n                this->effectTimer++;\n                if (this->effectTimer > 30) {\n                    Actor_Kill(&this->actor);\n                }\n                break;\n        }\n        \n        // Update collision detection\n        Collider_UpdateCylinder(&this->actor, &this->collider);\n        CollisionCheck_SetAT(play, &play->colChkCtx, &this->collider.base);\n        CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    }\n}\n\nvoid EnMagicSpell_Draw(Actor* thisx, PlayState* play) {\n    EnMagicSpell* this = (EnMagicSpell*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    // Draw magic effect particles\n    for (s32 i = 0; i < 3; i++) {\n        Matrix_Translate(this->effectPos[i].x, this->effectPos[i].y, this->effectPos[i].z, MTXMODE_NEW);\n        Matrix_Scale(0.2f, 0.2f, 0.2f, MTXMODE_APPLY);\n        Matrix_RotateY(this->timer * 0.1f, MTXMODE_APPLY);\n        \n        gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__), \n                 G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n        gSPDisplayList(POLY_OPA_DISP++, gEffectSsDlList);\n    }\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile EnMagicSpell_Profile = {\n    /**/ ACTOR_EN_MAGIC_SPELL,\n    /**/ ACTORCAT_MISC,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnMagicSpell),\n    /**/ EnMagicSpell_Init,\n    /**/ EnMagicSpell_Destroy, \n    /**/ EnMagicSpell_Update,\n    /**/ EnMagicSpell_Draw\n};\n```\"\n}"}
{"instruction": "Create a actor creation system", "output": "{\n  \"instruction\": \"Build a puzzle pedestal object that opens passages based on player inventory when activated using interconnected systems for puzzle rooms using established conventions\",\n  \"input\": null,\n  \"output\": \"```c\n// Pedestal that checks inventory and triggers room events\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 actionState;\n    /* 0x014E */ s16 timer;\n    /* 0x0150 */ f32 glowAlpha;\n    /* 0x0154 */ ColliderCylinder collider;\n} EnPedestal; // size = 0x1A0\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0x00000010, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 60, 0, { 0, 0, 0 } },\n};\n\nvoid EnPedestal_Init(Actor* thisx, PlayState* play) {\n    EnPedestal* this = (EnPedestal*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.1f);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actionState = 0;\n    this->timer = 0;\n    this->glowAlpha = 0.0f;\n    \n    this->actor.targetMode = 4;\n    this->actor.flags |= ACTOR_FLAG_0;\n}\n\nvoid EnPedestal_Destroy(Actor* thisx, PlayState* play) {\n    EnPedestal* this = (EnPedestal*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnPedestal_Update(Actor* thisx, PlayState* play) {\n    EnPedestal* this = (EnPedestal*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 100.0f) {\n        if (this->actionState == 0) {\n            // Check if player has required items\n            if ((gSaveContext.inventory.items[SLOT_BOW] != ITEM_NONE) &&\n                (gSaveContext.inventory.items[SLOT_HOOKSHOT] != ITEM_NONE)) {\n                \n                this->actionState = 1;\n                this->timer = 0;\n                \n                // Set switch flag to trigger room events\n                Flags_SetSwitch(play, (this->actor.params >> 8) & 0x3F);\n                \n                // Play success sound\n                Audio_PlayActorSound2(&this->actor, NA_SE_EV_GET_ITEM);\n            } else {\n                // Play error sound if missing items\n                if (this->timer & 0x10) {\n                    Audio_PlayActorSound2(&this->actor, NA_SE_SY_ERROR);\n                }\n            }\n        }\n    }\n    \n    // Glow effect when activated\n    if (this->actionState == 1) {\n        Math_SmoothStepToF(&this->glowAlpha, 255.0f, 0.3f, 10.0f, 0.1f);\n    }\n}\n\nvoid EnPedestal_Draw(Actor* thisx, PlayState* play) {\n    EnPedestal* this = (EnPedestal*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    gDPSetEnvColor(POLY_OPA_DISP++, 255, 255, 255, (u8)this->glowAlpha);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_MODELVIEW | G_MTX_LOAD);\n    gSPDisplayList(POLY_OPA_DISP++, gPedestalDL);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Pedestal_InitVars = {\n    /**/ ACTOR_EN_PEDESTAL,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnPedestal),\n    /**/ EnPedestal_Init,\n    /**/ EnPedestal_Destroy,\n    /**/ EnPedestal_Update,\n    /**/ EnPedestal_Draw\n};\n```\"\n}"}
{"instruction": "Create a puzzle system system", "output": "{\n  \"instruction\": \"How would you implement a elemental altar that controls water levels and flow? using timing mechanisms for platforming challenges with multiple states and transitions\",\n  \"input\": null,\n  \"output\": \"```c\n// Altar states\n#define ALTAR_STATE_IDLE 0\n#define ALTAR_STATE_RISING 1 \n#define ALTAR_STATE_FALLING 2\n#define ALTAR_STATE_FLOWING 3\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 actionState;\n    /* 0x014E */ s16 timer;\n    /* 0x0150 */ f32 waterLevel;\n    /* 0x0154 */ f32 targetWaterLevel;\n    /* 0x0158 */ s16 switchFlag;\n    /* 0x015A */ s16 roomNum;\n    /* 0x015C */ ColliderCylinder collider;\n} EnWaterAltar; // size = 0x1A8\n\nvoid EnWaterAltar_Init(Actor* thisx, PlayState* play) {\n    EnWaterAltar* this = (EnWaterAltar*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actionState = ALTAR_STATE_IDLE;\n    this->timer = 0;\n    this->waterLevel = this->actor.world.pos.y;\n    this->targetWaterLevel = this->waterLevel;\n    this->switchFlag = (this->actor.params >> 8) & 0x3F;\n    this->roomNum = this->actor.params & 0xFF;\n    \n    Actor_SetScale(&this->actor, 0.1f);\n}\n\nvoid EnWaterAltar_Update(Actor* thisx, PlayState* play) {\n    EnWaterAltar* this = (EnWaterAltar*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    // Check if player is near and pressing A\n    if (Actor_WorldDistXYZToActor(&this->actor, &player->actor) < 100.0f) {\n        if (func_8002F2CC(&this->actor, play, 100.0f) && \n            !(this->actionState == ALTAR_STATE_RISING || \n              this->actionState == ALTAR_STATE_FALLING)) {\n                \n            // Toggle water state\n            if (this->actionState == ALTAR_STATE_IDLE) {\n                this->actionState = ALTAR_STATE_RISING;\n                this->targetWaterLevel = this->waterLevel + 200.0f;\n                this->timer = 0;\n            } else if (this->actionState == ALTAR_STATE_FLOWING) {\n                this->actionState = ALTAR_STATE_FALLING;\n                this->targetWaterLevel = this->waterLevel - 200.0f;\n                this->timer = 0;\n            }\n        }\n    }\n\n    // State machine\n    switch(this->actionState) {\n        case ALTAR_STATE_IDLE:\n            break;\n            \n        case ALTAR_STATE_RISING:\n            Math_SmoothStepToF(&this->waterLevel, this->targetWaterLevel, 0.2f, 3.0f, 0.1f);\n            \n            if (fabsf(this->waterLevel - this->targetWaterLevel) < 1.0f) {\n                this->actionState = ALTAR_STATE_FLOWING;\n                this->timer = 0;\n            }\n            break;\n            \n        case ALTAR_STATE_FALLING:\n            Math_SmoothStepToF(&this->waterLevel, this->targetWaterLevel, 0.2f, 3.0f, 0.1f);\n            \n            if (fabsf(this->waterLevel - this->targetWaterLevel) < 1.0f) {\n                this->actionState = ALTAR_STATE_IDLE;\n                this->timer = 0;\n            }\n            break;\n            \n        case ALTAR_STATE_FLOWING:\n            // Create water ripple effects every 10 frames\n            if ((this->timer % 10) == 0) {\n                Actor_Spawn(&play->actorCtx, play, ACTOR_EN_RIVER_SOUND, \n                          this->actor.world.pos.x, this->waterLevel,\n                          this->actor.world.pos.z, 0, 0, 0, 0);\n            }\n            break;\n    }\n\n    // Update room water level through room context\n    play->roomCtx.roomList[this->roomNum].waterLevel = this->waterLevel;\n    \n    // Update switch flag for room state\n    if (this->switchFlag != 0) {\n        if (this->actionState == ALTAR_STATE_FLOWING) {\n            Flags_SetSwitch(play, this->switchFlag);\n        } else {\n            Flags_UnsetSwitch(play, this->switchFlag);\n        }\n    }\n\n    // Collision updates\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnWaterAltar_Draw(Actor* thisx, PlayState* play) {\n    EnWaterAltar* this = (EnWaterAltar*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_MODELVIEW | G_MTX_LOAD);\n    gSPDisplayList(POLY_OPA_DISP++, gWaterAltarDL);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_WaterAltar_InitVars = {\n    /**/ ACTOR_EN_WATER_ALTAR,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_WATER_ALTAR,\n    /**/ sizeof(EnWaterAltar),\n    /**/ EnWaterAltar_Init,\n    /**/ EnWaterAltar_Destroy,\n    /**/ EnWaterAltar_Update,\n    /**/ EnWaterAltar_Draw\n};\n```\"}"}
{"instruction": "Create a actor creation system", "output": "{\n  \"instruction\": \"Implement a shadow assassin enemy with the ability to creates defensive barriers when health is low using multiple attack patterns for overworld exploration with appropriate documentation\",\n  \"input\": null,\n  \"output\": \"```c\n// Shadow Assassin enemy that uses stealth and barrier tactics\n// Based on authentic OoT enemy patterns\n\n#include \\\"z_en_shadow_assassin.h\\\"\n\ntypedef enum {\n    /* 0 */ ASSASSIN_IDLE,\n    /* 1 */ ASSASSIN_CHASE,\n    /* 2 */ ASSASSIN_ATTACK,\n    /* 3 */ ASSASSIN_DEFENSIVE,\n    /* 4 */ ASSASSIN_RETREAT\n} AssassinState;\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ Vec3s jointTable[25];\n    /* 0x01F4 */ Vec3s morphTable[25];\n    /* 0x0258 */ s16 actionState;\n    /* 0x025A */ s16 attackTimer;\n    /* 0x025C */ s16 barrierTimer;\n    /* 0x025E */ s16 damageTimer;\n    /* 0x0260 */ f32 approachSpeed;\n    /* 0x0264 */ ColliderCylinder collider;\n    /* 0x02B0 */ ColliderCylinder barrierCollider;\n} EnShadowAssassin; // size = 0x02FC\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_HIT0,\n        AT_ON | AT_TYPE_ENEMY,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0xFFCFFFFF, 0x00, 0x08 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_ON | TOUCH_SFX_NORMAL,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 45, 0, { 0, 0, 0 } },\n};\n\nvoid EnShadowAssassin_Init(Actor* thisx, PlayState* play) {\n    EnShadowAssassin* this = (EnShadowAssassin*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    \n    SkelAnime_InitFlex(play, &this->skelAnime, &gShadowAssassinSkel, \n                       &gShadowAssassinIdleAnim, this->jointTable, \n                       this->morphTable, 25);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.colChkInfo.health = 8;\n    this->actionState = ASSASSIN_IDLE;\n    this->approachSpeed = 8.0f;\n    \n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 30.0f);\n}\n\nvoid EnShadowAssassin_Destroy(Actor* thisx, PlayState* play) {\n    EnShadowAssassin* this = (EnShadowAssassin*)thisx;\n    \n    Collider_DestroyCylinder(play, &this->collider);\n    Collider_DestroyCylinder(play, &this->barrierCollider);\n}\n\nvoid EnShadowAssassin_SetupIdle(EnShadowAssassin* this) {\n    Animation_Change(&this->skelAnime, &gShadowAssassinIdleAnim, 1.0f, 0.0f,\n                    Animation_GetLastFrame(&gShadowAssassinIdleAnim), ANIMMODE_LOOP, -8.0f);\n    this->actionState = ASSASSIN_IDLE;\n    this->attackTimer = 0;\n}\n\nvoid EnShadowAssassin_SetupChase(EnShadowAssassin* this) {\n    Animation_Change(&this->skelAnime, &gShadowAssassinRunAnim, 1.0f, 0.0f,\n                    Animation_GetLastFrame(&gShadowAssassinRunAnim), ANIMMODE_LOOP, -8.0f);\n    this->actionState = ASSASSIN_CHASE;\n    this->approachSpeed = 8.0f;\n}\n\nvoid EnShadowAssassin_Update(Actor* thisx, PlayState* play) {\n    EnShadowAssassin* this = (EnShadowAssassin*)thisx;\n    Player* player = GET_PLAYER(play);\n    s16 angleToPlayer;\n    f32 distanceToPlayer;\n    \n    if (this->damageTimer > 0) {\n        this->damageTimer--;\n    }\n    \n    SkelAnime_Update(&this->skelAnime);\n    \n    distanceToPlayer = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    angleToPlayer = Actor_WorldYawTowardActor(&this->actor, &player->actor);\n    \n    switch (this->actionState) {\n        case ASSASSIN_IDLE:\n            if (distanceToPlayer < 200.0f) {\n                EnShadowAssassin_SetupChase(this);\n            }\n            break;\n            \n        case ASSASSIN_CHASE:\n            Math_SmoothStepToS(&this->actor.world.rot.y, angleToPlayer, 2, 0x300, 0);\n            this->actor.shape.rot.y = this->actor.world.rot.y;\n            \n            if (distanceToPlayer < 80.0f) {\n                this->actionState = ASSASSIN_ATTACK;\n                this->attackTimer = 20;\n            }\n            break;\n    }\n    \n    // Create barrier when health is low\n    if (this->actor.colChkInfo.health <= 2 && this->barrierTimer <= 0) {\n        this->barrierTimer = 100;\n        this->actionState = ASSASSIN_DEFENSIVE;\n    }\n    \n    Actor_MoveXZGravity(&this->actor);\n    Actor_UpdateBgCheckInfo(play, &this->actor, 35.0f, 60.0f, 0.0f, 1);\n    \n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (this->actionState != ASSASSIN_DEFENSIVE) {\n        CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    }\n}\n\nvoid EnShadowAssassin_Draw(Actor* thisx, PlayState* play) {\n    EnShadowAssassin* this = (EnShadowAssassin*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n              \n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                          this->skelAnime.dListCount, NULL, NULL, this);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_ShadowAssassin_InitVars = {\n    /**/ ACTOR_EN_SHADOW_ASSASSIN,\n    /**/ ACTORCAT_ENEMY,\n    /**/ FLAGS,\n    /**/ OBJECT_SHADOW_ASSASSIN,\n    /**/ sizeof(EnShadowAssassin),\n    /**/ EnShadowAssassin_Init,\n    /**/ EnShadowAssassin_Destroy,\n    /**/ EnShadowAssassin_Update,\n    /**/ EnShadowAssassin_Draw\n};\n```\"\n}"}
{"instruction": "Create a ai behavior system", "output": "{\n  \"instruction\": \"Create a Shield blocking and deflection mechanics using advanced memory management\",\n  \"input\": null,\n  \"output\": \"\n```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 blockTimer;\n    /* 0x014E */ s16 deflectState;\n    /* 0x0150 */ f32 blockAngle;\n    /* 0x0154 */ ColliderCylinder collider;\n    /* 0x01A0 */ Vec3f deflectVel;\n    /* 0x01AC */ Vec3s jointTable[20];\n    /* 0x01FC */ Vec3s morphTable[20];\n    /* 0x024C */ SkelAnime skelAnime;\n} EnShieldBlock; // size = 0x290\n\nvoid EnShieldBlock_Init(Actor* thisx, PlayState* play) {\n    EnShieldBlock* this = (EnShieldBlock*)thisx;\n    Player* player = GET_PLAYER(play);\n\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n\n    this->blockTimer = 0;\n    this->deflectState = 0;\n    this->blockAngle = 0.0f;\n    \n    // Initialize skeleton animation if shield has visual effects\n    SkelAnime_InitFlex(play, &this->skelAnime, &gShieldBlockSkel, \n                       &gShieldBlockAnim, this->jointTable, \n                       this->morphTable, 20);\n\n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnShieldBlock_Update(Actor* thisx, PlayState* play) {\n    EnShieldBlock* this = (EnShieldBlock*)thisx;\n    Player* player = GET_PLAYER(play);\n    Vec3f shieldDir;\n    f32 blockRange = 30.0f;\n\n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n\n    // Check if player is blocking with shield\n    if (gSaveContext.equips.buttonItems[1] != ITEM_NONE) {\n        f32 dist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n        \n        if (dist < blockRange) {\n            Vec3f playerFront;\n            playerFront.x = Math_SinS(player->actor.shape.rot.y);\n            playerFront.z = Math_CosS(player->actor.shape.rot.y);\n\n            // Calculate shield block angle\n            this->blockAngle = Math_Vec3f_Yaw(&this->actor.world.pos, \n                                             &player->actor.world.pos);\n\n            // Handle deflection state\n            if (this->deflectState == 0) {\n                if (sqrtf(SQ(dx) + SQ(dz))(&this->actor.world.pos, \n                                    &player->actor.world.pos) < blockRange) {\n                    this->deflectState = 1;\n                    this->blockTimer = 10;\n\n                    // Calculate deflection velocity\n                    this->deflectVel.x = this->actor.world.pos.x - \n                                       player->actor.world.pos.x;\n                    this->deflectVel.z = this->actor.world.pos.z - \n                                       player->actor.world.pos.z;\n                    \n                    f32 normalizer = 1.0f / sqrtf(SQ(this->deflectVel.x) + \n                                                 SQ(this->deflectVel.z));\n                    this->deflectVel.x *= normalizer * 8.0f;\n                    this->deflectVel.z *= normalizer * 8.0f;\n                }\n            }\n        }\n    }\n\n    // Handle deflection movement\n    if (this->deflectState == 1) {\n        this->actor.world.pos.x += this->deflectVel.x;\n        this->actor.world.pos.z += this->deflectVel.z;\n\n        if (--this->blockTimer <= 0) {\n            this->deflectState = 0;\n        }\n    }\n\n    // Update background collision info\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 50.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n}\n\nvoid EnShieldBlock_Draw(Actor* thisx, PlayState* play) {\n    EnShieldBlock* this = (EnShieldBlock*)thisx;\n\n    OPEN_DISPS(play->state.gfxCtx);\n\n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    // Draw shield block effect\n    Matrix_Push();\n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, \n                    this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_RotateY(BINANG_TO_RAD(this->actor.world.rot.y), MTXMODE_APPLY);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, \n                this->actor.scale.z, MTXMODE_APPLY);\n\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, \n              __FILE__, __LINE__), G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n\n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, \n                         this->skelAnime.jointTable, \n                         this->skelAnime.dListCount, NULL, NULL, this);\n\n    Matrix_Pop();\n\n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_ShieldBlock_InitVars = {\n    /**/ ACTOR_EN_SHIELD_BLOCK,\n    /**/ ACTORCAT_ENEMY,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnShieldBlock),\n    /**/ EnShieldBlock_Init,\n    /**/ EnShieldBlock_Destroy,\n    /**/ EnShieldBlock_Update,\n    /**/ EnShieldBlock_Draw\n};\n```\n\"}"}
