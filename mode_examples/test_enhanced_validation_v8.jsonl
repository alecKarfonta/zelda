{"instruction": "Create a actor creation system", "output": "{\n  \"instruction\": \"What's the best way to create a flying demon that mirror the player's equipped weapon and abilities? with multiple interaction types with basic error checking\",\n  \"input\": null,\n  \"output\": \"```c\n// Flying demon that mirrors player equipment\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ Vec3s jointTable[LIMB_COUNT];\n    /* 0x01F4 */ Vec3s morphTable[LIMB_COUNT];\n    /* 0x0258 */ s16 actionState;\n    /* 0x025A */ s16 timer;\n    /* 0x025C */ f32 hoverY;\n    /* 0x0260 */ f32 targetY; \n    /* 0x0264 */ ColliderCylinder collider;\n} EnDemon; // Size = 0x02B0\n\nvoid EnDemon_Init(Actor* thisx, PlayState* play) {\n    EnDemon* this = (EnDemon*)thisx;\n    \n    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 30.0f);\n    SkelAnime_InitFlex(play, &this->skelAnime, &gDemonSkel, &gDemonFloatAnim, \n                       this->jointTable, this->morphTable, LIMB_COUNT);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->actor.colChkInfo.mass = MASS_IMMOVABLE;\n    Actor_SetScale(&this->actor, 0.015f);\n    \n    this->actionState = 0;\n    this->timer = 0;\n    this->hoverY = this->actor.world.pos.y;\n    this->targetY = this->hoverY;\n}\n\nvoid EnDemon_Destroy(Actor* thisx, PlayState* play) {\n    EnDemon* this = (EnDemon*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnDemon_MirrorPlayerEquipment(EnDemon* this, PlayState* play) {\n    Player* player = GET_PLAYER(play);\n    \n    // Basic error checking for player\n    if (player == NULL || player->actor.id != ACTOR_PLAYER) {\n        return;\n    }\n    \n    // Mirror player's current item if valid\n    if (player->currentShield < PLAYER_SHIELD_MAX) {\n        this->actor.params = player->currentShield;\n    }\n    \n    // Mirror player's sword type\n    if (player->swordState > 0 && player->swordState < PLAYER_SWORD_MAX) {\n        this->actionState = player->swordState;\n    }\n}\n\nvoid EnDemon_Update(Actor* thisx, PlayState* play) {\n    EnDemon* this = (EnDemon*)thisx;\n    Player* player = GET_PLAYER(play);\n    f32 dx;\n    f32 dz;\n    \n    // Update skeleton animation\n    SkelAnime_Update(&this->skelAnime);\n    \n    // Hover movement\n    Math_SmoothStepToF(&this->actor.world.pos.y, this->targetY, 0.3f, 3.0f, 0.5f);\n    this->timer++;\n    if (this->timer > 30) {\n        this->targetY = this->hoverY + Math_SinS(this->timer * 0x800) * 10.0f;\n    }\n    \n    // Face player if exists\n    if (player != NULL) {\n        dx = player->actor.world.pos.x - this->actor.world.pos.x;\n        dz = player->actor.world.pos.z - this->actor.world.pos.z;\n        Math_SmoothStepToS(&this->actor.shape.rot.y, Math_Atan2S(dz, dx), 6, 2000, 1);\n    }\n    \n    // Mirror player equipment with basic validation\n    EnDemon_MirrorPlayerEquipment(this, play);\n    \n    // Update collider\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Ground/wall collision\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 20.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n}\n\nvoid EnDemon_Draw(Actor* thisx, PlayState* play) {\n    EnDemon* this = (EnDemon*)thisx;\n    \n    // Draw skeleton\n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                         this->skelAnime.dListCount, NULL, NULL, this);\n}\n\nconst ActorProfile En_Demon_InitVars = {\n    /**/ ACTOR_EN_DEMON,\n    /**/ ACTORCAT_ENEMY,\n    /**/ FLAGS,\n    /**/ OBJECT_DEMON,\n    /**/ sizeof(EnDemon),\n    /**/ EnDemon_Init,\n    /**/ EnDemon_Destroy,\n    /**/ EnDemon_Update,\n    /**/ EnDemon_Draw\n};\n```\"\n}"}
{"instruction": "Create a interaction system system", "output": "{\n  \"instruction\": \"Create a faction system with different groups and allegiances with basic functionality\",\n  \"input\": null,\n  \"output\": \"```c\n// Authentic faction definitions using real OoT patterns\n#define FACTION_NONE      0\n#define FACTION_FRIENDLY  1\n#define FACTION_HOSTILE   2\n#define FACTION_NEUTRAL   3\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 faction;\n    /* 0x014E */ s16 timer;\n    /* 0x0150 */ s16 actionState;\n    /* 0x0152 */ s16 health;\n    /* 0x0154 */ f32 targetDist;\n    /* 0x0158 */ ColliderCylinder collider;\n} EnFaction; // size = 0x1A4\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_HIT0,\n        AT_NONE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000000, 0x00, 0x00 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 40, 0, { 0, 0, 0 } },\n};\n\nvoid EnFaction_Init(Actor* thisx, PlayState* play) {\n    EnFaction* this = (EnFaction*)thisx;\n    \n    // Authentic collision initialization\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->faction = this->actor.params & 0xFF;\n    this->health = 4;\n    this->actionState = 0;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnFaction_Destroy(Actor* thisx, PlayState* play) {\n    EnFaction* this = (EnFaction*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnFaction_Update(Actor* thisx, PlayState* play) {\n    EnFaction* this = (EnFaction*)thisx;\n    Actor* targetActor;\n    s32 i;\n    \n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Basic faction behavior\n    switch(this->faction) {\n        case FACTION_FRIENDLY:\n            // Follow player if nearby\n            this->targetDist = Actor_WorldDistXZToActor(&this->actor, &GET_PLAYER(play)->actor);\n            if (this->targetDist < 200.0f) {\n                Math_SmoothStepToF(&this->actor.speedXZ, 4.0f, 0.3f, 1.0f, 0.0f);\n                Math_SmoothStepToS(&this->actor.world.rot.y, \n                    Actor_WorldYawTowardActor(&this->actor, &GET_PLAYER(play)->actor), 4, \n                    0x800, 0);\n            } else {\n                Math_SmoothStepToF(&this->actor.speedXZ, 0.0f, 0.3f, 1.0f, 0.0f);\n            }\n            break;\n            \n        case FACTION_HOSTILE:\n            // Attack player if nearby\n            this->targetDist = Actor_WorldDistXZToActor(&this->actor, &GET_PLAYER(play)->actor);\n            if (this->targetDist < 150.0f) {\n                Math_SmoothStepToF(&this->actor.speedXZ, 6.0f, 0.3f, 1.0f, 0.0f);\n                Math_SmoothStepToS(&this->actor.world.rot.y,\n                    Actor_WorldYawTowardActor(&this->actor, &GET_PLAYER(play)->actor), 4,\n                    0x1000, 0);\n                    \n                if (this->targetDist < 50.0f && this->timer <= 0) {\n                    this->timer = 20;\n                    // Attack logic would go here\n                }\n            }\n            break;\n            \n        case FACTION_NEUTRAL:\n            // Wander randomly\n            if (this->timer <= 0) {\n                this->timer = (s16)Rand_ZeroFloat(60.0f) + 20;\n                this->actor.world.rot.y = (s16)Rand_ZeroFloat(65536.0f);\n            }\n            Math_SmoothStepToF(&this->actor.speedXZ, 2.0f, 0.3f, 1.0f, 0.0f);\n            break;\n    }\n    \n    if (this->timer > 0) {\n        this->timer--;\n    }\n    \n    // Update position with gravity and collision\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 50.0f, \n        UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    Actor_MoveXZGravity(&this->actor);\n}\n\nvoid EnFaction_Draw(Actor* thisx, PlayState* play) {\n    EnFaction* this = (EnFaction*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    func_80093D18(play->state.gfxCtx);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n        G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n        \n    // Draw actor model here\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Faction_InitVars = {\n    /**/ ACTOR_EN_FACTION,\n    /**/ ACTORCAT_NPC,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnFaction),\n    /**/ EnFaction_Init,\n    /**/ EnFaction_Destroy,\n    /**/ EnFaction_Update,\n    /**/ EnFaction_Draw\n};\n```\"\n}"}
