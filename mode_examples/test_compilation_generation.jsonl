{"instruction": "Create a animation system system", "output": "{\n  \"instruction\": \"Create a skeletal animation system for character movement implementing essential features\",\n  \"input\": null,\n  \"output\": \"typedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ Vec3s jointTable[20];\n    /* 0x01F0 */ Vec3s morphTable[20];\n    /* 0x0250 */ s16 actionState;\n    /* 0x0252 */ s16 animTimer;\n    /* 0x0254 */ ColliderCylinder collider;\n} EnCharacter; // size = 0x2A0\n\nvoid EnCharacter_Init(Actor* thisx, PlayState* play) {\n    EnCharacter* this = (EnCharacter*)thisx;\n    \n    // Initialize skeleton animation system\n    SkelAnime_InitFlex(play, &this->skelAnime, &gCharacterSkel, &gCharacterIdleAnim, \n                       this->jointTable, this->morphTable, 20);\n    \n    // Setup collision\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    // Initialize actor properties\n    Actor_SetScale(&this->actor, 0.01f);\n    this->actionState = 0;\n    this->animTimer = 0;\n}\n\nvoid EnCharacter_Update(Actor* thisx, PlayState* play) {\n    EnCharacter* this = (EnCharacter*)thisx;\n    s32 pad;\n    Player* player = GET_PLAYER(play);\n    \n    // Update animation\n    SkelAnime_Update(&this->skelAnime);\n    \n    // Handle state machine for animations\n    switch(this->actionState) {\n        case 0: // Idle\n            if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 100.0f) {\n                Animation_Change(&this->skelAnime, &gCharacterWalkAnim, 1.0f, 0.0f,\n                               Animation_GetLastFrame(&gCharacterWalkAnim), ANIMMODE_LOOP, 4.0f);\n                this->actionState = 1;\n            }\n            break;\n            \n        case 1: // Walking\n            if (Actor_WorldDistXZToActor(&this->actor, &player->actor) >= 100.0f) {\n                Animation_Change(&this->skelAnime, &gCharacterIdleAnim, 1.0f, 0.0f,\n                               Animation_GetLastFrame(&gCharacterIdleAnim), ANIMMODE_LOOP, 4.0f);\n                this->actionState = 0;\n            }\n            break;\n    }\n    \n    // Update collision detection\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 50.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnCharacter_Draw(Actor* thisx, PlayState* play) {\n    EnCharacter* this = (EnCharacter*)thisx;\n    \n    // Setup display list\n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    // Draw skeletal animation\n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                          this->skelAnime.dListCount, NULL, NULL, this);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Character_InitVars = {\n    /**/ ACTOR_EN_CHARACTER,\n    /**/ ACTORCAT_NPC,\n    /**/ FLAGS,\n    /**/ OBJECT_CHARACTER,\n    /**/ sizeof(EnCharacter),\n    /**/ EnCharacter_Init,\n    /**/ EnCharacter_Destroy,\n    /**/ EnCharacter_Update,\n    /**/ EnCharacter_Draw\n};\"\n}"}
{"instruction": "Create a ai behavior system", "output": "{\n  \"instruction\": \"Create a Magic spell casting and mana system implementing common features\",\n  \"input\": null,\n  \"output\": \"```c\n// Magic spell casting system using authentic OoT patterns\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 spellState;\n    /* 0x0150 */ f32 spellPower;\n    /* 0x0154 */ Vec3f effectPos[3];\n    /* 0x0178 */ ColliderCylinder collider;\n    /* 0x01C4 */ SkelAnime skelAnime;\n    /* 0x0208 */ Vec3s jointTable[20];\n    /* 0x0258 */ Vec3s morphTable[20];\n} EnMagicSpell;\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_ON | AT_TYPE_PLAYER,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_1,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x00000002, 0x00, 0x01 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_ON | TOUCH_SFX_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 20, 30, 0, { 0, 0, 0 } },\n};\n\nvoid EnMagicSpell_Init(Actor* thisx, PlayState* play) {\n    EnMagicSpell* this = (EnMagicSpell*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    SkelAnime_InitFlex(play, &this->skelAnime, &gEffectSkel, &gEffectAnim, \n                       this->jointTable, this->morphTable, 20);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->spellState = 0;\n    this->spellPower = 0.0f;\n}\n\nvoid EnMagicSpell_Destroy(Actor* thisx, PlayState* play) {\n    EnMagicSpell* this = (EnMagicSpell*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnMagicSpell_Update(Actor* thisx, PlayState* play) {\n    EnMagicSpell* this = (EnMagicSpell*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    // Only cast if player has enough magic\n    if (gSaveContext.magic >= 4) {\n        switch(this->spellState) {\n            case 0: // Charging\n                if (this->timer > 10) {\n                    this->spellState = 1;\n                    gSaveContext.magic -= 4; // Consume magic\n                }\n                Math_SmoothStepToF(&this->spellPower, 1.0f, 0.1f, 0.2f, 0.01f);\n                break;\n                \n            case 1: // Active\n                Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 20.0f, \n                                      UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n                \n                Collider_UpdateCylinder(&this->actor, &this->collider);\n                CollisionCheck_SetAT(play, &play->colChkCtx, &this->collider.base);\n                \n                if (this->timer > 30) {\n                    Actor_Kill(&this->actor);\n                }\n                break;\n        }\n    }\n}\n\nvoid EnMagicSpell_Draw(Actor* thisx, PlayState* play) {\n    EnMagicSpell* this = (EnMagicSpell*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Push();\n    Matrix_Scale(this->spellPower, this->spellPower, this->spellPower, MTXMODE_APPLY);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n              \n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                          this->skelAnime.dListCount, NULL, NULL, this);\n    \n    Matrix_Pop();\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_MagicSpell_InitVars = {\n    /**/ ACTOR_EN_MAGIC_SPELL,\n    /**/ ACTORCAT_MISC,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnMagicSpell),\n    /**/ EnMagicSpell_Init,\n    /**/ EnMagicSpell_Destroy,\n    /**/ EnMagicSpell_Update,\n    /**/ EnMagicSpell_Draw\n};\n```\"\n}"}
{"instruction": "Create a effect system system", "output": "{\n  \"instruction\": \"Create a Saria's Song effect that calls for help using memory-safe practices\",\n  \"input\": null,\n  \"output\": \"```c\n// Actor that creates a Saria's Song effect when played\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 effectState;\n    /* 0x0150 */ f32 alpha;\n    /* 0x0154 */ Vec3f effectPos[8];\n    /* 0x01B4 */ ColliderCylinder collider;\n} EnSariaEffect; // size = 0x200\n\nvoid EnSariaEffect_Init(Actor* thisx, PlayState* play) {\n    EnSariaEffect* this = (EnSariaEffect*)thisx;\n    s32 i;\n\n    Actor_SetScale(&this->actor, 0.01f);\n    \n    // Initialize effect positions in a circle\n    for (i = 0; i < 8; i++) {\n        this->effectPos[i].x = Math_SinS(i * 0x2000) * 30.0f;\n        this->effectPos[i].y = 0.0f;\n        this->effectPos[i].z = Math_CosS(i * 0x2000) * 30.0f;\n    }\n    \n    this->timer = 0;\n    this->effectState = 0;\n    this->alpha = 255.0f;\n\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n}\n\nvoid EnSariaEffect_Destroy(Actor* thisx, PlayState* play) {\n    EnSariaEffect* this = (EnSariaEffect*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnSariaEffect_Update(Actor* thisx, PlayState* play) {\n    EnSariaEffect* this = (EnSariaEffect*)thisx;\n    Player* player = GET_PLAYER(play);\n    s32 i;\n\n    this->timer++;\n\n    switch (this->effectState) {\n        case 0:\n            // Spiral upward\n            for (i = 0; i < 8; i++) {\n                this->effectPos[i].y += 2.0f;\n                this->effectPos[i].x = Math_SinS(this->timer * 0x800 + i * 0x2000) * (30.0f + this->effectPos[i].y * 0.1f);\n                this->effectPos[i].z = Math_CosS(this->timer * 0x800 + i * 0x2000) * (30.0f + this->effectPos[i].y * 0.1f);\n            }\n            \n            if (this->timer >= 60) {\n                this->effectState = 1;\n                this->timer = 0;\n            }\n            break;\n\n        case 1:\n            // Fade out\n            Math_SmoothStepToF(&this->alpha, 0.0f, 0.1f, 10.0f, 0.1f);\n            if (this->alpha <= 0.0f) {\n                Actor_Kill(&this->actor);\n            }\n            break;\n    }\n}\n\nvoid EnSariaEffect_Draw(Actor* thisx, PlayState* play) {\n    EnSariaEffect* this = (EnSariaEffect*)thisx;\n    s32 i;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    gDPSetPrimColor(POLY_XLU_DISP++, 0, 0, 100, 255, 100, (u8)this->alpha);\n    \n    for (i = 0; i < 8; i++) {\n        Matrix_Push();\n        Matrix_Translate(this->effectPos[i].x, this->effectPos[i].y, this->effectPos[i].z, MTXMODE_NEW);\n        Matrix_Scale(0.2f, 0.2f, 0.2f, MTXMODE_APPLY);\n        gSPMatrix(POLY_XLU_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__),\n                 G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n        gSPDisplayList(POLY_XLU_DISP++, gEffSparklesDL);\n        Matrix_Pop();\n    }\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_SariaEffect_InitVars = {\n    /**/ ACTOR_EN_SARIA_EFFECT,\n    /**/ ACTORCAT_MISC,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnSariaEffect),\n    /**/ EnSariaEffect_Init,\n    /**/ EnSariaEffect_Destroy,\n    /**/ EnSariaEffect_Update,\n    /**/ EnSariaEffect_Draw\n};\n```\"\n}"}
{"instruction": "Create a code explanation system", "output": "{\n  \"instruction\": \"Implement a complex code explanation system for enhanced gameplay implementing multiple subsystems\",\n  \"input\": null,\n  \"output\": \"// Authentic pattern for tutorial hint system actor\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 messageState;\n    /* 0x0150 */ f32 displayRange;\n    /* 0x0154 */ s16 textId;\n    /* 0x0156 */ s16 interactState;\n    /* 0x0158 */ ColliderCylinder collider;\n} EnHintSystem; // size = 0x1A4\n\nvoid EnHintSystem_Init(Actor* thisx, PlayState* play) {\n    EnHintSystem* this = (EnHintSystem*)thisx;\n    \n    // Authentic collision setup\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->displayRange = 100.0f;\n    this->messageState = 0;\n    this->textId = 0x1000; // Starting text ID\n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnHintSystem_Update(Actor* thisx, PlayState* play) {\n    EnHintSystem* this = (EnHintSystem*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    // Authentic distance check pattern\n    f32 dist = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    if (dist < this->displayRange) {\n        if (Actor_TalkOfferAccepted(&this->actor, play)) {\n            this->messageState = 1;\n            Message_StartTextbox(play, this->textId, NULL);\n        } else if (!Message_GetState(&play->msgCtx)) {\n            Actor_OfferTalk(&this->actor, play, this->displayRange);\n        }\n    }\n    \n    // Authentic collision update\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    // Authentic ground alignment\n    Actor_UpdateBgCheckInfo(play, &this->actor, 0.0f, 0.0f, 0.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n}\n\nvoid EnHintSystem_Draw(Actor* thisx, PlayState* play) {\n    EnHintSystem* this = (EnHintSystem*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__), \n              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);\n    gSPDisplayList(POLY_OPA_DISP++, gEffFlash1DL);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_HintSystem_InitVars = {\n    /**/ ACTOR_EN_HINT_SYSTEM,\n    /**/ ACTORCAT_NPC,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnHintSystem),\n    /**/ EnHintSystem_Init,\n    /**/ EnHintSystem_Destroy,\n    /**/ EnHintSystem_Update,\n    /**/ EnHintSystem_Draw\n};\"\n}"}
{"instruction": "Create a effect system system", "output": "{\n  \"instruction\": \"Implement a Song of Storms effect that creates rain with basic debugging support\",\n  \"input\": null,\n  \"output\": \"```c\n// Authentic pattern following z_actor.h and z_effect_ss.h\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 rainCount;\n    /* 0x0150 */ Vec3f rainOrigin;\n    /* 0x015C */ f32 radius;\n} EffStorm; // size = 0x160\n\nvoid EffStorm_Init(Actor* thisx, PlayState* play) {\n    EffStorm* this = (EffStorm*)thisx;\n    \n    this->timer = 100;\n    this->rainCount = 20;\n    this->radius = 100.0f;\n    \n    // Set initial position as spawn point\n    this->rainOrigin = this->actor.world.pos;\n    \n    // Standard actor setup\n    Actor_SetScale(&this->actor, 0.1f);\n}\n\nvoid EffStorm_Destroy(Actor* thisx, PlayState* play) {\n    // Nothing to clean up\n}\n\nvoid EffStorm_Update(Actor* thisx, PlayState* play) {\n    EffStorm* this = (EffStorm*)thisx;\n    s32 i;\n    Vec3f pos;\n    Vec3f vel = { 0.0f, -8.0f, 0.0f }; // Rain falls downward\n    \n    if (this->timer > 0) {\n        this->timer--;\n        \n        // Spawn rain particles within radius\n        for (i = 0; i < this->rainCount; i++) {\n            f32 angle = Rand_ZeroFloat(M_PI * 2);\n            f32 dist = Rand_ZeroFloat(this->radius);\n            \n            pos.x = this->rainOrigin.x + (cosf(angle) * dist);\n            pos.y = this->rainOrigin.y + 200.0f; // Start above\n            pos.z = this->rainOrigin.z + (sinf(angle) * dist);\n            \n            // Use authentic particle effect\n            EffectSsGSplash_Spawn(play, &pos, &vel, &vel, 0, 400);\n        }\n    } else {\n        Actor_Kill(&this->actor);\n    }\n}\n\nvoid EffStorm_Draw(Actor* thisx, PlayState* play) {\n    // No visual model to draw\n}\n\nconst ActorProfile Eff_Storm_InitVars = {\n    /**/ ACTOR_EFF_STORM,\n    /**/ ACTORCAT_MISC,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EffStorm),\n    /**/ EffStorm_Init,\n    /**/ EffStorm_Destroy, \n    /**/ EffStorm_Update,\n    /**/ EffStorm_Draw\n};\n```\"\n}"}
{"instruction": "Create a ai behavior system", "output": "{\n  \"instruction\": \"Make a Ocarina playing and song system using common practices\",\n  \"input\": null,\n  \"output\": \"// Authentic pattern based on OoT's ocarina system\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 songTimer;\n    /* 0x014E */ s16 songState;\n    /* 0x0150 */ u8 songNotes[8];\n    /* 0x0158 */ u8 noteIndex;\n    /* 0x0159 */ u8 songPlaying;\n    /* 0x015A */ s16 actionTimer;\n    /* 0x015C */ ColliderCylinder collider;\n} EnOcarina; // size = 0x1A8\n\n// Note patterns for songs (authentic note values from OoT)\nstatic u8 sSariaSongNotes[] = {\n    OCARINA_NOTE_F, OCARINA_NOTE_A, OCARINA_NOTE_B,\n    OCARINA_NOTE_F, OCARINA_NOTE_A, OCARINA_NOTE_B\n};\n\nstatic u8 sEponasSongNotes[] = {\n    OCARINA_NOTE_D, OCARINA_NOTE_B, OCARINA_NOTE_A,\n    OCARINA_NOTE_D, OCARINA_NOTE_B, OCARINA_NOTE_A\n};\n\nvoid EnOcarina_Init(Actor* thisx, PlayState* play) {\n    EnOcarina* this = (EnOcarina*)thisx;\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->songState = 0;\n    this->songTimer = 0;\n    this->noteIndex = 0;\n    this->songPlaying = false;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnOcarina_Update(Actor* thisx, PlayState* play) {\n    EnOcarina* this = (EnOcarina*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    if (Actor_WorldDistXZToActor(&this->actor, &player->actor) < 100.0f) {\n        if (gSaveContext.inventory.items[SLOT_OCARINA] != ITEM_NONE) {\n            // Check if player is in ocarina state\n            if (player->stateFlags2 & PLAYER_STATE2_OCARINA_PLAYING) {\n                this->songPlaying = true;\n                \n                // Store played notes\n                if (play->msgCtx.lastPlayedSong != 0xFF) {\n                    this->songNotes[this->noteIndex++] = play->msgCtx.lastPlayedSong;\n                    \n                    // Check song patterns\n                    if (this->noteIndex >= 6) {\n                        s32 matchSaria = true;\n                        s32 matchEpona = true;\n                        \n                        for (s32 i = 0; i < 6; i++) {\n                            if (this->songNotes[i] != sSariaSongNotes[i]) {\n                                matchSaria = false;\n                            }\n                            if (this->songNotes[i] != sEponasSongNotes[i]) {\n                                matchEpona = false;\n                            }\n                        }\n                        \n                        if (matchSaria) {\n                            // Handle Saria's Song effect\n                            this->songState = 1;\n                            this->actionTimer = 30;\n                        } else if (matchEpona) {\n                            // Handle Epona's Song effect  \n                            this->songState = 2;\n                            this->actionTimer = 30;\n                        }\n                        \n                        this->noteIndex = 0;\n                    }\n                }\n            } else {\n                this->songPlaying = false;\n                this->noteIndex = 0;\n            }\n        }\n    }\n    \n    if (this->actionTimer > 0) {\n        this->actionTimer--;\n    }\n    \n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 50.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n}\n\nconst ActorProfile EnOcarina_Profile = {\n    /**/ ACTOR_EN_OCARINA,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnOcarina),\n    /**/ EnOcarina_Init,\n    /**/ EnOcarina_Destroy,\n    /**/ EnOcarina_Update,\n    /**/ NULL\n};\"\n}"}
{"instruction": "Create a combat system system", "output": "{\n  \"instruction\": \"Implement a Sword combat with different attack patterns with reasonable performance\",\n  \"input\": null,\n  \"output\": \"```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 actionState;\n    /* 0x014E */ s16 attackTimer;\n    /* 0x0150 */ s16 comboPhase;\n    /* 0x0152 */ s16 damageTimer;\n    /* 0x0154 */ f32 attackRange;\n    /* 0x0158 */ ColliderCylinder bodyCollider;\n    /* 0x01A4 */ ColliderQuad swordCollider;\n    /* 0x0224 */ Vec3f swordTip;\n    /* 0x0230 */ Vec3f swordBase;\n    /* 0x023C */ SkelAnime skelAnime;\n    /* 0x0280 */ Vec3s jointTable[25];\n    /* 0x02E6 */ Vec3s morphTable[25];\n} EnSwordEnemy;\n\n#define SWORD_ENEMY_ATTACK_RANGE 150.0f\n#define SWORD_ENEMY_DAMAGE_TIME 20\n\nvoid EnSwordEnemy_Init(Actor* thisx, PlayState* play) {\n    EnSwordEnemy* this = (EnSwordEnemy*)thisx;\n    \n    SkelAnime_InitFlex(play, &this->skelAnime, &gStalfosSkel, &gStalfosIdleAnim, \n                       this->jointTable, this->morphTable, 25);\n    \n    Collider_InitCylinder(play, &this->bodyCollider);\n    Collider_SetCylinder(play, &this->bodyCollider, &this->actor, &sBodyColInit);\n    \n    Collider_InitQuad(play, &this->swordCollider);\n    Collider_SetQuad(play, &this->swordCollider, &this->actor, &sSwordColInit);\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    this->actor.colChkInfo.mass = MASS_HEAVY;\n    this->attackRange = SWORD_ENEMY_ATTACK_RANGE;\n    \n    this->actionState = 0;\n    this->attackTimer = 0;\n    this->comboPhase = 0;\n}\n\nvoid EnSwordEnemy_UpdateAttackCollider(EnSwordEnemy* this) {\n    Vec3f swordTip;\n    Vec3f swordBase;\n    \n    swordBase = this->swordBase;\n    swordTip = this->swordTip;\n    \n    Collider_SetQuadVertices(&this->swordCollider, &swordBase, &swordTip, &swordBase, &swordTip);\n}\n\nvoid EnSwordEnemy_SetAttackPattern(EnSwordEnemy* this, PlayState* play) {\n    Player* player = GET_PLAYER(play);\n    f32 distToPlayer = Actor_WorldDistXZToActor(&this->actor, &player->actor);\n    \n    if (distToPlayer < this->attackRange && this->attackTimer == 0) {\n        s16 angleToPlayer = Actor_WorldYawTowardActor(&this->actor, &player->actor);\n        \n        if (ABS((s16)(angleToPlayer - this->actor.world.rot.y)) < 0x2000) {\n            this->actionState = 1;\n            this->attackTimer = 30;\n            this->comboPhase = (this->comboPhase + 1) % 3;\n            \n            switch(this->comboPhase) {\n                case 0:\n                    Animation_Change(&this->skelAnime, &gStalfosSlashAnim, 1.5f, 0.0f, \n                                  Animation_GetLastFrame(&gStalfosSlashAnim), ANIMMODE_ONCE, -3.0f);\n                    break;\n                case 1:\n                    Animation_Change(&this->skelAnime, &gStalfosStabAnim, 1.2f, 0.0f,\n                                  Animation_GetLastFrame(&gStalfosStabAnim), ANIMMODE_ONCE, -3.0f);\n                    break;\n                case 2:\n                    Animation_Change(&this->skelAnime, &gStalfosSpinAnim, 1.8f, 0.0f,\n                                  Animation_GetLastFrame(&gStalfosSpinAnim), ANIMMODE_ONCE, -3.0f);\n                    break;\n            }\n        }\n    }\n}\n\nvoid EnSwordEnemy_Update(Actor* thisx, PlayState* play) {\n    EnSwordEnemy* this = (EnSwordEnemy*)thisx;\n    s32 pad;\n    \n    if (this->damageTimer > 0) {\n        this->damageTimer--;\n    }\n    \n    if (this->attackTimer > 0) {\n        this->attackTimer--;\n    }\n    \n    SkelAnime_Update(&this->skelAnime);\n    \n    switch(this->actionState) {\n        case 0: // Idle/Chase\n            EnSwordEnemy_SetAttackPattern(this, play);\n            break;\n            \n        case 1: // Attack\n            if (Animation_OnFrame(&this->skelAnime, this->skelAnime.endFrame)) {\n                this->actionState = 0;\n            }\n            break;\n    }\n    \n    // Update colliders\n    Collider_UpdateCylinder(&this->actor, &this->bodyCollider);\n    EnSwordEnemy_UpdateAttackCollider(this);\n    \n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->bodyCollider.base);\n    \n    if (this->actionState == 1) {\n        CollisionCheck_SetAT(play, &play->colChkCtx, &this->swordCollider.base);\n    }\n    \n    // Basic movement and collision\n    Actor_UpdateBgCheckInfo(play, &this->actor, 35.0f, 60.0f, 60.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n}\n\nvoid EnSwordEnemy_Draw(Actor* thisx, PlayState* play) {\n    EnSwordEnemy* this = (EnSwordEnemy*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                         this->skelAnime.dListCount, NULL, NULL, this);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_SwordEnemy_InitVars = {\n    /**/ ACTOR_EN_SWORD_ENEMY,\n    /**/ ACTORCAT_ENEMY,\n    /**/ FLAGS,\n    /**/ OBJECT_STALFOS,\n    /**/ sizeof(EnSwordEnemy),\n    /**/ EnSwordEnemy_Init,\n    /**/ EnSwordEnemy_Destroy,\n    /**/ EnSwordEnemy_Update,\n    /**/ EnSwordEnemy_Draw\n};\n```\"\n}"}
{"instruction": "Create an advanced memory management with multiple features implementing standard patterns", "output": "// Memory management patterns using authentic OoT functions\n\n#include \"global.h\"\n\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 state;\n    /* 0x0150 */ void* allocPtr;\n    /* 0x0154 */ u32 allocSize;\n    /* 0x0158 */ ColliderCylinder collider;\n} EnMemMgr; // size = 0x1A4\n\nvoid EnMemMgr_Init(Actor* thisx, PlayState* play) {\n    EnMemMgr* this = (EnMemMgr*)thisx;\n    \n    // Initialize collision using authentic pattern\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->timer = 0;\n    this->state = 0;\n    this->allocPtr = NULL;\n    this->allocSize = 0;\n    \n    // Use authentic ZeldaArena functions\n    this->allocPtr = ZeldaArena_Malloc(0x100);\n    if (this->allocPtr != NULL) {\n        this->allocSize = 0x100;\n    }\n    \n    Actor_SetScale(&this->actor, 0.01f);\n}\n\nvoid EnMemMgr_Destroy(Actor* thisx, PlayState* play) {\n    EnMemMgr* this = (EnMemMgr*)thisx;\n    \n    // Free allocated memory using authentic pattern\n    if (this->allocPtr != NULL) {\n        ZeldaArena_Free(this->allocPtr);\n        this->allocPtr = NULL;\n        this->allocSize = 0;\n    }\n    \n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnMemMgr_Update(Actor* thisx, PlayState* play) {\n    EnMemMgr* this = (EnMemMgr*)thisx;\n    Player* player = GET_PLAYER(play);\n    \n    this->timer++;\n    \n    // Example memory reallocation pattern\n    if (this->timer == 60) {\n        if (this->allocPtr != NULL) {\n            ZeldaArena_Free(this->allocPtr);\n            this->allocPtr = ZeldaArena_Malloc(0x200);\n            if (this->allocPtr != NULL) {\n                this->allocSize = 0x200;\n            }\n        }\n        this->timer = 0;\n    }\n    \n    // Authentic collision update pattern\n    Actor_UpdateBgCheckInfo(play, &this->actor, 35.0f, 60.0f, 0.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnMemMgr_Draw(Actor* thisx, PlayState* play) {\n    EnMemMgr* this = (EnMemMgr*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, this->actor.scale.z, MTXMODE_APPLY);\n    Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_MemMgr_InitVars = {\n    /**/ ACTOR_EN_MEMMGR,\n    /**/ ACTORCAT_PROP,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnMemMgr),\n    /**/ EnMemMgr_Init,\n    /**/ EnMemMgr_Destroy,\n    /**/ EnMemMgr_Update,\n    /**/ EnMemMgr_Draw\n};"}
{"instruction": "Create a animation system system", "output": "{\n  \"instruction\": \"Create a blend tree system for smooth animation transitions implementing multiple subsystems\",\n  \"input\": null,\n  \"output\": \"// Authentic blend tree system following OoT patterns\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ SkelAnime skelAnime;\n    /* 0x0190 */ Vec3s jointTable[20];\n    /* 0x01F0 */ Vec3s morphTable[20];\n    /* 0x0250 */ s16 blendTimer;\n    /* 0x0252 */ s16 blendFrames;\n    /* 0x0254 */ f32 blendWeight;\n    /* 0x0258 */ AnimationHeader* currentAnim;\n    /* 0x025C */ AnimationHeader* nextAnim;\n    /* 0x0260 */ ColliderCylinder collider;\n} EnBlendActor;\n\nvoid EnBlendActor_Init(Actor* thisx, PlayState* play) {\n    EnBlendActor* this = (EnBlendActor*)thisx;\n    \n    SkelAnime_InitFlex(play, &this->skelAnime, &gSomeSkeleton, NULL, \n                       this->jointTable, this->morphTable, 20);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->blendTimer = 0;\n    this->blendFrames = 0;\n    this->blendWeight = 0.0f;\n    this->currentAnim = &gSomeIdleAnim;\n    this->nextAnim = NULL;\n    \n    // Start with idle animation\n    Animation_Change(&this->skelAnime, this->currentAnim, 1.0f, 0.0f,\n                    Animation_GetLastFrame(this->currentAnim), ANIMMODE_LOOP, 0.0f);\n}\n\nvoid EnBlendActor_Update(Actor* thisx, PlayState* play) {\n    EnBlendActor* this = (EnBlendActor*)thisx;\n    \n    if (this->blendTimer > 0) {\n        this->blendTimer--;\n        \n        // Calculate blend weight\n        f32 step = 1.0f / this->blendFrames;\n        Math_SmoothStepToF(&this->blendWeight, 1.0f, 0.3f, step, 0.0f);\n        \n        if (this->blendTimer == 0) {\n            // Transition complete - set new animation as current\n            this->currentAnim = this->nextAnim;\n            this->nextAnim = NULL;\n            this->blendWeight = 0.0f;\n            Animation_Change(&this->skelAnime, this->currentAnim, 1.0f, 0.0f,\n                           Animation_GetLastFrame(this->currentAnim), ANIMMODE_LOOP, 0.0f);\n        }\n    }\n    \n    // Update skelAnime\n    SkelAnime_Update(&this->skelAnime);\n    \n    // Update collision\n    Actor_UpdateBgCheckInfo(play, &this->actor, 20.0f, 20.0f, 50.0f, \n                           UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnBlendActor_Draw(Actor* thisx, PlayState* play) {\n    EnBlendActor* this = (EnBlendActor*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    if (this->blendTimer > 0 && this->nextAnim != NULL) {\n        // Draw blended animation\n        SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                             this->skelAnime.dListCount, NULL, NULL, this);\n    } else {\n        // Draw normal animation\n        SkelAnime_DrawFlexOpa(play, this->skelAnime.skeleton, this->skelAnime.jointTable,\n                             this->skelAnime.dListCount, NULL, NULL, this);\n    }\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_BlendActor_InitVars = {\n    /**/ ACTOR_EN_BLEND_ACTOR,\n    /**/ ACTORCAT_NPC,\n    /**/ FLAGS,\n    /**/ OBJECT_BLEND_ACTOR,\n    /**/ sizeof(EnBlendActor),\n    /**/ EnBlendActor_Init,\n    /**/ EnBlendActor_Destroy,\n    /**/ EnBlendActor_Update,\n    /**/ EnBlendActor_Draw\n};\"\n}"}
{"instruction": "Create a ai behavior system", "output": "{\n  \"instruction\": \"Make a Bomb throwing and explosion mechanics implementing common features\",\n  \"input\": null,\n  \"output\": \"```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 timer;\n    /* 0x014E */ s16 explosionState;\n    /* 0x0150 */ f32 scale;\n    /* 0x0154 */ ColliderCylinder collider;\n    /* 0x01A0 */ Vec3f velocity;\n} EnBomb; // size = 0x1AC\n\nstatic ColliderCylinderInit sCylinderInit = {\n    {\n        COLTYPE_NONE,\n        AT_ON | AT_TYPE_EXPLOSIVE,\n        AC_ON | AC_TYPE_PLAYER,\n        OC1_ON | OC1_TYPE_ALL,\n        OC2_TYPE_2,\n        COLSHAPE_CYLINDER,\n    },\n    {\n        ELEMTYPE_UNK0,\n        { 0x20000000, 0x01, 0x04 },\n        { 0xFFCFFFFF, 0x00, 0x00 },\n        TOUCH_ON | TOUCH_SFX_NONE,\n        BUMP_ON,\n        OCELEM_ON,\n    },\n    { 12, 25, 0, { 0, 0, 0 } },\n};\n\nvoid EnBomb_Init(Actor* thisx, PlayState* play) {\n    EnBomb* this = (EnBomb*)thisx;\n    \n    Actor_SetScale(&this->actor, 0.01f);\n    \n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->timer = 70;\n    this->explosionState = 0;\n    this->actor.gravity = -1.0f;\n    \n    // Initial throw velocity\n    this->velocity.x = Math_SinS(this->actor.world.rot.y) * 8.0f;\n    this->velocity.y = 10.0f;\n    this->velocity.z = Math_CosS(this->actor.world.rot.y) * 8.0f;\n}\n\nvoid EnBomb_Destroy(Actor* thisx, PlayState* play) {\n    EnBomb* this = (EnBomb*)thisx;\n    Collider_DestroyCylinder(play, &this->collider);\n}\n\nvoid EnBomb_Update(Actor* thisx, PlayState* play) {\n    EnBomb* this = (EnBomb*)thisx;\n    \n    // Update position based on velocity\n    this->actor.world.pos.x += this->velocity.x;\n    this->actor.world.pos.y += this->velocity.y;\n    this->actor.world.pos.z += this->velocity.z;\n    \n    // Apply gravity\n    this->velocity.y += this->actor.gravity;\n    \n    // Check ground collision\n    Actor_UpdateBgCheckInfo(play, &this->actor, 15.0f, 20.0f, 0.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    \n    if (this->actor.bgCheckFlags & UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2) {\n        this->velocity.x = 0.0f;\n        this->velocity.y = 0.0f;\n        this->velocity.z = 0.0f;\n        this->actor.velocity.y = 0.0f;\n    }\n    \n    // Update timer and handle explosion\n    if (--this->timer <= 0) {\n        Actor_SpawnAsChild(&play->actorCtx, &this->actor, play, ACTOR_EN_BOMBF, \n            this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z,\n            0, 0, 0, 0);\n        Actor_Kill(&this->actor);\n        return;\n    }\n    \n    // Update collision detection\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);\n}\n\nvoid EnBomb_Draw(Actor* thisx, PlayState* play) {\n    EnBomb* this = (EnBomb*)thisx;\n    \n    OPEN_DISPS(play->state.gfxCtx);\n    \n    Gfx_SetupDL_25Opa(play->state.gfxCtx);\n    \n    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z, MTXMODE_NEW);\n    Matrix_Scale(this->actor.scale.x, this->actor.scale.y, this->actor.scale.z, MTXMODE_APPLY);\n    \n    gSPMatrix(POLY_OPA_DISP++, Matrix_NewMtx(play->state.gfxCtx, __FILE__, __LINE__), \n        G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);\n    \n    gSPDisplayList(POLY_OPA_DISP++, gBombDL);\n    \n    CLOSE_DISPS(play->state.gfxCtx);\n}\n\nconst ActorProfile En_Bomb_InitVars = {\n    /**/ ACTOR_EN_BOMB,\n    /**/ ACTORCAT_MISC,\n    /**/ FLAGS,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnBomb),\n    /**/ EnBomb_Init,\n    /**/ EnBomb_Destroy,\n    /**/ EnBomb_Update,\n    /**/ EnBomb_Draw\n};\n```\"\n}"}
