{"instruction": "Create a combat system system", "output": "{\n  \"instruction\": \"Create a Transformation mask mechanics (Deku, Goron, Zora) with extensive error handling and edge cases\",\n  \"input\": null,\n  \"output\": \"\n```c\ntypedef struct {\n    /* 0x0000 */ Actor actor;\n    /* 0x014C */ s16 transformState;\n    /* 0x014E */ s16 transformTimer;\n    /* 0x0150 */ s16 prevTransformState;\n    /* 0x0152 */ s16 transformLock; \n    /* 0x0154 */ f32 transformScale;\n    /* 0x0158 */ ColliderCylinder collider;\n} EnTransform; // size = 0x1A4\n\n// Transform states matching mask types\n#define TRANSFORM_STATE_HUMAN     0\n#define TRANSFORM_STATE_DEKU      1\n#define TRANSFORM_STATE_GORON     2\n#define TRANSFORM_STATE_ZORA      3\n\n// Error states\n#define TRANSFORM_ERROR_NONE      0\n#define TRANSFORM_ERROR_WATER     1\n#define TRANSFORM_ERROR_LAVA      2\n#define TRANSFORM_ERROR_LOCKED    3\n\nvoid EnTransform_Init(Actor* thisx, PlayState* play) {\n    EnTransform* this = (EnTransform*)thisx;\n    \n    // Initialize collision using authentic pattern\n    Collider_InitCylinder(play, &this->collider);\n    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);\n    \n    this->transformState = TRANSFORM_STATE_HUMAN;\n    this->prevTransformState = TRANSFORM_STATE_HUMAN;\n    this->transformTimer = 0;\n    this->transformLock = 0;\n    this->transformScale = 0.01f;\n    \n    Actor_SetScale(&this->actor, this->transformScale);\n    Actor_SetFocus(&this->actor, 50.0f);\n}\n\ns16 EnTransform_CheckTransformErrors(EnTransform* this, PlayState* play) {\n    WaterBox* waterBox;\n    f32 waterSurface;\n    \n    // Check if in water\n    if (WaterBox_GetSurface1(play, &play->colCtx, this->actor.world.pos.x,\n        this->actor.world.pos.z, &waterSurface, &waterBox)) {\n        if (this->actor.world.pos.y < waterSurface) {\n            if (this->transformState == TRANSFORM_STATE_GORON) {\n                return TRANSFORM_ERROR_WATER;\n            }\n        }\n    }\n    \n    // Check if transformation is locked\n    if (this->transformLock) {\n        return TRANSFORM_ERROR_LOCKED;\n    }\n    \n    // Check lava collision for non-Goron forms\n    if (this->actor.bgCheckFlags & BGCHECKFLAG_LAVA) {\n        if (this->transformState != TRANSFORM_STATE_GORON) {\n            return TRANSFORM_ERROR_LAVA;\n        }\n    }\n    \n    return TRANSFORM_ERROR_NONE;\n}\n\nvoid EnTransform_HandleTransformation(EnTransform* this, PlayState* play) {\n    s16 error = EnTransform_CheckTransformErrors(this, play);\n    \n    if (error != TRANSFORM_ERROR_NONE) {\n        // Revert to previous valid state on error\n        this->transformState = this->prevTransformState;\n        return;\n    }\n    \n    switch(this->transformState) {\n        case TRANSFORM_STATE_DEKU:\n            this->transformScale = 0.008f;\n            Actor_SetScale(&this->actor, this->transformScale);\n            // Adjust collision cylinder for Deku form\n            this->collider.dim.radius = 15;\n            this->collider.dim.height = 35;\n            break;\n            \n        case TRANSFORM_STATE_GORON:\n            this->transformScale = 0.015f;\n            Actor_SetScale(&this->actor, this->transformScale);\n            // Adjust collision cylinder for Goron form\n            this->collider.dim.radius = 30;\n            this->collider.dim.height = 55;\n            break;\n            \n        case TRANSFORM_STATE_ZORA:\n            this->transformScale = 0.012f;\n            Actor_SetScale(&this->actor, this->transformScale);\n            // Adjust collision cylinder for Zora form\n            this->collider.dim.radius = 20;\n            this->collider.dim.height = 60;\n            break;\n            \n        case TRANSFORM_STATE_HUMAN:\n        default:\n            this->transformScale = 0.01f;\n            Actor_SetScale(&this->actor, this->transformScale);\n            // Reset collision cylinder for human form\n            this->collider.dim.radius = 20;\n            this->collider.dim.height = 50;\n            break;\n    }\n    \n    this->prevTransformState = this->transformState;\n}\n\nvoid EnTransform_Update(Actor* thisx, PlayState* play) {\n    EnTransform* this = (EnTransform*)thisx;\n    \n    // Update collision\n    Actor_UpdateBgCheckInfo(play, &this->actor, 26.0f, 10.0f, 0.0f, UPDBGCHECKINFO_FLAG_0 | UPDBGCHECKINFO_FLAG_2);\n    Collider_UpdateCylinder(&this->actor, &this->collider);\n    CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);\n    \n    if (this->transformTimer > 0) {\n        this->transformTimer--;\n        if (this->transformTimer == 0) {\n            this->transformLock = 0;\n        }\n    }\n    \n    EnTransform_HandleTransformation(this, play);\n    \n    // Handle movement based on form\n    Actor_MoveXZGravity(&this->actor);\n}\n\nconst ActorProfile EnTransform_Profile = {\n    /**/ ACTOR_EN_TRANSFORM,\n    /**/ ACTORCAT_PLAYER,\n    /**/ FLAGS_NONE,\n    /**/ OBJECT_GAMEPLAY_KEEP,\n    /**/ sizeof(EnTransform),\n    /**/ EnTransform_Init,\n    /**/ EnTransform_Destroy,\n    /**/ EnTransform_Update,\n    /**/ EnTransform_Draw,\n};\n```\"\n}"}
